/* tslint:disable */

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** Uuid */
  Uuid: any;
  /**
 * A signed eight-byte integer. The upper big integer values are greater then the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
 **/
  BigInt: any;
  Datetime: any;
  /** The day, does not include a time. */
  Date: any;
  Json: any;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: any;
  /** NaiveDateTime */
  NaiveDateTime: any;
  /** NaiveDate */
  NaiveDate: any;
  Upload: any;
  /**
 * A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
   * which securely represents claims between two parties.
 **/
  JwtToken: any;
}

/** All input for the `acceptInvite` mutation. */
export interface IAcceptInviteInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  inviteHash: Scalars["String"];
  email: Scalars["String"];
  firstName: Scalars["String"];
  lastName: Scalars["String"];
  age: Scalars["Int"];
  password: Scalars["String"];
}

/** The output of our `acceptInvite` mutation. */
export interface IAcceptInvitePayload {
   __typename?: "AcceptInvitePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `activateCoach` mutation. */
export interface IActivateCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  coachId: Scalars["Int"];
}

/** The output of our `activateCoach` mutation. */
export interface IActivateCoachPayload {
   __typename?: "ActivateCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `activateMember` mutation. */
export interface IActivateMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
}

/** The output of our `activateMember` mutation. */
export interface IActivateMemberPayload {
   __typename?: "ActivateMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface IAddDeviceMetaInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Id of device */
  deviceId: Scalars["String"];
  /** Platform (Operation System) */
  platform: Scalars["String"];
  /** Version of the app */
  version: Scalars["String"];
  /** Current timezone */
  timezone?: Maybe<Scalars["String"]>;
  /** JSON object with available permissions */
  permissions: Scalars["String"];
}

export interface IAddDeviceMetaPayload {
   __typename?: "AddDeviceMetaPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IAddMealPhotoInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Date of meal */
  date: Scalars["NaiveDate"];
  /** Order in the list of meals */
  orderIndex: Scalars["Int"];
  /** Name of the meal */
  name?: Maybe<Scalars["String"]>;
  /** Path to file on the client */
  localPath?: Maybe<Scalars["String"]>;
}

export interface IAddMealPhotoPayload {
   __typename?: "AddMealPhotoPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Generated image object */
  image: IFoodJournalMealImage;
  /** Updated water volume */
  uploadLink: Scalars["String"];
}

export interface IAddProgressPictureInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Date of the photo */
  date: Scalars["NaiveDate"];
  /** Comment */
  comment?: Maybe<Scalars["String"]>;
  /** Path to file on the client */
  localPath?: Maybe<Scalars["String"]>;
  /** Is picture private only */
  isPrivate: Scalars["Boolean"];
}

export interface IAddProgressPicturePayload {
   __typename?: "AddProgressPicturePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Generated progress picture */
  picture: IProgressPicture;
  /** Upload link for progress picture */
  uploadLink: Scalars["String"];
}

/** All input for the `archiveCoach` mutation. */
export interface IArchiveCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  coachId: Scalars["Int"];
}

/** The output of our `archiveCoach` mutation. */
export interface IArchiveCoachPayload {
   __typename?: "ArchiveCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `archiveMember` mutation. */
export interface IArchiveMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
}

/** The output of our `archiveMember` mutation. */
export interface IArchiveMemberPayload {
   __typename?: "ArchiveMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `archiveWorkout` mutation. */
export interface IArchiveWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workoutId: Scalars["Uuid"];
}

/** The output of our `archiveWorkout` mutation. */
export interface IArchiveWorkoutPayload {
   __typename?: "ArchiveWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workout?: Maybe<IWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Workout`. May be used by Relay 1. */
  workoutEdge?: Maybe<IWorkoutsEdge>;
}

/** The output of our `archiveWorkout` mutation. */
export interface IArchiveWorkoutPayloadWorkoutEdgeArgs {
  orderBy?: Maybe<IWorkoutsOrderBy[]>;
}

/** All input for the `assignFeatures` mutation. */
export interface IAssignFeaturesInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  featureIds: Array<Maybe<Scalars["Uuid"]>>;
  userIds: Array<Maybe<Scalars["Uuid"]>>;
  comment?: Maybe<Scalars["String"]>;
}

/** The output of our `assignFeatures` mutation. */
export interface IAssignFeaturesPayload {
   __typename?: "AssignFeaturesPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  userFeatures?: Maybe<Array<Maybe<IUserFeature>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface IAssignJournalTargetsInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** List of user IDs */
  userIds: Array<Scalars["ID"]>;
  /** Journal target template ID */
  targetId: Scalars["ID"];
  /** Initial day of assignment */
  startDate: Scalars["NaiveDate"];
  /** Last day of assignment */
  endDate?: Maybe<Scalars["NaiveDate"]>;
  /** List of days of the week */
  weekdays: IWeekday[];
}

export interface IAssignJournalTargetsPayload {
   __typename?: "AssignJournalTargetsPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Assigned targets */
  targets: IFoodJournalUserTargetsConnection;
}

export enum IAssignmentFilter {
  All = "ALL",
  Active = "ACTIVE",
  Completed = "COMPLETED",
}

/** All input for the `assignTags` mutation. */
export interface IAssignTagsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  tags?: Maybe<Array<Maybe<Scalars["String"]>>>;
  members?: Maybe<Array<Maybe<Scalars["Int"]>>>;
}

/** The output of our `assignTags` mutation. */
export interface IAssignTagsPayload {
   __typename?: "AssignTagsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  tags?: Maybe<Array<Maybe<ITag>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<ITagsEdge>;
}

/** The output of our `assignTags` mutation. */
export interface IAssignTagsPayloadTagEdgeArgs {
  orderBy?: Maybe<ITagsOrderBy[]>;
}

export interface IAssignTrainingPlanInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of training plan to assign */
  trainingPlanId: Scalars["ID"];
  /** id of users to assign templates to */
  userIds: Array<Scalars["ID"]>;
  /** initial day of assignment, otherwise today */
  startDate?: Maybe<Scalars["NaiveDate"]>;
  /** last day of assignment, otherwise today + duration */
  endDate?: Maybe<Scalars["NaiveDate"]>;
}

export interface IAssignWorkoutTemplatesInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of workout templates to assign */
  workoutIds: Array<Scalars["ID"]>;
  /** id of users to assign templates to */
  userIds: Array<Scalars["ID"]>;
  /** initial day of assignment, otherwise infinite */
  startDate?: Maybe<Scalars["NaiveDate"]>;
  /** last day of assignment, otherwise infinite */
  endDate?: Maybe<Scalars["NaiveDate"]>;
}

export interface IAssignWorkoutTemplatesPayload {
   __typename?: "AssignWorkoutTemplatesPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IAttendance  extends INode {
   __typename?: "Attendance";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  sessionId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
  attended?: Maybe<Scalars["Boolean"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  isWalkIn: Scalars["Boolean"];
  id: Scalars["Uuid"];
  cancelled?: Maybe<Scalars["Boolean"]>;
  /** Reads a single `Session` that is related to this `Attendance`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Attendee` that is related to this `Attendance`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** Reads and enables pagination through a set of `AttendanceOverride`. */
  attendanceOverridesByAttendanceId: IAttendanceOverridesConnection;
  hasOverride?: Maybe<Scalars["Boolean"]>;
}

export interface IAttendanceAttendanceOverridesByAttendanceIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
  condition?: Maybe<IAttendanceOverrideCondition>;
}

/**
 * A condition to be used against `Attendance` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IAttendanceCondition {
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `attended` field. */
  attended?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `isWalkIn` field. */
  isWalkIn?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `cancelled` field. */
  cancelled?: Maybe<Scalars["Boolean"]>;
}

export interface IAttendanceHasOverrideFlagView {
   __typename?: "AttendanceHasOverrideFlagView";
  attendanceId?: Maybe<Scalars["Uuid"]>;
  hasOverride?: Maybe<Scalars["Boolean"]>;
}

/**
 * A condition to be used against `AttendanceHasOverrideFlagView` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 **/
export interface IAttendanceHasOverrideFlagViewCondition {
  /** Checks for equality with the object’s `attendanceId` field. */
  attendanceId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `hasOverride` field. */
  hasOverride?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `AttendanceHasOverrideFlagView` values. */
export interface IAttendanceHasOverrideFlagViewsConnection {
   __typename?: "AttendanceHasOverrideFlagViewsConnection";
  /** A list of `AttendanceHasOverrideFlagView` objects. */
  nodes: Array<Maybe<IAttendanceHasOverrideFlagView>>;
  /** A list of edges which contains the `AttendanceHasOverrideFlagView` and cursor to aid in pagination. */
  edges: IAttendanceHasOverrideFlagViewsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `AttendanceHasOverrideFlagView` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `AttendanceHasOverrideFlagView` edge in the connection. */
export interface IAttendanceHasOverrideFlagViewsEdge {
   __typename?: "AttendanceHasOverrideFlagViewsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `AttendanceHasOverrideFlagView` at the end of the edge. */
  node?: Maybe<IAttendanceHasOverrideFlagView>;
}

/** Methods to use when ordering `AttendanceHasOverrideFlagView`. */
export enum IAttendanceHasOverrideFlagViewsOrderBy {
  Natural = "NATURAL",
  AttendanceIdAsc = "ATTENDANCE_ID_ASC",
  AttendanceIdDesc = "ATTENDANCE_ID_DESC",
  HasOverrideAsc = "HAS_OVERRIDE_ASC",
  HasOverrideDesc = "HAS_OVERRIDE_DESC",
}

/** An input for mutations affecting `Attendance` */
export interface IAttendanceInput {
  sessionId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
  attended?: Maybe<Scalars["Boolean"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isWalkIn?: Maybe<Scalars["Boolean"]>;
  id?: Maybe<Scalars["Uuid"]>;
  cancelled?: Maybe<Scalars["Boolean"]>;
}

/**
 * This entity is to be used for providing an ability to override/shadow
 * bookings/attendances OR create overrides for a period of time for a given
 * attendee (can be used to implement suspension/snooze business logic).
 **/
export interface IAttendanceOverride  extends INode {
   __typename?: "AttendanceOverride";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  attendeeId: Scalars["Uuid"];
  fromDate?: Maybe<Scalars["Date"]>;
  toDate?: Maybe<Scalars["Date"]>;
  reason?: Maybe<Scalars["String"]>;
  /** (Optional) Ad-hoc overrides on attendance level. */
  attendanceId?: Maybe<Scalars["Uuid"]>;
  /** (Optional) Booking level overrides. */
  bookingId?: Maybe<Scalars["Uuid"]>;
  /**
 * (Optional) KS account ID. Override can potentially be created by a coach
   * (instructor) or a member. Account federation system is no guaranteed to exist
   * in the same schema as this table, hence the reference is weak.
 **/
  authorId?: Maybe<Scalars["String"]>;
  createdAt: Scalars["Datetime"];
  updatedAt: Scalars["Datetime"];
  /** Reads a single `Attendee` that is related to this `AttendanceOverride`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Attendance` that is related to this `AttendanceOverride`. */
  attendanceByAttendanceId?: Maybe<IAttendance>;
  /** Reads a single `Booking` that is related to this `AttendanceOverride`. */
  bookingByBookingId?: Maybe<IBooking>;
}

/**
 * A condition to be used against `AttendanceOverride` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IAttendanceOverrideCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `attendeeId` field. */
  attendeeId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `fromDate` field. */
  fromDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `toDate` field. */
  toDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `reason` field. */
  reason?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `attendanceId` field. */
  attendanceId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `bookingId` field. */
  bookingId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `AttendanceOverride` */
export interface IAttendanceOverrideInput {
  id?: Maybe<Scalars["Uuid"]>;
  attendeeId: Scalars["Uuid"];
  fromDate?: Maybe<Scalars["Date"]>;
  toDate?: Maybe<Scalars["Date"]>;
  reason?: Maybe<Scalars["String"]>;
  /** (Optional) Ad-hoc overrides on attendance level. */
  attendanceId?: Maybe<Scalars["Uuid"]>;
  /** (Optional) Booking level overrides. */
  bookingId?: Maybe<Scalars["Uuid"]>;
  /**
 * (Optional) KS account ID. Override can potentially be created by a coach
   * (instructor) or a member. Account federation system is no guaranteed to exist
   * in the same schema as this table, hence the reference is weak.
 **/
  authorId?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `AttendanceOverride`. Fields that are set will be updated. */
export interface IAttendanceOverridePatch {
  id?: Maybe<Scalars["Uuid"]>;
  attendeeId?: Maybe<Scalars["Uuid"]>;
  fromDate?: Maybe<Scalars["Date"]>;
  toDate?: Maybe<Scalars["Date"]>;
  reason?: Maybe<Scalars["String"]>;
  /** (Optional) Ad-hoc overrides on attendance level. */
  attendanceId?: Maybe<Scalars["Uuid"]>;
  /** (Optional) Booking level overrides. */
  bookingId?: Maybe<Scalars["Uuid"]>;
  /**
 * (Optional) KS account ID. Override can potentially be created by a coach
   * (instructor) or a member. Account federation system is no guaranteed to exist
   * in the same schema as this table, hence the reference is weak.
 **/
  authorId?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `AttendanceOverride` values. */
export interface IAttendanceOverridesConnection {
   __typename?: "AttendanceOverridesConnection";
  /** A list of `AttendanceOverride` objects. */
  nodes: Array<Maybe<IAttendanceOverride>>;
  /** A list of edges which contains the `AttendanceOverride` and cursor to aid in pagination. */
  edges: IAttendanceOverridesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `AttendanceOverride` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `AttendanceOverride` edge in the connection. */
export interface IAttendanceOverridesEdge {
   __typename?: "AttendanceOverridesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `AttendanceOverride` at the end of the edge. */
  node?: Maybe<IAttendanceOverride>;
}

/** Methods to use when ordering `AttendanceOverride`. */
export enum IAttendanceOverridesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  AttendeeIdAsc = "ATTENDEE_ID_ASC",
  AttendeeIdDesc = "ATTENDEE_ID_DESC",
  FromDateAsc = "FROM_DATE_ASC",
  FromDateDesc = "FROM_DATE_DESC",
  ToDateAsc = "TO_DATE_ASC",
  ToDateDesc = "TO_DATE_DESC",
  ReasonAsc = "REASON_ASC",
  ReasonDesc = "REASON_DESC",
  AttendanceIdAsc = "ATTENDANCE_ID_ASC",
  AttendanceIdDesc = "ATTENDANCE_ID_DESC",
  BookingIdAsc = "BOOKING_ID_ASC",
  BookingIdDesc = "BOOKING_ID_DESC",
  AuthorIdAsc = "AUTHOR_ID_ASC",
  AuthorIdDesc = "AUTHOR_ID_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `Attendance`. Fields that are set will be updated. */
export interface IAttendancePatch {
  sessionId?: Maybe<Scalars["Uuid"]>;
  personId?: Maybe<Scalars["Uuid"]>;
  attended?: Maybe<Scalars["Boolean"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isWalkIn?: Maybe<Scalars["Boolean"]>;
  id?: Maybe<Scalars["Uuid"]>;
  cancelled?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `Attendance` values. */
export interface IAttendancesConnection {
   __typename?: "AttendancesConnection";
  /** A list of `Attendance` objects. */
  nodes: Array<Maybe<IAttendance>>;
  /** A list of edges which contains the `Attendance` and cursor to aid in pagination. */
  edges: IAttendancesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Attendance` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Attendance` edge in the connection. */
export interface IAttendancesEdge {
   __typename?: "AttendancesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Attendance` at the end of the edge. */
  node?: Maybe<IAttendance>;
}

/** Methods to use when ordering `Attendance`. */
export enum IAttendancesOrderBy {
  Natural = "NATURAL",
  SessionIdAsc = "SESSION_ID_ASC",
  SessionIdDesc = "SESSION_ID_DESC",
  PersonIdAsc = "PERSON_ID_ASC",
  PersonIdDesc = "PERSON_ID_DESC",
  AttendedAsc = "ATTENDED_ASC",
  AttendedDesc = "ATTENDED_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  IsWalkInAsc = "IS_WALK_IN_ASC",
  IsWalkInDesc = "IS_WALK_IN_DESC",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  CancelledAsc = "CANCELLED_ASC",
  CancelledDesc = "CANCELLED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IAttendanceStatsByDateView {
   __typename?: "AttendanceStatsByDateView";
  date?: Maybe<Scalars["Date"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  numAttended?: Maybe<Scalars["BigInt"]>;
  numWalkIns?: Maybe<Scalars["BigFloat"]>;
  registered?: Maybe<Scalars["BigInt"]>;
  score?: Maybe<Scalars["Float"]>;
}

/**
 * A condition to be used against `AttendanceStatsByDateView` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 **/
export interface IAttendanceStatsByDateViewCondition {
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `numAttended` field. */
  numAttended?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `numWalkIns` field. */
  numWalkIns?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `registered` field. */
  registered?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `AttendanceStatsByDateView` values. */
export interface IAttendanceStatsByDateViewsConnection {
   __typename?: "AttendanceStatsByDateViewsConnection";
  /** A list of `AttendanceStatsByDateView` objects. */
  nodes: Array<Maybe<IAttendanceStatsByDateView>>;
  /** A list of edges which contains the `AttendanceStatsByDateView` and cursor to aid in pagination. */
  edges: IAttendanceStatsByDateViewsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `AttendanceStatsByDateView` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `AttendanceStatsByDateView` edge in the connection. */
export interface IAttendanceStatsByDateViewsEdge {
   __typename?: "AttendanceStatsByDateViewsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `AttendanceStatsByDateView` at the end of the edge. */
  node?: Maybe<IAttendanceStatsByDateView>;
}

/** Methods to use when ordering `AttendanceStatsByDateView`. */
export enum IAttendanceStatsByDateViewsOrderBy {
  Natural = "NATURAL",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  NumAttendedAsc = "NUM_ATTENDED_ASC",
  NumAttendedDesc = "NUM_ATTENDED_DESC",
  NumWalkInsAsc = "NUM_WALK_INS_ASC",
  NumWalkInsDesc = "NUM_WALK_INS_DESC",
  RegisteredAsc = "REGISTERED_ASC",
  RegisteredDesc = "REGISTERED_DESC",
  ScoreAsc = "SCORE_ASC",
  ScoreDesc = "SCORE_DESC",
}

export interface IAttendanceStatsByPersonView {
   __typename?: "AttendanceStatsByPersonView";
  personId?: Maybe<Scalars["Uuid"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  score?: Maybe<Scalars["Float"]>;
}

/**
 * A condition to be used against `AttendanceStatsByPersonView` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 **/
export interface IAttendanceStatsByPersonViewCondition {
  /** Checks for equality with the object’s `personId` field. */
  personId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `AttendanceStatsByPersonView` values. */
export interface IAttendanceStatsByPersonViewsConnection {
   __typename?: "AttendanceStatsByPersonViewsConnection";
  /** A list of `AttendanceStatsByPersonView` objects. */
  nodes: Array<Maybe<IAttendanceStatsByPersonView>>;
  /** A list of edges which contains the `AttendanceStatsByPersonView` and cursor to aid in pagination. */
  edges: IAttendanceStatsByPersonViewsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `AttendanceStatsByPersonView` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `AttendanceStatsByPersonView` edge in the connection. */
export interface IAttendanceStatsByPersonViewsEdge {
   __typename?: "AttendanceStatsByPersonViewsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `AttendanceStatsByPersonView` at the end of the edge. */
  node?: Maybe<IAttendanceStatsByPersonView>;
}

/** Methods to use when ordering `AttendanceStatsByPersonView`. */
export enum IAttendanceStatsByPersonViewsOrderBy {
  Natural = "NATURAL",
  PersonIdAsc = "PERSON_ID_ASC",
  PersonIdDesc = "PERSON_ID_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  ScoreAsc = "SCORE_ASC",
  ScoreDesc = "SCORE_DESC",
}

export interface IAttendee  extends INode {
   __typename?: "Attendee";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  ksUserId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  age?: Maybe<Scalars["Int"]>;
  gender?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  clubId?: Maybe<Scalars["Uuid"]>;
  status: IAttendeeStatus;
  ksAccountId?: Maybe<Scalars["String"]>;
  /** Reads a single `Club` that is related to this `Attendee`. */
  clubByClubId?: Maybe<IClub>;
  /** Reads and enables pagination through a set of `Booking`. */
  bookingsByPersonId: IBookingsConnection;
  /** Reads and enables pagination through a set of `ReservationRequest`. */
  reservationRequestsByPersonId: IReservationRequestsConnection;
  /** Reads and enables pagination through a set of `Attendance`. */
  attendancesByPersonId: IAttendancesConnection;
  /** Reads and enables pagination through a set of `AttendanceOverride`. */
  attendanceOverridesByAttendeeId: IAttendanceOverridesConnection;
  /** Reads and enables pagination through a set of `AttendeeClub`. */
  attendeeClubsByAttendeeId: IAttendeeClubsConnection;
  attendanceScore?: Maybe<Scalars["Float"]>;
}

export interface IAttendeeBookingsByPersonIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBookingsOrderBy[]>;
  condition?: Maybe<IBookingCondition>;
}

export interface IAttendeeReservationRequestsByPersonIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
  condition?: Maybe<IReservationRequestCondition>;
}

export interface IAttendeeAttendancesByPersonIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendancesOrderBy[]>;
  condition?: Maybe<IAttendanceCondition>;
}

export interface IAttendeeAttendanceOverridesByAttendeeIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
  condition?: Maybe<IAttendanceOverrideCondition>;
}

export interface IAttendeeAttendeeClubsByAttendeeIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
  condition?: Maybe<IAttendeeClubCondition>;
}

export interface IAttendeeClub  extends INode {
   __typename?: "AttendeeClub";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  attendeeId: Scalars["Uuid"];
  clubId: Scalars["Uuid"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Attendee` that is related to this `AttendeeClub`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Club` that is related to this `AttendeeClub`. */
  clubByClubId?: Maybe<IClub>;
}

/**
 * A condition to be used against `AttendeeClub` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IAttendeeClubCondition {
  /** Checks for equality with the object’s `attendeeId` field. */
  attendeeId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `AttendeeClub` */
export interface IAttendeeClubInput {
  attendeeId: Scalars["Uuid"];
  clubId: Scalars["Uuid"];
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `AttendeeClub`. Fields that are set will be updated. */
export interface IAttendeeClubPatch {
  attendeeId?: Maybe<Scalars["Uuid"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `AttendeeClub` values. */
export interface IAttendeeClubsConnection {
   __typename?: "AttendeeClubsConnection";
  /** A list of `AttendeeClub` objects. */
  nodes: Array<Maybe<IAttendeeClub>>;
  /** A list of edges which contains the `AttendeeClub` and cursor to aid in pagination. */
  edges: IAttendeeClubsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `AttendeeClub` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `AttendeeClub` edge in the connection. */
export interface IAttendeeClubsEdge {
   __typename?: "AttendeeClubsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `AttendeeClub` at the end of the edge. */
  node?: Maybe<IAttendeeClub>;
}

/** Methods to use when ordering `AttendeeClub`. */
export enum IAttendeeClubsOrderBy {
  Natural = "NATURAL",
  AttendeeIdAsc = "ATTENDEE_ID_ASC",
  AttendeeIdDesc = "ATTENDEE_ID_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/**
 * A condition to be used against `Attendee` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IAttendeeCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `age` field. */
  age?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<IAttendeeStatus>;
  /** Checks for equality with the object’s `ksAccountId` field. */
  ksAccountId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Attendee` */
export interface IAttendeeInput {
  id?: Maybe<Scalars["Uuid"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  age?: Maybe<Scalars["Int"]>;
  gender?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  status?: Maybe<IAttendeeStatus>;
  ksAccountId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Attendee`. Fields that are set will be updated. */
export interface IAttendeePatch {
  id?: Maybe<Scalars["Uuid"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  age?: Maybe<Scalars["Int"]>;
  gender?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  status?: Maybe<IAttendeeStatus>;
  ksAccountId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Attendee` values. */
export interface IAttendeesConnection {
   __typename?: "AttendeesConnection";
  /** A list of `Attendee` objects. */
  nodes: Array<Maybe<IAttendee>>;
  /** A list of edges which contains the `Attendee` and cursor to aid in pagination. */
  edges: IAttendeesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Attendee` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Attendee` edge in the connection. */
export interface IAttendeesEdge {
   __typename?: "AttendeesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Attendee` at the end of the edge. */
  node?: Maybe<IAttendee>;
}

/** Methods to use when ordering `Attendee`. */
export enum IAttendeesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  FirstNameAsc = "FIRST_NAME_ASC",
  FirstNameDesc = "FIRST_NAME_DESC",
  LastNameAsc = "LAST_NAME_ASC",
  LastNameDesc = "LAST_NAME_DESC",
  NicknameAsc = "NICKNAME_ASC",
  NicknameDesc = "NICKNAME_DESC",
  PhoneAsc = "PHONE_ASC",
  PhoneDesc = "PHONE_DESC",
  AgeAsc = "AGE_ASC",
  AgeDesc = "AGE_DESC",
  GenderAsc = "GENDER_ASC",
  GenderDesc = "GENDER_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  KsAccountIdAsc = "KS_ACCOUNT_ID_ASC",
  KsAccountIdDesc = "KS_ACCOUNT_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IAttendeeStatus {
  Active = "ACTIVE",
  Archived = "ARCHIVED",
  Deleted = "DELETED",
}

/** All input for the `authenticate` mutation. */
export interface IAuthenticateInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  email: Scalars["String"];
  password: Scalars["String"];
}

/** The output of our `authenticate` mutation. */
export interface IAuthenticatePayload {
   __typename?: "AuthenticatePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  jwtToken?: Maybe<Scalars["JwtToken"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `authenticateProduct` mutation. */
export interface IAuthenticateProductInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  email: Scalars["String"];
  password: Scalars["String"];
  product: Scalars["String"];
}

/** The output of our `authenticateProduct` mutation. */
export interface IAuthenticateProductPayload {
   __typename?: "AuthenticateProductPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  jwtToken?: Maybe<Scalars["JwtToken"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface IBarcodeInput {
  region?: Maybe<Scalars["String"]>;
  language?: Maybe<Scalars["String"]>;
}

export interface IBarcodeRequest {
   __typename?: "BarcodeRequest";
  barcode: Scalars["String"];
  labelUri: Scalars["String"];
  nutritionUri: Scalars["String"];
}

export interface IBarcodeSearchMetaInput {
  region?: Maybe<Scalars["String"]>;
  barcodeType?: Maybe<Scalars["String"]>;
  language?: Maybe<Scalars["String"]>;
}

export interface IBloodPressure {
   __typename?: "BloodPressure";
  systole?: Maybe<Scalars["Int"]>;
  diastole?: Maybe<Scalars["Int"]>;
}

export interface IBloodPressureValueInput {
  systole?: Maybe<Scalars["Int"]>;
  diastole?: Maybe<Scalars["Int"]>;
}

export interface IBodyCircumference {
   __typename?: "BodyCircumference";
  neck?: Maybe<Scalars["Float"]>;
  chest?: Maybe<Scalars["Float"]>;
  abdomen?: Maybe<Scalars["Float"]>;
  hip?: Maybe<Scalars["Float"]>;
  rightArm?: Maybe<Scalars["Float"]>;
  rightThigh?: Maybe<Scalars["Float"]>;
}

export enum IBodyMeasurementKey {
  BodyWeight = "BODY_WEIGHT",
  BodyFatPercentage = "BODY_FAT_PERCENTAGE",
  BodyFatMass = "BODY_FAT_MASS",
  SkeletalMuscleMass = "SKELETAL_MUSCLE_MASS",
  Circumference = "CIRCUMFERENCE",
  SkinFolds = "SKIN_FOLDS",
  SleepHours = "SLEEP_HOURS",
  BloodPressure = "BLOOD_PRESSURE",
  MenstrualDay = "MENSTRUAL_DAY",
  HeartRate = "HEART_RATE",
  HeartRateVar = "HEART_RATE_VAR",
  BodyTemp = "BODY_TEMP",
}

/** All input for the `bookAttendeesIntoTimeslots` mutation. */
export interface IBookAttendeesIntoTimeslotsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  timeslotIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  personIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  startDate?: Maybe<Scalars["Datetime"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `bookAttendeesIntoTimeslots` mutation. */
export interface IBookAttendeesIntoTimeslotsPayload {
   __typename?: "BookAttendeesIntoTimeslotsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  bookings?: Maybe<Array<Maybe<IBooking>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Booking`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `Booking`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Booking`. May be used by Relay 1. */
  bookingEdge?: Maybe<IBookingsEdge>;
}

/** The output of our `bookAttendeesIntoTimeslots` mutation. */
export interface IBookAttendeesIntoTimeslotsPayloadBookingEdgeArgs {
  orderBy?: Maybe<IBookingsOrderBy[]>;
}

export interface IBooking  extends INode {
   __typename?: "Booking";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  timeslotId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
  isRecurring: Scalars["Boolean"];
  notes?: Maybe<Scalars["String"]>;
  startDate?: Maybe<Scalars["Date"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Timeslot` that is related to this `Booking`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `Booking`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** Reads and enables pagination through a set of `AttendanceOverride`. */
  attendanceOverridesByBookingId: IAttendanceOverridesConnection;
}

export interface IBookingAttendanceOverridesByBookingIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
  condition?: Maybe<IAttendanceOverrideCondition>;
}

/** A condition to be used against `Booking` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IBookingCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `timeslotId` field. */
  timeslotId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `isRecurring` field. */
  isRecurring?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `Booking` */
export interface IBookingInput {
  id?: Maybe<Scalars["Uuid"]>;
  timeslotId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
  isRecurring: Scalars["Boolean"];
  notes?: Maybe<Scalars["String"]>;
  startDate?: Maybe<Scalars["Date"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `Booking`. Fields that are set will be updated. */
export interface IBookingPatch {
  id?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  personId?: Maybe<Scalars["Uuid"]>;
  isRecurring?: Maybe<Scalars["Boolean"]>;
  notes?: Maybe<Scalars["String"]>;
  startDate?: Maybe<Scalars["Date"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `Booking` values. */
export interface IBookingsConnection {
   __typename?: "BookingsConnection";
  /** A list of `Booking` objects. */
  nodes: Array<Maybe<IBooking>>;
  /** A list of edges which contains the `Booking` and cursor to aid in pagination. */
  edges: IBookingsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Booking` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Booking` edge in the connection. */
export interface IBookingsEdge {
   __typename?: "BookingsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Booking` at the end of the edge. */
  node?: Maybe<IBooking>;
}

/** Methods to use when ordering `Booking`. */
export enum IBookingsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TimeslotIdAsc = "TIMESLOT_ID_ASC",
  TimeslotIdDesc = "TIMESLOT_ID_DESC",
  PersonIdAsc = "PERSON_ID_ASC",
  PersonIdDesc = "PERSON_ID_DESC",
  IsRecurringAsc = "IS_RECURRING_ASC",
  IsRecurringDesc = "IS_RECURRING_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  StartDateAsc = "START_DATE_ASC",
  StartDateDesc = "START_DATE_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A list of food brands. */
export interface IBrand  extends INode {
   __typename?: "Brand";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  comment?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `FoodbankFood`. */
  foodbankFoodsByBrand: IFoodbankFoodsConnection;
  /** Reads and enables pagination through a set of `BrandBarcode`. */
  brandBarcodesByBrandId: IBrandBarcodesConnection;
}

/** A list of food brands. */
export interface IBrandFoodbankFoodsByBrandArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
  condition?: Maybe<IFoodbankFoodCondition>;
}

/** A list of food brands. */
export interface IBrandBrandBarcodesByBrandIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBrandBarcodesOrderBy[]>;
  condition?: Maybe<IBrandBarcodeCondition>;
}

export interface IBrandBarcode  extends INode {
   __typename?: "BrandBarcode";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  brandId: Scalars["Uuid"];
  gtinId: Scalars["String"];
  comment?: Maybe<Scalars["String"]>;
  createdAt: Scalars["Datetime"];
  /** Reads a single `Brand` that is related to this `BrandBarcode`. */
  brandByBrandId?: Maybe<IBrand>;
}

/**
 * A condition to be used against `BrandBarcode` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IBrandBarcodeCondition {
  /** Checks for equality with the object’s `brandId` field. */
  brandId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `gtinId` field. */
  gtinId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `BrandBarcode` */
export interface IBrandBarcodeInput {
  brandId: Scalars["Uuid"];
  gtinId: Scalars["String"];
  comment?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `BrandBarcode`. Fields that are set will be updated. */
export interface IBrandBarcodePatch {
  brandId?: Maybe<Scalars["Uuid"]>;
  gtinId?: Maybe<Scalars["String"]>;
  comment?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `BrandBarcode` values. */
export interface IBrandBarcodesConnection {
   __typename?: "BrandBarcodesConnection";
  /** A list of `BrandBarcode` objects. */
  nodes: Array<Maybe<IBrandBarcode>>;
  /** A list of edges which contains the `BrandBarcode` and cursor to aid in pagination. */
  edges: IBrandBarcodesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `BrandBarcode` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `BrandBarcode` edge in the connection. */
export interface IBrandBarcodesEdge {
   __typename?: "BrandBarcodesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `BrandBarcode` at the end of the edge. */
  node?: Maybe<IBrandBarcode>;
}

/** Methods to use when ordering `BrandBarcode`. */
export enum IBrandBarcodesOrderBy {
  Natural = "NATURAL",
  BrandIdAsc = "BRAND_ID_ASC",
  BrandIdDesc = "BRAND_ID_DESC",
  GtinIdAsc = "GTIN_ID_ASC",
  GtinIdDesc = "GTIN_ID_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IBrandCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `alternativeNames` field. */
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Brand` */
export interface IBrandInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  comment?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Brand`. Fields that are set will be updated. */
export interface IBrandPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  comment?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Brand` values. */
export interface IBrandsConnection {
   __typename?: "BrandsConnection";
  /** A list of `Brand` objects. */
  nodes: Array<Maybe<IBrand>>;
  /** A list of edges which contains the `Brand` and cursor to aid in pagination. */
  edges: IBrandsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Brand` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Brand` edge in the connection. */
export interface IBrandsEdge {
   __typename?: "BrandsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Brand` at the end of the edge. */
  node?: Maybe<IBrand>;
}

/** Methods to use when ordering `Brand`. */
export enum IBrandsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  AlternativeNamesAsc = "ALTERNATIVE_NAMES_ASC",
  AlternativeNamesDesc = "ALTERNATIVE_NAMES_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A connection to a list of `Category` values. */
export interface ICategoriesConnection {
   __typename?: "CategoriesConnection";
  /** A list of `Category` objects. */
  nodes: Array<Maybe<ICategory>>;
  /** A list of edges which contains the `Category` and cursor to aid in pagination. */
  edges: ICategoriesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Category` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Category` edge in the connection. */
export interface ICategoriesEdge {
   __typename?: "CategoriesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Category` at the end of the edge. */
  node?: Maybe<ICategory>;
}

/** Methods to use when ordering `Category`. */
export enum ICategoriesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  ParentIdAsc = "PARENT_ID_ASC",
  ParentIdDesc = "PARENT_ID_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Category of food */
export interface ICategory  extends INode {
   __typename?: "Category";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  parentId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `FoodCategory`. */
  foodCategoriesByCategoryId: IFoodCategoriesConnection;
}

/** Category of food */
export interface ICategoryFoodCategoriesByCategoryIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
  condition?: Maybe<IFoodCategoryCondition>;
}

/**
 * A condition to be used against `Category` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface ICategoryCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Category` */
export interface ICategoryInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
  parentId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Category`. Fields that are set will be updated. */
export interface ICategoryPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  parentId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
}

/** All input for the `changeMembersCoach` mutation. */
export interface IChangeMembersCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberIds: Array<Maybe<Scalars["Int"]>>;
  newCoachId: Scalars["Int"];
}

/** The output of our `changeMembersCoach` mutation. */
export interface IChangeMembersCoachPayload {
   __typename?: "ChangeMembersCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `changeUserCoach` mutation. */
export interface IChangeUserCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  newCoachId: Scalars["Int"];
}

/** The output of our `changeUserCoach` mutation. */
export interface IChangeUserCoachPayload {
   __typename?: "ChangeUserCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  member?: Maybe<IMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<IMembersEdge>;
}

/** The output of our `changeUserCoach` mutation. */
export interface IChangeUserCoachPayloadMemberEdgeArgs {
  orderBy?: Maybe<IMembersOrderBy[]>;
}

/** All input for the `checkinMember` mutation. */
export interface ICheckinMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  notes: Scalars["String"];
}

/** The output of our `checkinMember` mutation. */
export interface ICheckinMemberPayload {
   __typename?: "CheckinMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberCheckin?: Maybe<IMemberCheckin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberCheckin`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberCheckin`. May be used by Relay 1. */
  memberCheckinEdge?: Maybe<IMemberCheckinsEdge>;
}

/** The output of our `checkinMember` mutation. */
export interface ICheckinMemberPayloadMemberCheckinEdgeArgs {
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
}

export interface ICircumferenceValueInput {
  neck?: Maybe<Scalars["Float"]>;
  chest?: Maybe<Scalars["Float"]>;
  abdomen?: Maybe<Scalars["Float"]>;
  hip?: Maybe<Scalars["Float"]>;
  rightArm?: Maybe<Scalars["Float"]>;
  rightThigh?: Maybe<Scalars["Float"]>;
}

export interface IClass  extends INode {
   __typename?: "Class";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name?: Maybe<Scalars["String"]>;
  capacity?: Maybe<Scalars["Int"]>;
  clubId: Scalars["Uuid"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Club` that is related to this `Class`. */
  clubByClubId?: Maybe<IClub>;
  /** Reads and enables pagination through a set of `Timeslot`. */
  timeslotsByClassId: ITimeslotsConnection;
  /** Reads and enables pagination through a set of `ClassInstructor`. */
  classInstructorsByClassId: IClassInstructorsConnection;
}

export interface IClassTimeslotsByClassIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITimeslotsOrderBy[]>;
  condition?: Maybe<ITimeslotCondition>;
}

export interface IClassClassInstructorsByClassIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
  condition?: Maybe<IClassInstructorCondition>;
}

/** A condition to be used against `Class` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IClassCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `capacity` field. */
  capacity?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `Class` values. */
export interface IClassesConnection {
   __typename?: "ClassesConnection";
  /** A list of `Class` objects. */
  nodes: Array<Maybe<IClass>>;
  /** A list of edges which contains the `Class` and cursor to aid in pagination. */
  edges: IClassesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Class` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Class` edge in the connection. */
export interface IClassesEdge {
   __typename?: "ClassesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Class` at the end of the edge. */
  node?: Maybe<IClass>;
}

/** Methods to use when ordering `Class`. */
export enum IClassesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  CapacityAsc = "CAPACITY_ASC",
  CapacityDesc = "CAPACITY_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** An input for mutations affecting `Class` */
export interface IClassInput {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  capacity?: Maybe<Scalars["Int"]>;
  clubId: Scalars["Uuid"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

export interface IClassInstructor  extends INode {
   __typename?: "ClassInstructor";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  classId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Class` that is related to this `ClassInstructor`. */
  classByClassId?: Maybe<IClass>;
  /** Reads a single `Instructor` that is related to this `ClassInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
}

/**
 * A condition to be used against `ClassInstructor` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IClassInstructorCondition {
  /** Checks for equality with the object’s `classId` field. */
  classId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `instructorId` field. */
  instructorId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `ClassInstructor` */
export interface IClassInstructorInput {
  classId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `ClassInstructor`. Fields that are set will be updated. */
export interface IClassInstructorPatch {
  classId?: Maybe<Scalars["Uuid"]>;
  instructorId?: Maybe<Scalars["Uuid"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `ClassInstructor` values. */
export interface IClassInstructorsConnection {
   __typename?: "ClassInstructorsConnection";
  /** A list of `ClassInstructor` objects. */
  nodes: Array<Maybe<IClassInstructor>>;
  /** A list of edges which contains the `ClassInstructor` and cursor to aid in pagination. */
  edges: IClassInstructorsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ClassInstructor` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ClassInstructor` edge in the connection. */
export interface IClassInstructorsEdge {
   __typename?: "ClassInstructorsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ClassInstructor` at the end of the edge. */
  node?: Maybe<IClassInstructor>;
}

/** Methods to use when ordering `ClassInstructor`. */
export enum IClassInstructorsOrderBy {
  Natural = "NATURAL",
  ClassIdAsc = "CLASS_ID_ASC",
  ClassIdDesc = "CLASS_ID_DESC",
  InstructorIdAsc = "INSTRUCTOR_ID_ASC",
  InstructorIdDesc = "INSTRUCTOR_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `Class`. Fields that are set will be updated. */
export interface IClassPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  capacity?: Maybe<Scalars["Int"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

export interface ICloneTrainingPlanInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of training plan to clone */
  trainingPlanId: Scalars["ID"];
  /** new id of the cloned training plan */
  newPlanId?: Maybe<Scalars["ID"]>;
  /** new name of the cloned plan */
  name?: Maybe<Scalars["String"]>;
}

export interface ICloneTrainingPlanPayload {
   __typename?: "CloneTrainingPlanPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** cloned training plan */
  trainingPlan: ITrainingPlan;
}

export interface ICloneWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
  /** id of workout template to clone */
  workoutTemplateId: Scalars["ID"];
  /** new id of the cloned workout template */
  newTemplateId?: Maybe<Scalars["ID"]>;
  /** new name of the cloned template */
  name?: Maybe<Scalars["String"]>;
  /** ID of destionation directory */
  directoryId?: Maybe<Scalars["ID"]>;
}

export interface ICloneWorkoutTemplatePayload {
   __typename?: "CloneWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
  /** cloned workout template */
  workoutTemplate: IWorkoutTemplate;
}

export interface IClub  extends INode {
   __typename?: "Club";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name?: Maybe<Scalars["String"]>;
  location?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** 1-1 ref to ks_meta.club(id) */
  ksClubId?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `Attendee`. */
  attendeesByClubId: IAttendeesConnection;
  /** Reads and enables pagination through a set of `Instructor`. */
  instructorsByClubId: IInstructorsConnection;
  /** Reads and enables pagination through a set of `Class`. */
  classesByClubId: IClassesConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsByClubId: ISessionsConnection;
  /** Reads and enables pagination through a set of `AttendeeClub`. */
  attendeeClubsByClubId: IAttendeeClubsConnection;
  attendanceScoreAvg?: Maybe<Scalars["Float"]>;
}

export interface IClubAttendeesByClubIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendeesOrderBy[]>;
  condition?: Maybe<IAttendeeCondition>;
}

export interface IClubInstructorsByClubIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IInstructorsOrderBy[]>;
  condition?: Maybe<IInstructorCondition>;
}

export interface IClubClassesByClubIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClassesOrderBy[]>;
  condition?: Maybe<IClassCondition>;
}

export interface IClubSessionsByClubIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionsOrderBy[]>;
  condition?: Maybe<ISessionCondition>;
}

export interface IClubAttendeeClubsByClubIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
  condition?: Maybe<IAttendeeClubCondition>;
}

/** A condition to be used against `Club` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IClubCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksClubId` field. */
  ksClubId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Club` */
export interface IClubInput {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  location?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** 1-1 ref to ks_meta.club(id) */
  ksClubId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Club`. Fields that are set will be updated. */
export interface IClubPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  location?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** 1-1 ref to ks_meta.club(id) */
  ksClubId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Club` values. */
export interface IClubsConnection {
   __typename?: "ClubsConnection";
  /** A list of `Club` objects. */
  nodes: Array<Maybe<IClub>>;
  /** A list of edges which contains the `Club` and cursor to aid in pagination. */
  edges: IClubsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Club` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Club` edge in the connection. */
export interface IClubsEdge {
   __typename?: "ClubsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Club` at the end of the edge. */
  node?: Maybe<IClub>;
}

/** Methods to use when ordering `Club`. */
export enum IClubsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  LocationAsc = "LOCATION_ASC",
  LocationDesc = "LOCATION_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  KsClubIdAsc = "KS_CLUB_ID_ASC",
  KsClubIdDesc = "KS_CLUB_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IClubStatus {
  Active = "ACTIVE",
  NeedAttention = "NEED_ATTENTION",
  Disabled = "DISABLED",
}

/** A connection to a list of `ClubSummary` values. */
export interface IClubSummariesConnection {
   __typename?: "ClubSummariesConnection";
  /** A list of `ClubSummary` objects. */
  nodes: Array<Maybe<IClubSummary>>;
  /** A list of edges which contains the `ClubSummary` and cursor to aid in pagination. */
  edges: IClubSummariesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ClubSummary` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ClubSummary` edge in the connection. */
export interface IClubSummariesEdge {
   __typename?: "ClubSummariesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ClubSummary` at the end of the edge. */
  node?: Maybe<IClubSummary>;
}

/** Methods to use when ordering `ClubSummary`. */
export enum IClubSummariesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  OrgIdAsc = "ORG_ID_ASC",
  OrgIdDesc = "ORG_ID_DESC",
  OrgNameAsc = "ORG_NAME_ASC",
  OrgNameDesc = "ORG_NAME_DESC",
  CoachCountAsc = "COACH_COUNT_ASC",
  CoachCountDesc = "COACH_COUNT_DESC",
  MemberCountAsc = "MEMBER_COUNT_ASC",
  MemberCountDesc = "MEMBER_COUNT_DESC",
}

export interface IClubSummary {
   __typename?: "ClubSummary";
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  orgId?: Maybe<Scalars["Uuid"]>;
  orgName?: Maybe<Scalars["String"]>;
  coachCount?: Maybe<Scalars["BigInt"]>;
  memberCount?: Maybe<Scalars["BigInt"]>;
}

/**
 * A condition to be used against `ClubSummary` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IClubSummaryCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `coachCount` field. */
  coachCount?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `memberCount` field. */
  memberCount?: Maybe<Scalars["BigInt"]>;
}

/** A coach of the label. */
export interface ICoach  extends INode {
   __typename?: "Coach";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  /** The primary unique identifier for the coach. */
  id: Scalars["Int"];
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  /** The coach’s first name. */
  firstName: Scalars["String"];
  /** The coach’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  /** The time this coach was created. */
  createdAt: Scalars["Datetime"];
  checkInDay?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status: IPersonStatus;
  /** Reads a single `Location` that is related to this `Coach`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads and enables pagination through a set of `Member`. */
  membersByCoachId: IMembersConnection;
  /** Reads and enables pagination through a set of `TrainingProgram`. */
  trainingProgramsByCoachId: ITrainingProgramsConnection;
  /** Reads and enables pagination through a set of `ExerciseOverride`. */
  exerciseOverridesByCoachId: IExerciseOverridesConnection;
  /** Reads and enables pagination through a set of `WorkoutNode`. */
  workoutNodesByCoachId: IWorkoutNodesConnection;
  /** Reads and enables pagination through a set of `WorkoutNodeEvent`. */
  workoutNodeEventsByCoachId: IWorkoutNodeEventsConnection;
  /** Reads and enables pagination through a set of `MemberReminder`. */
  memberRemindersByCoachId: IMemberRemindersConnection;
  /** Reads and enables pagination through a set of `MentoringReport`. */
  mentoringReportsByCoachId: IMentoringReportsConnection;
  accountStatus?: Maybe<IPersonStatus>;
  /** Reads and enables pagination through a set of `Member`. */
  allMembers: IMembersConnection;
  club?: Maybe<IKsClub>;
  currentWorkspaceId?: Maybe<Scalars["Int"]>;
  dateOfBirth?: Maybe<Scalars["Date"]>;
  email?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `Feature`. */
  features: IFeaturesConnection;
  fullName?: Maybe<Scalars["String"]>;
  gender?: Maybe<Scalars["String"]>;
  height?: Maybe<Scalars["Float"]>;
  isInstructor?: Maybe<Scalars["Boolean"]>;
  /** Reads and enables pagination through a set of `MetricAverage`. */
  memberKpiAverages: IMetricAveragesConnection;
  /** Reads and enables pagination through a set of `MetricAverage`. */
  memberMeasurementAverages: IMetricAveragesConnection;
  profilePicDir?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `UserSetting`. */
  settings: IUserSettingsConnection;
  searchFood?: Maybe<IFatSecretFoodSearchResult>;
  foodItemById?: Maybe<IFatSecretFoodItemResult>;
  findIdForBarcode?: Maybe<IFatSecretFoodId>;
  findFoodByBarcode?: Maybe<IFatSecretBarcodeResult>;
  findFoodItemByBarcode?: Maybe<IKeystoneFoodbankFoodItem>;
  keystoneFoodSearch: IKeystoneFoodSearchResult;
}

/** A coach of the label. */
export interface ICoachMembersByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMembersOrderBy[]>;
  condition?: Maybe<IMemberCondition>;
}

/** A coach of the label. */
export interface ICoachTrainingProgramsByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITrainingProgramsOrderBy[]>;
  condition?: Maybe<ITrainingProgramCondition>;
}

/** A coach of the label. */
export interface ICoachExerciseOverridesByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
  condition?: Maybe<IExerciseOverrideCondition>;
}

/** A coach of the label. */
export interface ICoachWorkoutNodesByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
  condition?: Maybe<IWorkoutNodeCondition>;
}

/** A coach of the label. */
export interface ICoachWorkoutNodeEventsByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodeEventsOrderBy[]>;
  condition?: Maybe<IWorkoutNodeEventCondition>;
}

/** A coach of the label. */
export interface ICoachMemberRemindersByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
  condition?: Maybe<IMemberReminderCondition>;
}

/** A coach of the label. */
export interface ICoachMentoringReportsByCoachIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
  condition?: Maybe<IMentoringReportCondition>;
}

/** A coach of the label. */
export interface ICoachAllMembersArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A coach of the label. */
export interface ICoachFeaturesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A coach of the label. */
export interface ICoachMemberKpiAveragesArgs {
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A coach of the label. */
export interface ICoachMemberMeasurementAveragesArgs {
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A coach of the label. */
export interface ICoachSettingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A coach of the label. */
export interface ICoachSearchFoodArgs {
  term?: Maybe<Scalars["String"]>;
  meta?: Maybe<ISearchInput>;
}

/** A coach of the label. */
export interface ICoachFoodItemByIdArgs {
  id?: Maybe<Scalars["String"]>;
  meta?: Maybe<IFoodItemInput>;
}

/** A coach of the label. */
export interface ICoachFindIdForBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IBarcodeInput>;
}

/** A coach of the label. */
export interface ICoachFindFoodByBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IBarcodeInput>;
}

/** A coach of the label. */
export interface ICoachFindFoodItemByBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IKeystoneBarcodeInput>;
}

/** A coach of the label. */
export interface ICoachKeystoneFoodSearchArgs {
  term?: Maybe<Scalars["String"]>;
  meta?: Maybe<IKeystoneSearchInput>;
}

/** A condition to be used against `Coach` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ICoachCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `checkInDay` field. */
  checkInDay?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsOrgId` field. */
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsClubId` field. */
  defaultKsClubId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<IPersonStatus>;
}

/** A connection to a list of `Coach` values. */
export interface ICoachesConnection {
   __typename?: "CoachesConnection";
  /** A list of `Coach` objects. */
  nodes: Array<Maybe<ICoach>>;
  /** A list of edges which contains the `Coach` and cursor to aid in pagination. */
  edges: ICoachesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Coach` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Coach` edge in the connection. */
export interface ICoachesEdge {
   __typename?: "CoachesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Coach` at the end of the edge. */
  node?: Maybe<ICoach>;
}

/** Methods to use when ordering `Coach`. */
export enum ICoachesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  LocationIdAsc = "LOCATION_ID_ASC",
  LocationIdDesc = "LOCATION_ID_DESC",
  FirstNameAsc = "FIRST_NAME_ASC",
  FirstNameDesc = "FIRST_NAME_DESC",
  LastNameAsc = "LAST_NAME_ASC",
  LastNameDesc = "LAST_NAME_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  CheckInDayAsc = "CHECK_IN_DAY_ASC",
  CheckInDayDesc = "CHECK_IN_DAY_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  DefaultKsOrgIdAsc = "DEFAULT_KS_ORG_ID_ASC",
  DefaultKsOrgIdDesc = "DEFAULT_KS_ORG_ID_DESC",
  DefaultKsClubIdAsc = "DEFAULT_KS_CLUB_ID_ASC",
  DefaultKsClubIdDesc = "DEFAULT_KS_CLUB_ID_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** An input for mutations affecting `Coach` */
export interface ICoachInput {
  /** The primary unique identifier for the coach. */
  id?: Maybe<Scalars["Int"]>;
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  /** The coach’s first name. */
  firstName: Scalars["String"];
  /** The coach’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** The time this coach was created. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  checkInDay?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status?: Maybe<IPersonStatus>;
}

/** Represents an update to a `Coach`. Fields that are set will be updated. */
export interface ICoachPatch {
  /** The primary unique identifier for the coach. */
  id?: Maybe<Scalars["Int"]>;
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  /** The coach’s first name. */
  firstName?: Maybe<Scalars["String"]>;
  /** The coach’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** The time this coach was created. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  checkInDay?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status?: Maybe<IPersonStatus>;
}

/** Ingredients of food */
export interface IComposition  extends INode {
   __typename?: "Composition";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  foodId: Scalars["Uuid"];
  ingredients?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Reads a single `FoodbankFood` that is related to this `Composition`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
}

/**
 * A condition to be used against `Composition` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface ICompositionCondition {
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `ingredients` field. */
  ingredients?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** An input for mutations affecting `Composition` */
export interface ICompositionInput {
  foodId: Scalars["Uuid"];
  ingredients?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** Represents an update to a `Composition`. Fields that are set will be updated. */
export interface ICompositionPatch {
  foodId?: Maybe<Scalars["Uuid"]>;
  ingredients?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** A connection to a list of `Composition` values. */
export interface ICompositionsConnection {
   __typename?: "CompositionsConnection";
  /** A list of `Composition` objects. */
  nodes: Array<Maybe<IComposition>>;
  /** A list of edges which contains the `Composition` and cursor to aid in pagination. */
  edges: ICompositionsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Composition` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Composition` edge in the connection. */
export interface ICompositionsEdge {
   __typename?: "CompositionsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Composition` at the end of the edge. */
  node?: Maybe<IComposition>;
}

/** Methods to use when ordering `Composition`. */
export enum ICompositionsOrderBy {
  Natural = "NATURAL",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  IngredientsAsc = "INGREDIENTS_ASC",
  IngredientsDesc = "INGREDIENTS_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IConvertTrainingProgramInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of training program to convert to v3 */
  id: Scalars["ID"];
  withWorkouts?: Maybe<Scalars["Boolean"]>;
}

export interface IConvertTrainingProgramPayload {
   __typename?: "ConvertTrainingProgramPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Text report of the convertation */
  status: Array<Scalars["String"]>;
}

/** A connection to a list of `Country` values. */
export interface ICountriesConnection {
   __typename?: "CountriesConnection";
  /** A list of `Country` objects. */
  nodes: Array<Maybe<ICountry>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: ICountriesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Country` edge in the connection. */
export interface ICountriesEdge {
   __typename?: "CountriesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<ICountry>;
}

/** Methods to use when ordering `Country`. */
export enum ICountriesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  AlternativeNamesAsc = "ALTERNATIVE_NAMES_ASC",
  AlternativeNamesDesc = "ALTERNATIVE_NAMES_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A list of countries. */
export interface ICountry  extends INode {
   __typename?: "Country";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Reads and enables pagination through a set of `FoodbankFood`. */
  foodbankFoodsByCountryId: IFoodbankFoodsConnection;
}

/** A list of countries. */
export interface ICountryFoodbankFoodsByCountryIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
  condition?: Maybe<IFoodbankFoodCondition>;
}

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ICountryCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `alternativeNames` field. */
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** An input for mutations affecting `Country` */
export interface ICountryInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** Represents an update to a `Country`. Fields that are set will be updated. */
export interface ICountryPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** All input for the create `Attendance` mutation. */
export interface ICreateAttendanceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendance` to be created by this mutation. */
  attendance: IAttendanceInput;
}

/** All input for the create `AttendanceOverride` mutation. */
export interface ICreateAttendanceOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendanceOverride` to be created by this mutation. */
  attendanceOverride: IAttendanceOverrideInput;
}

/** The output of our create `AttendanceOverride` mutation. */
export interface ICreateAttendanceOverridePayload {
   __typename?: "CreateAttendanceOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendanceOverride` that was created by this mutation. */
  attendanceOverride?: Maybe<IAttendanceOverride>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendanceOverride`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Attendance` that is related to this `AttendanceOverride`. */
  attendanceByAttendanceId?: Maybe<IAttendance>;
  /** Reads a single `Booking` that is related to this `AttendanceOverride`. */
  bookingByBookingId?: Maybe<IBooking>;
  /** An edge for our `AttendanceOverride`. May be used by Relay 1. */
  attendanceOverrideEdge?: Maybe<IAttendanceOverridesEdge>;
}

/** The output of our create `AttendanceOverride` mutation. */
export interface ICreateAttendanceOverridePayloadAttendanceOverrideEdgeArgs {
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
}

/** The output of our create `Attendance` mutation. */
export interface ICreateAttendancePayload {
   __typename?: "CreateAttendancePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendance` that was created by this mutation. */
  attendance?: Maybe<IAttendance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `Attendance`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Attendee` that is related to this `Attendance`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Attendance`. May be used by Relay 1. */
  attendanceEdge?: Maybe<IAttendancesEdge>;
}

/** The output of our create `Attendance` mutation. */
export interface ICreateAttendancePayloadAttendanceEdgeArgs {
  orderBy?: Maybe<IAttendancesOrderBy[]>;
}

/** All input for the create `AttendeeClub` mutation. */
export interface ICreateAttendeeClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendeeClub` to be created by this mutation. */
  attendeeClub: IAttendeeClubInput;
}

/** The output of our create `AttendeeClub` mutation. */
export interface ICreateAttendeeClubPayload {
   __typename?: "CreateAttendeeClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendeeClub` that was created by this mutation. */
  attendeeClub?: Maybe<IAttendeeClub>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendeeClub`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Club` that is related to this `AttendeeClub`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `AttendeeClub`. May be used by Relay 1. */
  attendeeClubEdge?: Maybe<IAttendeeClubsEdge>;
}

/** The output of our create `AttendeeClub` mutation. */
export interface ICreateAttendeeClubPayloadAttendeeClubEdgeArgs {
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
}

/** All input for the create `Attendee` mutation. */
export interface ICreateAttendeeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendee` to be created by this mutation. */
  attendee: IAttendeeInput;
}

/** The output of our create `Attendee` mutation. */
export interface ICreateAttendeePayload {
   __typename?: "CreateAttendeePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendee` that was created by this mutation. */
  attendee?: Maybe<IAttendee>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Attendee`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Attendee`. May be used by Relay 1. */
  attendeeEdge?: Maybe<IAttendeesEdge>;
}

/** The output of our create `Attendee` mutation. */
export interface ICreateAttendeePayloadAttendeeEdgeArgs {
  orderBy?: Maybe<IAttendeesOrderBy[]>;
}

/** All input for the `createAttendeesByUserIds` mutation. */
export interface ICreateAttendeesByUserIdsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  userIds?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

/** The output of our `createAttendeesByUserIds` mutation. */
export interface ICreateAttendeesByUserIdsPayload {
   __typename?: "CreateAttendeesByUserIdsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  attendees?: Maybe<Array<Maybe<IAttendee>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Attendee`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Attendee`. May be used by Relay 1. */
  attendeeEdge?: Maybe<IAttendeesEdge>;
}

/** The output of our `createAttendeesByUserIds` mutation. */
export interface ICreateAttendeesByUserIdsPayloadAttendeeEdgeArgs {
  orderBy?: Maybe<IAttendeesOrderBy[]>;
}

/** All input for the create `Booking` mutation. */
export interface ICreateBookingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Booking` to be created by this mutation. */
  booking: IBookingInput;
}

/** The output of our create `Booking` mutation. */
export interface ICreateBookingPayload {
   __typename?: "CreateBookingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Booking` that was created by this mutation. */
  booking?: Maybe<IBooking>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Booking`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `Booking`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Booking`. May be used by Relay 1. */
  bookingEdge?: Maybe<IBookingsEdge>;
}

/** The output of our create `Booking` mutation. */
export interface ICreateBookingPayloadBookingEdgeArgs {
  orderBy?: Maybe<IBookingsOrderBy[]>;
}

/** All input for the create `BrandBarcode` mutation. */
export interface ICreateBrandBarcodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `BrandBarcode` to be created by this mutation. */
  brandBarcode: IBrandBarcodeInput;
}

/** The output of our create `BrandBarcode` mutation. */
export interface ICreateBrandBarcodePayload {
   __typename?: "CreateBrandBarcodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `BrandBarcode` that was created by this mutation. */
  brandBarcode?: Maybe<IBrandBarcode>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `BrandBarcode`. */
  brandByBrandId?: Maybe<IBrand>;
  /** An edge for our `BrandBarcode`. May be used by Relay 1. */
  brandBarcodeEdge?: Maybe<IBrandBarcodesEdge>;
}

/** The output of our create `BrandBarcode` mutation. */
export interface ICreateBrandBarcodePayloadBrandBarcodeEdgeArgs {
  orderBy?: Maybe<IBrandBarcodesOrderBy[]>;
}

/** All input for the create `Brand` mutation. */
export interface ICreateBrandInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Brand` to be created by this mutation. */
  brand: IBrandInput;
}

/** The output of our create `Brand` mutation. */
export interface ICreateBrandPayload {
   __typename?: "CreateBrandPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Brand` that was created by this mutation. */
  brand?: Maybe<IBrand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<IBrandsEdge>;
}

/** The output of our create `Brand` mutation. */
export interface ICreateBrandPayloadBrandEdgeArgs {
  orderBy?: Maybe<IBrandsOrderBy[]>;
}

/** All input for the create `Category` mutation. */
export interface ICreateCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Category` to be created by this mutation. */
  category: ICategoryInput;
}

/** The output of our create `Category` mutation. */
export interface ICreateCategoryPayload {
   __typename?: "CreateCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Category` that was created by this mutation. */
  category?: Maybe<ICategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<ICategoriesEdge>;
}

/** The output of our create `Category` mutation. */
export interface ICreateCategoryPayloadCategoryEdgeArgs {
  orderBy?: Maybe<ICategoriesOrderBy[]>;
}

/** All input for the create `Class` mutation. */
export interface ICreateClassInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Class` to be created by this mutation. */
  class: IClassInput;
}

/** All input for the create `ClassInstructor` mutation. */
export interface ICreateClassInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ClassInstructor` to be created by this mutation. */
  classInstructor: IClassInstructorInput;
}

/** The output of our create `ClassInstructor` mutation. */
export interface ICreateClassInstructorPayload {
   __typename?: "CreateClassInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ClassInstructor` that was created by this mutation. */
  classInstructor?: Maybe<IClassInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `ClassInstructor`. */
  classByClassId?: Maybe<IClass>;
  /** Reads a single `Instructor` that is related to this `ClassInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `ClassInstructor`. May be used by Relay 1. */
  classInstructorEdge?: Maybe<IClassInstructorsEdge>;
}

/** The output of our create `ClassInstructor` mutation. */
export interface ICreateClassInstructorPayloadClassInstructorEdgeArgs {
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
}

/** The output of our create `Class` mutation. */
export interface ICreateClassPayload {
   __typename?: "CreateClassPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Class` that was created by this mutation. */
  class?: Maybe<IClass>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Class`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Class`. May be used by Relay 1. */
  classEdge?: Maybe<IClassesEdge>;
}

/** The output of our create `Class` mutation. */
export interface ICreateClassPayloadClassEdgeArgs {
  orderBy?: Maybe<IClassesOrderBy[]>;
}

/** All input for the create `Club` mutation. */
export interface ICreateClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Club` to be created by this mutation. */
  club: IClubInput;
}

/** The output of our create `Club` mutation. */
export interface ICreateClubPayload {
   __typename?: "CreateClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Club` that was created by this mutation. */
  club?: Maybe<IClub>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Club`. May be used by Relay 1. */
  clubEdge?: Maybe<IClubsEdge>;
}

/** The output of our create `Club` mutation. */
export interface ICreateClubPayloadClubEdgeArgs {
  orderBy?: Maybe<IClubsOrderBy[]>;
}

/** All input for the create `Coach` mutation. */
export interface ICreateCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Coach` to be created by this mutation. */
  coach: ICoachInput;
}

/** The output of our create `Coach` mutation. */
export interface ICreateCoachPayload {
   __typename?: "CreateCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Coach` that was created by this mutation. */
  coach?: Maybe<ICoach>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Coach`. */
  locationByLocationId?: Maybe<ILocation>;
  /** An edge for our `Coach`. May be used by Relay 1. */
  coachEdge?: Maybe<ICoachesEdge>;
}

/** The output of our create `Coach` mutation. */
export interface ICreateCoachPayloadCoachEdgeArgs {
  orderBy?: Maybe<ICoachesOrderBy[]>;
}

/** All input for the create `Composition` mutation. */
export interface ICreateCompositionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Composition` to be created by this mutation. */
  composition: ICompositionInput;
}

/** The output of our create `Composition` mutation. */
export interface ICreateCompositionPayload {
   __typename?: "CreateCompositionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Composition` that was created by this mutation. */
  composition?: Maybe<IComposition>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Composition`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Composition`. May be used by Relay 1. */
  compositionEdge?: Maybe<ICompositionsEdge>;
}

/** The output of our create `Composition` mutation. */
export interface ICreateCompositionPayloadCompositionEdgeArgs {
  orderBy?: Maybe<ICompositionsOrderBy[]>;
}

/** All input for the create `Country` mutation. */
export interface ICreateCountryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Country` to be created by this mutation. */
  country: ICountryInput;
}

/** The output of our create `Country` mutation. */
export interface ICreateCountryPayload {
   __typename?: "CreateCountryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<ICountry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<ICountriesEdge>;
}

/** The output of our create `Country` mutation. */
export interface ICreateCountryPayloadCountryEdgeArgs {
  orderBy?: Maybe<ICountriesOrderBy[]>;
}

/** All input for the create `DataSource` mutation. */
export interface ICreateDataSourceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `DataSource` to be created by this mutation. */
  dataSource: IDataSourceInput;
}

/** The output of our create `DataSource` mutation. */
export interface ICreateDataSourcePayload {
   __typename?: "CreateDataSourcePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `DataSource` that was created by this mutation. */
  dataSource?: Maybe<IDataSource>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `DataSource`. May be used by Relay 1. */
  dataSourceEdge?: Maybe<IDataSourcesEdge>;
}

/** The output of our create `DataSource` mutation. */
export interface ICreateDataSourcePayloadDataSourceEdgeArgs {
  orderBy?: Maybe<IDataSourcesOrderBy[]>;
}

/** All input for the `createEmptyNutritionDay` mutation. */
export interface ICreateEmptyNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  planId?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `createEmptyNutritionDay` mutation. */
export interface ICreateEmptyNutritionDayPayload {
   __typename?: "CreateEmptyNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our `createEmptyNutritionDay` mutation. */
export interface ICreateEmptyNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the create `Exercise` mutation. */
export interface ICreateExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Exercise` to be created by this mutation. */
  exercise: IExerciseInput;
}

/** All input for the create `ExerciseOverride` mutation. */
export interface ICreateExerciseOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ExerciseOverride` to be created by this mutation. */
  exerciseOverride: IExerciseOverrideInput;
}

/** The output of our create `ExerciseOverride` mutation. */
export interface ICreateExerciseOverridePayload {
   __typename?: "CreateExerciseOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ExerciseOverride` that was created by this mutation. */
  exerciseOverride?: Maybe<IExerciseOverride>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Exercise` that is related to this `ExerciseOverride`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `ExerciseOverride`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `ExerciseOverride`. May be used by Relay 1. */
  exerciseOverrideEdge?: Maybe<IExerciseOverridesEdge>;
}

/** The output of our create `ExerciseOverride` mutation. */
export interface ICreateExerciseOverridePayloadExerciseOverrideEdgeArgs {
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
}

/** The output of our create `Exercise` mutation. */
export interface ICreateExercisePayload {
   __typename?: "CreateExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Exercise` that was created by this mutation. */
  exercise?: Maybe<IExercise>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Exercise`. May be used by Relay 1. */
  exerciseEdge?: Maybe<IExercisesEdge>;
}

/** The output of our create `Exercise` mutation. */
export interface ICreateExercisePayloadExerciseEdgeArgs {
  orderBy?: Maybe<IExercisesOrderBy[]>;
}

/** All input for the create `FavouriteFood` mutation. */
export interface ICreateFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FavouriteFood` to be created by this mutation. */
  favouriteFood: IFavouriteFoodInput;
}

/** The output of our create `FavouriteFood` mutation. */
export interface ICreateFavouriteFoodPayload {
   __typename?: "CreateFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FavouriteFood` that was created by this mutation. */
  favouriteFood?: Maybe<IFavouriteFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `FavouriteFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `FavouriteFood`. May be used by Relay 1. */
  favouriteFoodEdge?: Maybe<IFavouriteFoodsEdge>;
}

/** The output of our create `FavouriteFood` mutation. */
export interface ICreateFavouriteFoodPayloadFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
}

/** All input for the `createFeature` mutation. */
export interface ICreateFeatureInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  name: Scalars["String"];
  comment: Scalars["String"];
}

/** The output of our `createFeature` mutation. */
export interface ICreateFeaturePayload {
   __typename?: "CreateFeaturePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  feature?: Maybe<IFeature>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the create `FoodbankFood` mutation. */
export interface ICreateFoodbankFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankFood` to be created by this mutation. */
  foodbankFood: IFoodbankFoodInput;
}

/** The output of our create `FoodbankFood` mutation. */
export interface ICreateFoodbankFoodPayload {
   __typename?: "CreateFoodbankFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankFood` that was created by this mutation. */
  foodbankFood?: Maybe<IFoodbankFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `FoodbankFood`. */
  brandByBrand?: Maybe<IBrand>;
  /** Reads a single `Country` that is related to this `FoodbankFood`. */
  countryByCountryId?: Maybe<ICountry>;
  /** Reads a single `DataSource` that is related to this `FoodbankFood`. */
  dataSourceBySource?: Maybe<IDataSource>;
  /** An edge for our `FoodbankFood`. May be used by Relay 1. */
  foodbankFoodEdge?: Maybe<IFoodbankFoodsEdge>;
}

/** The output of our create `FoodbankFood` mutation. */
export interface ICreateFoodbankFoodPayloadFoodbankFoodEdgeArgs {
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
}

/** All input for the create `FoodbankNutritionFact` mutation. */
export interface ICreateFoodbankNutritionFactInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankNutritionFact` to be created by this mutation. */
  foodbankNutritionFact: IFoodbankNutritionFactInput;
}

/** The output of our create `FoodbankNutritionFact` mutation. */
export interface ICreateFoodbankNutritionFactPayload {
   __typename?: "CreateFoodbankNutritionFactPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankNutritionFact` that was created by this mutation. */
  foodbankNutritionFact?: Maybe<IFoodbankNutritionFact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodbankNutritionFact`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `FoodbankNutritionFact`. May be used by Relay 1. */
  foodbankNutritionFactEdge?: Maybe<IFoodbankNutritionFactsEdge>;
}

/** The output of our create `FoodbankNutritionFact` mutation. */
export interface ICreateFoodbankNutritionFactPayloadFoodbankNutritionFactEdgeArgs {
  orderBy?: Maybe<IFoodbankNutritionFactsOrderBy[]>;
}

/** All input for the create `FoodCategory` mutation. */
export interface ICreateFoodCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodCategory` to be created by this mutation. */
  foodCategory: IFoodCategoryInput;
}

/** The output of our create `FoodCategory` mutation. */
export interface ICreateFoodCategoryPayload {
   __typename?: "CreateFoodCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodCategory` that was created by this mutation. */
  foodCategory?: Maybe<IFoodCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodCategory`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** Reads a single `Category` that is related to this `FoodCategory`. */
  categoryByCategoryId?: Maybe<ICategory>;
  /** An edge for our `FoodCategory`. May be used by Relay 1. */
  foodCategoryEdge?: Maybe<IFoodCategoriesEdge>;
}

/** The output of our create `FoodCategory` mutation. */
export interface ICreateFoodCategoryPayloadFoodCategoryEdgeArgs {
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
}

/** All input for the create `Food` mutation. */
export interface ICreateFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Food` to be created by this mutation. */
  food: IFoodInput;
}

/** The output of our create `Food` mutation. */
export interface ICreateFoodPayload {
   __typename?: "CreateFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Food` that was created by this mutation. */
  food?: Maybe<IFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `Food`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `Food`. May be used by Relay 1. */
  foodEdge?: Maybe<IFoodsEdge>;
}

/** The output of our create `Food` mutation. */
export interface ICreateFoodPayloadFoodEdgeArgs {
  orderBy?: Maybe<IFoodsOrderBy[]>;
}

/** All input for the create `Gtin` mutation. */
export interface ICreateGtinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Gtin` to be created by this mutation. */
  gtin: IGtinInput;
}

/** The output of our create `Gtin` mutation. */
export interface ICreateGtinPayload {
   __typename?: "CreateGtinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Gtin` that was created by this mutation. */
  gtin?: Maybe<IGtin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Gtin`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Gtin`. May be used by Relay 1. */
  gtinEdge?: Maybe<IGtinsEdge>;
}

/** The output of our create `Gtin` mutation. */
export interface ICreateGtinPayloadGtinEdgeArgs {
  orderBy?: Maybe<IGtinsOrderBy[]>;
}

/** All input for the create `HistoryAction` mutation. */
export interface ICreateHistoryActionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `HistoryAction` to be created by this mutation. */
  historyAction: IHistoryActionInput;
}

/** The output of our create `HistoryAction` mutation. */
export interface ICreateHistoryActionPayload {
   __typename?: "CreateHistoryActionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `HistoryAction` that was created by this mutation. */
  historyAction?: Maybe<IHistoryAction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `HistoryAction`. May be used by Relay 1. */
  historyActionEdge?: Maybe<IHistoryActionsEdge>;
}

/** The output of our create `HistoryAction` mutation. */
export interface ICreateHistoryActionPayloadHistoryActionEdgeArgs {
  orderBy?: Maybe<IHistoryActionsOrderBy[]>;
}

/** All input for the create `Instructor` mutation. */
export interface ICreateInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Instructor` to be created by this mutation. */
  instructor: IInstructorInput;
}

/** The output of our create `Instructor` mutation. */
export interface ICreateInstructorPayload {
   __typename?: "CreateInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Instructor` that was created by this mutation. */
  instructor?: Maybe<IInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Instructor`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Instructor`. May be used by Relay 1. */
  instructorEdge?: Maybe<IInstructorsEdge>;
}

/** The output of our create `Instructor` mutation. */
export interface ICreateInstructorPayloadInstructorEdgeArgs {
  orderBy?: Maybe<IInstructorsOrderBy[]>;
}

/** All input for the `createInstructors` mutation. */
export interface ICreateInstructorsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  userIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  clubId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `createInstructors` mutation. */
export interface ICreateInstructorsPayload {
   __typename?: "CreateInstructorsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  instructors?: Maybe<Array<Maybe<IInstructor>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Instructor`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Instructor`. May be used by Relay 1. */
  instructorEdge?: Maybe<IInstructorsEdge>;
}

/** The output of our `createInstructors` mutation. */
export interface ICreateInstructorsPayloadInstructorEdgeArgs {
  orderBy?: Maybe<IInstructorsOrderBy[]>;
}

export interface ICreateJournalDayTargetsInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** List of user IDs */
  userIds: Array<Scalars["ID"]>;
  /** Target protein */
  protein: Scalars["Float"];
  /** Target fat */
  fat: Scalars["Float"];
  /** Target carbs */
  carbs: Scalars["Float"];
  /** Target vegetables */
  vegetables: Scalars["Float"];
  /** Target water */
  water?: Maybe<Scalars["Int"]>;
  /** Initial day of assignment */
  startDate: Scalars["NaiveDate"];
  /** Last day of assignment */
  endDate?: Maybe<Scalars["NaiveDate"]>;
  /** List of days of the week */
  weekdays: IWeekday[];
}

export interface ICreateJournalDayTargetsPayload {
   __typename?: "CreateJournalDayTargetsPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Assigned targets */
  targets: IFoodJournalUserTargetsConnection;
}

/** All input for the create `Location` mutation. */
export interface ICreateLocationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Location` to be created by this mutation. */
  location: ILocationInput;
}

/** The output of our create `Location` mutation. */
export interface ICreateLocationPayload {
   __typename?: "CreateLocationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Location` that was created by this mutation. */
  location?: Maybe<ILocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge?: Maybe<ILocationsEdge>;
}

/** The output of our create `Location` mutation. */
export interface ICreateLocationPayloadLocationEdgeArgs {
  orderBy?: Maybe<ILocationsOrderBy[]>;
}

/** All input for the create `ManagerClubOrg` mutation. */
export interface ICreateManagerClubOrgInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ManagerClubOrg` to be created by this mutation. */
  managerClubOrg: IManagerClubOrgInput;
}

/** The output of our create `ManagerClubOrg` mutation. */
export interface ICreateManagerClubOrgPayload {
   __typename?: "CreateManagerClubOrgPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ManagerClubOrg` that was created by this mutation. */
  managerClubOrg?: Maybe<IManagerClubOrg>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Manager` that is related to this `ManagerClubOrg`. */
  managerByManagerId?: Maybe<IManager>;
  /** An edge for our `ManagerClubOrg`. May be used by Relay 1. */
  managerClubOrgEdge?: Maybe<IManagerClubOrgsEdge>;
}

/** The output of our create `ManagerClubOrg` mutation. */
export interface ICreateManagerClubOrgPayloadManagerClubOrgEdgeArgs {
  orderBy?: Maybe<IManagerClubOrgsOrderBy[]>;
}

/** All input for the create `Manager` mutation. */
export interface ICreateManagerInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Manager` to be created by this mutation. */
  manager: IManagerInput;
}

/** The output of our create `Manager` mutation. */
export interface ICreateManagerPayload {
   __typename?: "CreateManagerPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Manager` that was created by this mutation. */
  manager?: Maybe<IManager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Manager`. May be used by Relay 1. */
  managerEdge?: Maybe<IManagersEdge>;
}

/** The output of our create `Manager` mutation. */
export interface ICreateManagerPayloadManagerEdgeArgs {
  orderBy?: Maybe<IManagersOrderBy[]>;
}

/** All input for the create `MealItem` mutation. */
export interface ICreateMealItemInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MealItem` to be created by this mutation. */
  mealItem: IMealItemInput;
}

/** The output of our create `MealItem` mutation. */
export interface ICreateMealItemPayload {
   __typename?: "CreateMealItemPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MealItem` that was created by this mutation. */
  mealItem?: Maybe<IMealItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MemberMeal` that is related to this `MealItem`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** Reads a single `Food` that is related to this `MealItem`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MealItem`. May be used by Relay 1. */
  mealItemEdge?: Maybe<IMealItemsEdge>;
}

/** The output of our create `MealItem` mutation. */
export interface ICreateMealItemPayloadMealItemEdgeArgs {
  orderBy?: Maybe<IMealItemsOrderBy[]>;
}

/** All input for the create `MemberCheckin` mutation. */
export interface ICreateMemberCheckinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberCheckin` to be created by this mutation. */
  memberCheckin: IMemberCheckinInput;
}

/** The output of our create `MemberCheckin` mutation. */
export interface ICreateMemberCheckinPayload {
   __typename?: "CreateMemberCheckinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberCheckin` that was created by this mutation. */
  memberCheckin?: Maybe<IMemberCheckin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberCheckin`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberCheckin`. May be used by Relay 1. */
  memberCheckinEdge?: Maybe<IMemberCheckinsEdge>;
}

/** The output of our create `MemberCheckin` mutation. */
export interface ICreateMemberCheckinPayloadMemberCheckinEdgeArgs {
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
}

/** All input for the create `MemberEvaluatedRecipe` mutation. */
export interface ICreateMemberEvaluatedRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberEvaluatedRecipe` to be created by this mutation. */
  memberEvaluatedRecipe: IMemberEvaluatedRecipeInput;
}

/** The output of our create `MemberEvaluatedRecipe` mutation. */
export interface ICreateMemberEvaluatedRecipePayload {
   __typename?: "CreateMemberEvaluatedRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberEvaluatedRecipe` that was created by this mutation. */
  memberEvaluatedRecipe?: Maybe<IMemberEvaluatedRecipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `MemberEvaluatedRecipe`. */
  foodByFoodId?: Maybe<IFood>;
  /** Reads a single `MemberRecipe` that is related to this `MemberEvaluatedRecipe`. */
  memberRecipeByRecipeId?: Maybe<IMemberRecipe>;
  /** An edge for our `MemberEvaluatedRecipe`. May be used by Relay 1. */
  memberEvaluatedRecipeEdge?: Maybe<IMemberEvaluatedRecipesEdge>;
}

/** The output of our create `MemberEvaluatedRecipe` mutation. */
export interface ICreateMemberEvaluatedRecipePayloadMemberEvaluatedRecipeEdgeArgs {
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
}

/** All input for the create `MemberFavouriteFood` mutation. */
export interface ICreateMemberFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberFavouriteFood` to be created by this mutation. */
  memberFavouriteFood: IMemberFavouriteFoodInput;
}

/** The output of our create `MemberFavouriteFood` mutation. */
export interface ICreateMemberFavouriteFoodPayload {
   __typename?: "CreateMemberFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberFavouriteFood` that was created by this mutation. */
  memberFavouriteFood?: Maybe<IMemberFavouriteFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberFavouriteFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberFavouriteFood`. May be used by Relay 1. */
  memberFavouriteFoodEdge?: Maybe<IMemberFavouriteFoodsEdge>;
}

/** The output of our create `MemberFavouriteFood` mutation. */
export interface ICreateMemberFavouriteFoodPayloadMemberFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IMemberFavouriteFoodsOrderBy[]>;
}

/** All input for the create `Member` mutation. */
export interface ICreateMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Member` to be created by this mutation. */
  member: IMemberInput;
}

/** All input for the create `MemberMeal` mutation. */
export interface ICreateMemberMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMeal` to be created by this mutation. */
  memberMeal: IMemberMealInput;
}

/** The output of our create `MemberMeal` mutation. */
export interface ICreateMemberMealPayload {
   __typename?: "CreateMemberMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMeal` that was created by this mutation. */
  memberMeal?: Maybe<IMemberMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our create `MemberMeal` mutation. */
export interface ICreateMemberMealPayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the create `MemberMetric` mutation. */
export interface ICreateMemberMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMetric` to be created by this mutation. */
  memberMetric: IMemberMetricInput;
}

/** The output of our create `MemberMetric` mutation. */
export interface ICreateMemberMetricPayload {
   __typename?: "CreateMemberMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMetric` that was created by this mutation. */
  memberMetric?: Maybe<IMemberMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMetric`. May be used by Relay 1. */
  memberMetricEdge?: Maybe<IMemberMetricsEdge>;
}

/** The output of our create `MemberMetric` mutation. */
export interface ICreateMemberMetricPayloadMemberMetricEdgeArgs {
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
}

/** All input for the create `MemberMyFood` mutation. */
export interface ICreateMemberMyFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMyFood` to be created by this mutation. */
  memberMyFood: IMemberMyFoodInput;
}

/** The output of our create `MemberMyFood` mutation. */
export interface ICreateMemberMyFoodPayload {
   __typename?: "CreateMemberMyFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMyFood` that was created by this mutation. */
  memberMyFood?: Maybe<IMemberMyFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMyFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMyFood`. May be used by Relay 1. */
  memberMyFoodEdge?: Maybe<IMemberMyFoodsEdge>;
}

/** The output of our create `MemberMyFood` mutation. */
export interface ICreateMemberMyFoodPayloadMemberMyFoodEdgeArgs {
  orderBy?: Maybe<IMemberMyFoodsOrderBy[]>;
}

/** All input for the create `MemberNutritionMetric` mutation. */
export interface ICreateMemberNutritionMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionMetric` to be created by this mutation. */
  memberNutritionMetric: IMemberNutritionMetricInput;
}

/** The output of our create `MemberNutritionMetric` mutation. */
export interface ICreateMemberNutritionMetricPayload {
   __typename?: "CreateMemberNutritionMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionMetric` that was created by this mutation. */
  memberNutritionMetric?: Maybe<IMemberNutritionMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberNutritionMetric`. May be used by Relay 1. */
  memberNutritionMetricEdge?: Maybe<IMemberNutritionMetricsEdge>;
}

/** The output of our create `MemberNutritionMetric` mutation. */
export interface ICreateMemberNutritionMetricPayloadMemberNutritionMetricEdgeArgs {
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
}

/** All input for the create `MemberNutritionPlan` mutation. */
export interface ICreateMemberNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionPlan` to be created by this mutation. */
  memberNutritionPlan: IMemberNutritionPlanInput;
}

/** The output of our create `MemberNutritionPlan` mutation. */
export interface ICreateMemberNutritionPlanPayload {
   __typename?: "CreateMemberNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionPlan` that was created by this mutation. */
  memberNutritionPlan?: Maybe<IMemberNutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionPlan`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `NutritionPlan` that is related to this `MemberNutritionPlan`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `MemberNutritionPlan`. May be used by Relay 1. */
  memberNutritionPlanEdge?: Maybe<IMemberNutritionPlansEdge>;
}

/** The output of our create `MemberNutritionPlan` mutation. */
export interface ICreateMemberNutritionPlanPayloadMemberNutritionPlanEdgeArgs {
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
}

/** The output of our create `Member` mutation. */
export interface ICreateMemberPayload {
   __typename?: "CreateMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Member` that was created by this mutation. */
  member?: Maybe<IMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<IMembersEdge>;
}

/** The output of our create `Member` mutation. */
export interface ICreateMemberPayloadMemberEdgeArgs {
  orderBy?: Maybe<IMembersOrderBy[]>;
}

/** All input for the create `MemberRecentFood` mutation. */
export interface ICreateMemberRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecentFood` to be created by this mutation. */
  memberRecentFood: IMemberRecentFoodInput;
}

/** The output of our create `MemberRecentFood` mutation. */
export interface ICreateMemberRecentFoodPayload {
   __typename?: "CreateMemberRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecentFood` that was created by this mutation. */
  memberRecentFood?: Maybe<IMemberRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MemberRecentFood`. May be used by Relay 1. */
  memberRecentFoodEdge?: Maybe<IMemberRecentFoodsEdge>;
}

/** The output of our create `MemberRecentFood` mutation. */
export interface ICreateMemberRecentFoodPayloadMemberRecentFoodEdgeArgs {
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
}

/** All input for the create `MemberRecipe` mutation. */
export interface ICreateMemberRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecipe` to be created by this mutation. */
  memberRecipe: IMemberRecipeInput;
}

/** The output of our create `MemberRecipe` mutation. */
export interface ICreateMemberRecipePayload {
   __typename?: "CreateMemberRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecipe` that was created by this mutation. */
  memberRecipe?: Maybe<IMemberRecipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecipe`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `MemberMeal` that is related to this `MemberRecipe`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `MemberRecipe`. May be used by Relay 1. */
  memberRecipeEdge?: Maybe<IMemberRecipesEdge>;
}

/** The output of our create `MemberRecipe` mutation. */
export interface ICreateMemberRecipePayloadMemberRecipeEdgeArgs {
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
}

/** All input for the create `MemberReminder` mutation. */
export interface ICreateMemberReminderInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberReminder` to be created by this mutation. */
  memberReminder: IMemberReminderInput;
}

/** The output of our create `MemberReminder` mutation. */
export interface ICreateMemberReminderPayload {
   __typename?: "CreateMemberReminderPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberReminder` that was created by this mutation. */
  memberReminder?: Maybe<IMemberReminder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberReminder`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Coach` that is related to this `MemberReminder`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `MemberReminder`. May be used by Relay 1. */
  memberReminderEdge?: Maybe<IMemberRemindersEdge>;
}

/** The output of our create `MemberReminder` mutation. */
export interface ICreateMemberReminderPayloadMemberReminderEdgeArgs {
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
}

/** All input for the create `MemberStepsMetric` mutation. */
export interface ICreateMemberStepsMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberStepsMetric` to be created by this mutation. */
  memberStepsMetric: IMemberStepsMetricInput;
}

/** The output of our create `MemberStepsMetric` mutation. */
export interface ICreateMemberStepsMetricPayload {
   __typename?: "CreateMemberStepsMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberStepsMetric` that was created by this mutation. */
  memberStepsMetric?: Maybe<IMemberStepsMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberStepsMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberStepsMetric`. May be used by Relay 1. */
  memberStepsMetricEdge?: Maybe<IMemberStepsMetricsEdge>;
}

/** The output of our create `MemberStepsMetric` mutation. */
export interface ICreateMemberStepsMetricPayloadMemberStepsMetricEdgeArgs {
  orderBy?: Maybe<IMemberStepsMetricsOrderBy[]>;
}

/** All input for the create `MemberTag` mutation. */
export interface ICreateMemberTagInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTag` to be created by this mutation. */
  memberTag: IMemberTagInput;
}

/** The output of our create `MemberTag` mutation. */
export interface ICreateMemberTagPayload {
   __typename?: "CreateMemberTagPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTag` that was created by this mutation. */
  memberTag?: Maybe<IMemberTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberTag`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Tag` that is related to this `MemberTag`. */
  tagByTagId?: Maybe<ITag>;
  /** An edge for our `MemberTag`. May be used by Relay 1. */
  memberTagEdge?: Maybe<IMemberTagsEdge>;
}

/** The output of our create `MemberTag` mutation. */
export interface ICreateMemberTagPayloadMemberTagEdgeArgs {
  orderBy?: Maybe<IMemberTagsOrderBy[]>;
}

/** All input for the create `MemberTrainingProgram` mutation. */
export interface ICreateMemberTrainingProgramInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTrainingProgram` to be created by this mutation. */
  memberTrainingProgram: IMemberTrainingProgramInput;
}

/** The output of our create `MemberTrainingProgram` mutation. */
export interface ICreateMemberTrainingProgramPayload {
   __typename?: "CreateMemberTrainingProgramPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTrainingProgram` that was created by this mutation. */
  memberTrainingProgram?: Maybe<IMemberTrainingProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberTrainingProgram`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `TrainingProgram` that is related to this `MemberTrainingProgram`. */
  trainingProgramByTrainingProgramId?: Maybe<ITrainingProgram>;
  /** An edge for our `MemberTrainingProgram`. May be used by Relay 1. */
  memberTrainingProgramEdge?: Maybe<IMemberTrainingProgramsEdge>;
}

/** The output of our create `MemberTrainingProgram` mutation. */
export interface ICreateMemberTrainingProgramPayloadMemberTrainingProgramEdgeArgs {
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
}

/** All input for the create `MemberWaterMetric` mutation. */
export interface ICreateMemberWaterMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWaterMetric` to be created by this mutation. */
  memberWaterMetric: IMemberWaterMetricInput;
}

/** The output of our create `MemberWaterMetric` mutation. */
export interface ICreateMemberWaterMetricPayload {
   __typename?: "CreateMemberWaterMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWaterMetric` that was created by this mutation. */
  memberWaterMetric?: Maybe<IMemberWaterMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWaterMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberWaterMetric`. May be used by Relay 1. */
  memberWaterMetricEdge?: Maybe<IMemberWaterMetricsEdge>;
}

/** The output of our create `MemberWaterMetric` mutation. */
export interface ICreateMemberWaterMetricPayloadMemberWaterMetricEdgeArgs {
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
}

/** All input for the create `MemberWorkout` mutation. */
export interface ICreateMemberWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWorkout` to be created by this mutation. */
  memberWorkout: IMemberWorkoutInput;
}

/** The output of our create `MemberWorkout` mutation. */
export interface ICreateMemberWorkoutPayload {
   __typename?: "CreateMemberWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWorkout` that was created by this mutation. */
  memberWorkout?: Maybe<IMemberWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `MemberWorkout`. May be used by Relay 1. */
  memberWorkoutEdge?: Maybe<IMemberWorkoutsEdge>;
}

/** The output of our create `MemberWorkout` mutation. */
export interface ICreateMemberWorkoutPayloadMemberWorkoutEdgeArgs {
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
}

/** All input for the create `MentorEvent` mutation. */
export interface ICreateMentorEventInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentorEvent` to be created by this mutation. */
  mentorEvent: IMentorEventInput;
}

/** The output of our create `MentorEvent` mutation. */
export interface ICreateMentorEventPayload {
   __typename?: "CreateMentorEventPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentorEvent` that was created by this mutation. */
  mentorEvent?: Maybe<IMentorEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `MentorEvent`. May be used by Relay 1. */
  mentorEventEdge?: Maybe<IMentorEventsEdge>;
}

/** The output of our create `MentorEvent` mutation. */
export interface ICreateMentorEventPayloadMentorEventEdgeArgs {
  orderBy?: Maybe<IMentorEventsOrderBy[]>;
}

/** All input for the create `MentoringReport` mutation. */
export interface ICreateMentoringReportInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReport` to be created by this mutation. */
  mentoringReport: IMentoringReportInput;
}

/** All input for the create `MentoringReportMessage` mutation. */
export interface ICreateMentoringReportMessageInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReportMessage` to be created by this mutation. */
  mentoringReportMessage: IMentoringReportMessageInput;
}

/** The output of our create `MentoringReportMessage` mutation. */
export interface ICreateMentoringReportMessagePayload {
   __typename?: "CreateMentoringReportMessagePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReportMessage` that was created by this mutation. */
  mentoringReportMessage?: Maybe<IMentoringReportMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MentoringReport` that is related to this `MentoringReportMessage`. */
  mentoringReportByMentoringReportId?: Maybe<IMentoringReport>;
  /** An edge for our `MentoringReportMessage`. May be used by Relay 1. */
  mentoringReportMessageEdge?: Maybe<IMentoringReportMessagesEdge>;
}

/** The output of our create `MentoringReportMessage` mutation. */
export interface ICreateMentoringReportMessagePayloadMentoringReportMessageEdgeArgs {
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
}

/** The output of our create `MentoringReport` mutation. */
export interface ICreateMentoringReportPayload {
   __typename?: "CreateMentoringReportPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReport` that was created by this mutation. */
  mentoringReport?: Maybe<IMentoringReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Coach` that is related to this `MentoringReport`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads a single `Member` that is related to this `MentoringReport`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MentoringReport`. May be used by Relay 1. */
  mentoringReportEdge?: Maybe<IMentoringReportsEdge>;
}

/** The output of our create `MentoringReport` mutation. */
export interface ICreateMentoringReportPayloadMentoringReportEdgeArgs {
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
}

/** All input for the `createNewExercise` mutation. */
export interface ICreateNewExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  name: Scalars["String"];
  description: Scalars["String"];
  meta: Scalars["Json"];
  type: Scalars["String"];
  targetMuscle: Scalars["String"];
  knownAs: Scalars["String"];
  equipment: Scalars["String"];
  alternatives: Scalars["Json"];
  family: Scalars["String"];
  instructions: Scalars["String"];
  media: Array<Maybe<Scalars["String"]>>;
}

/** The output of our `createNewExercise` mutation. */
export interface ICreateNewExercisePayload {
   __typename?: "CreateNewExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  exercise?: Maybe<IExercise>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Exercise`. May be used by Relay 1. */
  exerciseEdge?: Maybe<IExercisesEdge>;
}

/** The output of our `createNewExercise` mutation. */
export interface ICreateNewExercisePayloadExerciseEdgeArgs {
  orderBy?: Maybe<IExercisesOrderBy[]>;
}

/** All input for the create `Notification` mutation. */
export interface ICreateNotificationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Notification` to be created by this mutation. */
  notification: INotificationInput;
}

/** The output of our create `Notification` mutation. */
export interface ICreateNotificationPayload {
   __typename?: "CreateNotificationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<INotification>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<INotificationsEdge>;
}

/** The output of our create `Notification` mutation. */
export interface ICreateNotificationPayloadNotificationEdgeArgs {
  orderBy?: Maybe<INotificationsOrderBy[]>;
}

/** All input for the create `NutritionDay` mutation. */
export interface ICreateNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDay` to be created by this mutation. */
  nutritionDay: INutritionDayInput;
}

/** All input for the create `NutritionDayMeal` mutation. */
export interface ICreateNutritionDayMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDayMeal` to be created by this mutation. */
  nutritionDayMeal: INutritionDayMealInput;
}

/** The output of our create `NutritionDayMeal` mutation. */
export interface ICreateNutritionDayMealPayload {
   __typename?: "CreateNutritionDayMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDayMeal` that was created by this mutation. */
  nutritionDayMeal?: Maybe<INutritionDayMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionDayMeal`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `MemberMeal` that is related to this `NutritionDayMeal`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `NutritionDayMeal`. May be used by Relay 1. */
  nutritionDayMealEdge?: Maybe<INutritionDayMealsEdge>;
}

/** The output of our create `NutritionDayMeal` mutation. */
export interface ICreateNutritionDayMealPayloadNutritionDayMealEdgeArgs {
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
}

/** The output of our create `NutritionDay` mutation. */
export interface ICreateNutritionDayPayload {
   __typename?: "CreateNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDay` that was created by this mutation. */
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our create `NutritionDay` mutation. */
export interface ICreateNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the create `NutritionDictionary` mutation. */
export interface ICreateNutritionDictionaryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDictionary` to be created by this mutation. */
  nutritionDictionary: INutritionDictionaryInput;
}

/** The output of our create `NutritionDictionary` mutation. */
export interface ICreateNutritionDictionaryPayload {
   __typename?: "CreateNutritionDictionaryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDictionary` that was created by this mutation. */
  nutritionDictionary?: Maybe<INutritionDictionary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDictionary` that is related to this `NutritionDictionary`. */
  nutritionDictionaryByParentNutritionId?: Maybe<INutritionDictionary>;
  /** An edge for our `NutritionDictionary`. May be used by Relay 1. */
  nutritionDictionaryEdge?: Maybe<INutritionDictionariesEdge>;
}

/** The output of our create `NutritionDictionary` mutation. */
export interface ICreateNutritionDictionaryPayloadNutritionDictionaryEdgeArgs {
  orderBy?: Maybe<INutritionDictionariesOrderBy[]>;
}

/** All input for the create `NutritionPlanDay` mutation. */
export interface ICreateNutritionPlanDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanDay` to be created by this mutation. */
  nutritionPlanDay: INutritionPlanDayInput;
}

/** The output of our create `NutritionPlanDay` mutation. */
export interface ICreateNutritionPlanDayPayload {
   __typename?: "CreateNutritionPlanDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanDay` that was created by this mutation. */
  nutritionPlanDay?: Maybe<INutritionPlanDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanDay`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanDay`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** An edge for our `NutritionPlanDay`. May be used by Relay 1. */
  nutritionPlanDayEdge?: Maybe<INutritionPlanDaysEdge>;
}

/** The output of our create `NutritionPlanDay` mutation. */
export interface ICreateNutritionPlanDayPayloadNutritionPlanDayEdgeArgs {
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
}

/** All input for the `createNutritionPlan` mutation. */
export interface ICreateNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlan: INutritionPlanInput;
}

/** The output of our `createNutritionPlan` mutation. */
export interface ICreateNutritionPlanPayload {
   __typename?: "CreateNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlan?: Maybe<INutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `NutritionPlan`. May be used by Relay 1. */
  nutritionPlanEdge?: Maybe<INutritionPlansEdge>;
}

/** The output of our `createNutritionPlan` mutation. */
export interface ICreateNutritionPlanPayloadNutritionPlanEdgeArgs {
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
}

/** All input for the create `NutritionPlanSchedule` mutation. */
export interface ICreateNutritionPlanScheduleInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanSchedule` to be created by this mutation. */
  nutritionPlanSchedule: INutritionPlanScheduleInput;
}

/** The output of our create `NutritionPlanSchedule` mutation. */
export interface ICreateNutritionPlanSchedulePayload {
   __typename?: "CreateNutritionPlanSchedulePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanSchedule` that was created by this mutation. */
  nutritionPlanSchedule?: Maybe<INutritionPlanSchedule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanSchedule`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanSchedule`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `NutritionPlanSchedule`. May be used by Relay 1. */
  nutritionPlanScheduleEdge?: Maybe<INutritionPlanSchedulesEdge>;
}

/** The output of our create `NutritionPlanSchedule` mutation. */
export interface ICreateNutritionPlanSchedulePayloadNutritionPlanScheduleEdgeArgs {
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
}

/** All input for the create `NutritionProfile` mutation. */
export interface ICreateNutritionProfileInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfile` to be created by this mutation. */
  nutritionProfile: INutritionProfileInput;
}

/** All input for the create `NutritionProfileMeal` mutation. */
export interface ICreateNutritionProfileMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfileMeal` to be created by this mutation. */
  nutritionProfileMeal: INutritionProfileMealInput;
}

/** The output of our create `NutritionProfileMeal` mutation. */
export interface ICreateNutritionProfileMealPayload {
   __typename?: "CreateNutritionProfileMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfileMeal` that was created by this mutation. */
  nutritionProfileMeal?: Maybe<INutritionProfileMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionProfile` that is related to this `NutritionProfileMeal`. */
  nutritionProfileByNutritionProfileId?: Maybe<INutritionProfile>;
  /** An edge for our `NutritionProfileMeal`. May be used by Relay 1. */
  nutritionProfileMealEdge?: Maybe<INutritionProfileMealsEdge>;
}

/** The output of our create `NutritionProfileMeal` mutation. */
export interface ICreateNutritionProfileMealPayloadNutritionProfileMealEdgeArgs {
  orderBy?: Maybe<INutritionProfileMealsOrderBy[]>;
}

/** The output of our create `NutritionProfile` mutation. */
export interface ICreateNutritionProfilePayload {
   __typename?: "CreateNutritionProfilePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfile` that was created by this mutation. */
  nutritionProfile?: Maybe<INutritionProfile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionProfile`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionProfile`. May be used by Relay 1. */
  nutritionProfileEdge?: Maybe<INutritionProfilesEdge>;
}

/** The output of our create `NutritionProfile` mutation. */
export interface ICreateNutritionProfilePayloadNutritionProfileEdgeArgs {
  orderBy?: Maybe<INutritionProfilesOrderBy[]>;
}

/** All input for the create `ProgramWorkout` mutation. */
export interface ICreateProgramWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ProgramWorkout` to be created by this mutation. */
  programWorkout: IProgramWorkoutInput;
}

/** The output of our create `ProgramWorkout` mutation. */
export interface ICreateProgramWorkoutPayload {
   __typename?: "CreateProgramWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ProgramWorkout` that was created by this mutation. */
  programWorkout?: Maybe<IProgramWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `TrainingProgram` that is related to this `ProgramWorkout`. */
  trainingProgramByProgramId?: Maybe<ITrainingProgram>;
  /** Reads a single `Workout` that is related to this `ProgramWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `ProgramWorkout`. May be used by Relay 1. */
  programWorkoutEdge?: Maybe<IProgramWorkoutsEdge>;
}

/** The output of our create `ProgramWorkout` mutation. */
export interface ICreateProgramWorkoutPayloadProgramWorkoutEdgeArgs {
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
}

/** All input for the create `RecentFood` mutation. */
export interface ICreateRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `RecentFood` to be created by this mutation. */
  recentFood: IRecentFoodInput;
}

/** The output of our create `RecentFood` mutation. */
export interface ICreateRecentFoodPayload {
   __typename?: "CreateRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `RecentFood` that was created by this mutation. */
  recentFood?: Maybe<IRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `RecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `RecentFood`. May be used by Relay 1. */
  recentFoodEdge?: Maybe<IRecentFoodsEdge>;
}

/** The output of our create `RecentFood` mutation. */
export interface ICreateRecentFoodPayloadRecentFoodEdgeArgs {
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
}

/** All input for the `createReservationRequest` mutation. */
export interface ICreateReservationRequestInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  date?: Maybe<Scalars["Date"]>;
  prevTimeslotId?: Maybe<Scalars["Uuid"]>;
  type?: Maybe<IReservationType>;
}

/** The output of our `createReservationRequest` mutation. */
export interface ICreateReservationRequestPayload {
   __typename?: "CreateReservationRequestPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberReservations?: Maybe<Array<Maybe<IMemberReservation>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the create `Serving` mutation. */
export interface ICreateServingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Serving` to be created by this mutation. */
  serving: IServingInput;
}

/** The output of our create `Serving` mutation. */
export interface ICreateServingPayload {
   __typename?: "CreateServingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Serving` that was created by this mutation. */
  serving?: Maybe<IServing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Serving`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Serving`. May be used by Relay 1. */
  servingEdge?: Maybe<IServingsEdge>;
}

/** The output of our create `Serving` mutation. */
export interface ICreateServingPayloadServingEdgeArgs {
  orderBy?: Maybe<IServingsOrderBy[]>;
}

/** All input for the `createSessionByTimeslotId` mutation. */
export interface ICreateSessionByTimeslotIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  timestamp?: Maybe<Scalars["Datetime"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `createSessionByTimeslotId` mutation. */
export interface ICreateSessionByTimeslotIdPayload {
   __typename?: "CreateSessionByTimeslotIdPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  session?: Maybe<ISession>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<ISessionsEdge>;
}

/** The output of our `createSessionByTimeslotId` mutation. */
export interface ICreateSessionByTimeslotIdPayloadSessionEdgeArgs {
  orderBy?: Maybe<ISessionsOrderBy[]>;
}

/** All input for the create `Session` mutation. */
export interface ICreateSessionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Session` to be created by this mutation. */
  session: ISessionInput;
}

/** All input for the create `SessionInstructor` mutation. */
export interface ICreateSessionInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `SessionInstructor` to be created by this mutation. */
  sessionInstructor: ISessionInstructorInput;
}

/** The output of our create `SessionInstructor` mutation. */
export interface ICreateSessionInstructorPayload {
   __typename?: "CreateSessionInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `SessionInstructor` that was created by this mutation. */
  sessionInstructor?: Maybe<ISessionInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `SessionInstructor`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Instructor` that is related to this `SessionInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `SessionInstructor`. May be used by Relay 1. */
  sessionInstructorEdge?: Maybe<ISessionInstructorsEdge>;
}

/** The output of our create `SessionInstructor` mutation. */
export interface ICreateSessionInstructorPayloadSessionInstructorEdgeArgs {
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
}

/** The output of our create `Session` mutation. */
export interface ICreateSessionPayload {
   __typename?: "CreateSessionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Session` that was created by this mutation. */
  session?: Maybe<ISession>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<ISessionsEdge>;
}

/** The output of our create `Session` mutation. */
export interface ICreateSessionPayloadSessionEdgeArgs {
  orderBy?: Maybe<ISessionsOrderBy[]>;
}

/** All input for the create `Setting` mutation. */
export interface ICreateSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Setting` to be created by this mutation. */
  setting: ISettingInput;
}

/** The output of our create `Setting` mutation. */
export interface ICreateSettingPayload {
   __typename?: "CreateSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<ISetting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<ISettingsEdge>;
}

/** The output of our create `Setting` mutation. */
export interface ICreateSettingPayloadSettingEdgeArgs {
  orderBy?: Maybe<ISettingsOrderBy[]>;
}

/** All input for the create `Tag` mutation. */
export interface ICreateTagInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Tag` to be created by this mutation. */
  tag: ITagInput;
}

/** The output of our create `Tag` mutation. */
export interface ICreateTagPayload {
   __typename?: "CreateTagPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<ITag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<ITagsEdge>;
}

/** The output of our create `Tag` mutation. */
export interface ICreateTagPayloadTagEdgeArgs {
  orderBy?: Maybe<ITagsOrderBy[]>;
}

/** All input for the create `Timeslot` mutation. */
export interface ICreateTimeslotInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Timeslot` to be created by this mutation. */
  timeslot: ITimeslotInput;
}

/** The output of our create `Timeslot` mutation. */
export interface ICreateTimeslotPayload {
   __typename?: "CreateTimeslotPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Timeslot` that was created by this mutation. */
  timeslot?: Maybe<ITimeslot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `Timeslot`. */
  classByClassId?: Maybe<IClass>;
  /** An edge for our `Timeslot`. May be used by Relay 1. */
  timeslotEdge?: Maybe<ITimeslotsEdge>;
}

/** The output of our create `Timeslot` mutation. */
export interface ICreateTimeslotPayloadTimeslotEdgeArgs {
  orderBy?: Maybe<ITimeslotsOrderBy[]>;
}

export interface ICreateTrainingProgramInput {
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingProgram: ITrainingProgramInput;
}

export interface ICreateTrainingProgramPayload {
   __typename?: "CreateTrainingProgramPayload";
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingProgram: IOldTrainingProgram;
}

/** All input for the create `UserSetting` mutation. */
export interface ICreateUserSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `UserSetting` to be created by this mutation. */
  userSetting: IUserSettingInput;
}

/** The output of our create `UserSetting` mutation. */
export interface ICreateUserSettingPayload {
   __typename?: "CreateUserSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `UserSetting` that was created by this mutation. */
  userSetting?: Maybe<IUserSetting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  settingBySettingId?: Maybe<ISetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<IUserSettingsEdge>;
}

/** The output of our create `UserSetting` mutation. */
export interface ICreateUserSettingPayloadUserSettingEdgeArgs {
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
}

export interface ICreateWorkoutByProgramIdInput {
  name: Scalars["String"];
  body: Scalars["Json"];
  programId: Scalars["Int"];
}

export interface ICreateWorkoutByProgramIdPayload {
   __typename?: "CreateWorkoutByProgramIdPayload";
  workoutByWorkoutId: IOldWorkout;
}

/** All input for the create `WorkoutExerciseAttempt` mutation. */
export interface ICreateWorkoutExerciseAttemptInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExerciseAttempt` to be created by this mutation. */
  workoutExerciseAttempt: IWorkoutExerciseAttemptInput;
}

/** The output of our create `WorkoutExerciseAttempt` mutation. */
export interface ICreateWorkoutExerciseAttemptPayload {
   __typename?: "CreateWorkoutExerciseAttemptPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExerciseAttempt` that was created by this mutation. */
  workoutExerciseAttempt?: Maybe<IWorkoutExerciseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MemberWorkout` that is related to this `WorkoutExerciseAttempt`. */
  memberWorkoutByMemberWorkoutId?: Maybe<IMemberWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExerciseAttempt`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** An edge for our `WorkoutExerciseAttempt`. May be used by Relay 1. */
  workoutExerciseAttemptEdge?: Maybe<IWorkoutExerciseAttemptsEdge>;
}

/** The output of our create `WorkoutExerciseAttempt` mutation. */
export interface ICreateWorkoutExerciseAttemptPayloadWorkoutExerciseAttemptEdgeArgs {
  orderBy?: Maybe<IWorkoutExerciseAttemptsOrderBy[]>;
}

/** All input for the create `WorkoutExercise` mutation. */
export interface ICreateWorkoutExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExercise` to be created by this mutation. */
  workoutExercise: IWorkoutExerciseInput;
}

/** The output of our create `WorkoutExercise` mutation. */
export interface ICreateWorkoutExercisePayload {
   __typename?: "CreateWorkoutExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExercise` that was created by this mutation. */
  workoutExercise?: Maybe<IWorkoutExercise>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutExercise`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExercise`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** An edge for our `WorkoutExercise`. May be used by Relay 1. */
  workoutExerciseEdge?: Maybe<IWorkoutExercisesEdge>;
}

/** The output of our create `WorkoutExercise` mutation. */
export interface ICreateWorkoutExercisePayloadWorkoutExerciseEdgeArgs {
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
}

/** All input for the `createWorkoutInProgramByIdV2` mutation. */
export interface ICreateWorkoutInProgramByIdV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  name?: Maybe<Scalars["String"]>;
  body?: Maybe<Scalars["Json"]>;
  programId?: Maybe<Scalars["Int"]>;
  duration?: Maybe<Scalars["Int"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `createWorkoutInProgramByIdV2` mutation. */
export interface ICreateWorkoutInProgramByIdV2Payload {
   __typename?: "CreateWorkoutInProgramByIdV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  programWorkout?: Maybe<IProgramWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `TrainingProgram` that is related to this `ProgramWorkout`. */
  trainingProgramByProgramId?: Maybe<ITrainingProgram>;
  /** Reads a single `Workout` that is related to this `ProgramWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `ProgramWorkout`. May be used by Relay 1. */
  programWorkoutEdge?: Maybe<IProgramWorkoutsEdge>;
}

/** The output of our `createWorkoutInProgramByIdV2` mutation. */
export interface ICreateWorkoutInProgramByIdV2PayloadProgramWorkoutEdgeArgs {
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
}

/** All input for the create `Workout` mutation. */
export interface ICreateWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Workout` to be created by this mutation. */
  workout: IWorkoutInput;
}

export interface ICreateWorkoutNodeEventInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout content for update */
  workoutNodeEvent: IWorkoutNodeEventInput;
}

export interface ICreateWorkoutNodeEventPayload {
   __typename?: "CreateWorkoutNodeEventPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated workout */
  workoutNodeEvent: IOldWorkoutNodeEvent;
}

/** All input for the create `WorkoutNode` mutation. */
export interface ICreateWorkoutNodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNode` to be created by this mutation. */
  workoutNode: IWorkoutNodeInput;
}

/** The output of our create `WorkoutNode` mutation. */
export interface ICreateWorkoutNodePayload {
   __typename?: "CreateWorkoutNodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNode` that was created by this mutation. */
  workoutNode?: Maybe<IWorkoutNode>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `WorkoutNode` that is related to this `WorkoutNode`. */
  workoutNodeByParentId?: Maybe<IWorkoutNode>;
  /** Reads a single `Workout` that is related to this `WorkoutNode`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutNode`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `WorkoutNode`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `WorkoutNode`. May be used by Relay 1. */
  workoutNodeEdge?: Maybe<IWorkoutNodesEdge>;
}

/** The output of our create `WorkoutNode` mutation. */
export interface ICreateWorkoutNodePayloadWorkoutNodeEdgeArgs {
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
}

/** The output of our create `Workout` mutation. */
export interface ICreateWorkoutPayload {
   __typename?: "CreateWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Workout` that was created by this mutation. */
  workout?: Maybe<IWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Workout`. May be used by Relay 1. */
  workoutEdge?: Maybe<IWorkoutsEdge>;
}

/** The output of our create `Workout` mutation. */
export interface ICreateWorkoutPayloadWorkoutEdgeArgs {
  orderBy?: Maybe<IWorkoutsOrderBy[]>;
}

export interface ICreateWorkoutTemplateDirectoryInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout template directory */
  workoutTemplateDirectory: IWorkoutTemplateDirectoryInput;
}

export interface ICreateWorkoutTemplateDirectoryPayload {
   __typename?: "CreateWorkoutTemplateDirectoryPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** created workout template directory */
  workoutTemplateDirectory: IWorkoutTemplateDirectory;
}

export interface IDailyAttendanceView {
   __typename?: "DailyAttendanceView";
  date?: Maybe<Scalars["Date"]>;
  personId?: Maybe<Scalars["Uuid"]>;
  attendedOnce?: Maybe<Scalars["Boolean"]>;
  actual?: Maybe<Scalars["BigInt"]>;
  walkIns?: Maybe<Scalars["BigInt"]>;
  registered?: Maybe<Scalars["BigInt"]>;
  suspended?: Maybe<Scalars["BigInt"]>;
  sessionClubId?: Maybe<Scalars["Uuid"]>;
}

/**
 * A condition to be used against `DailyAttendanceView` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IDailyAttendanceViewCondition {
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `attendedOnce` field. */
  attendedOnce?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `actual` field. */
  actual?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `walkIns` field. */
  walkIns?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `registered` field. */
  registered?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `suspended` field. */
  suspended?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `sessionClubId` field. */
  sessionClubId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `DailyAttendanceView` values. */
export interface IDailyAttendanceViewsConnection {
   __typename?: "DailyAttendanceViewsConnection";
  /** A list of `DailyAttendanceView` objects. */
  nodes: Array<Maybe<IDailyAttendanceView>>;
  /** A list of edges which contains the `DailyAttendanceView` and cursor to aid in pagination. */
  edges: IDailyAttendanceViewsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `DailyAttendanceView` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `DailyAttendanceView` edge in the connection. */
export interface IDailyAttendanceViewsEdge {
   __typename?: "DailyAttendanceViewsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `DailyAttendanceView` at the end of the edge. */
  node?: Maybe<IDailyAttendanceView>;
}

/** Methods to use when ordering `DailyAttendanceView`. */
export enum IDailyAttendanceViewsOrderBy {
  Natural = "NATURAL",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  PersonIdAsc = "PERSON_ID_ASC",
  PersonIdDesc = "PERSON_ID_DESC",
  AttendedOnceAsc = "ATTENDED_ONCE_ASC",
  AttendedOnceDesc = "ATTENDED_ONCE_DESC",
  ActualAsc = "ACTUAL_ASC",
  ActualDesc = "ACTUAL_DESC",
  WalkInsAsc = "WALK_INS_ASC",
  WalkInsDesc = "WALK_INS_DESC",
  RegisteredAsc = "REGISTERED_ASC",
  RegisteredDesc = "REGISTERED_DESC",
  SuspendedAsc = "SUSPENDED_ASC",
  SuspendedDesc = "SUSPENDED_DESC",
  SessionClubIdAsc = "SESSION_CLUB_ID_ASC",
  SessionClubIdDesc = "SESSION_CLUB_ID_DESC",
}

export interface IDataSource  extends INode {
   __typename?: "DataSource";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["String"];
  name: Scalars["String"];
  rating: IRating;
  sourceName?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `FoodbankFood`. */
  foodbankFoodsBySource: IFoodbankFoodsConnection;
}

export interface IDataSourceFoodbankFoodsBySourceArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
  condition?: Maybe<IFoodbankFoodCondition>;
}

/**
 * A condition to be used against `DataSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IDataSourceCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `rating` field. */
  rating?: Maybe<IRating>;
  /** Checks for equality with the object’s `sourceName` field. */
  sourceName?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `DataSource` */
export interface IDataSourceInput {
  id: Scalars["String"];
  name: Scalars["String"];
  rating: IRating;
  sourceName?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `DataSource`. Fields that are set will be updated. */
export interface IDataSourcePatch {
  id?: Maybe<Scalars["String"]>;
  name?: Maybe<Scalars["String"]>;
  rating?: Maybe<IRating>;
  sourceName?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `DataSource` values. */
export interface IDataSourcesConnection {
   __typename?: "DataSourcesConnection";
  /** A list of `DataSource` objects. */
  nodes: Array<Maybe<IDataSource>>;
  /** A list of edges which contains the `DataSource` and cursor to aid in pagination. */
  edges: IDataSourcesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `DataSource` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `DataSource` edge in the connection. */
export interface IDataSourcesEdge {
   __typename?: "DataSourcesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `DataSource` at the end of the edge. */
  node?: Maybe<IDataSource>;
}

/** Methods to use when ordering `DataSource`. */
export enum IDataSourcesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  RatingAsc = "RATING_ASC",
  RatingDesc = "RATING_DESC",
  SourceNameAsc = "SOURCE_NAME_ASC",
  SourceNameDesc = "SOURCE_NAME_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** All input for the `deleteAttendanceById` mutation. */
export interface IDeleteAttendanceByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteAttendanceBySessionIdAndPersonId` mutation. */
export interface IDeleteAttendanceBySessionIdAndPersonIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  sessionId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
}

/** All input for the `deleteAttendance` mutation. */
export interface IDeleteAttendanceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Attendance` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteAttendanceOverrideById` mutation. */
export interface IDeleteAttendanceOverrideByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteAttendanceOverride` mutation. */
export interface IDeleteAttendanceOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `AttendanceOverride` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `AttendanceOverride` mutation. */
export interface IDeleteAttendanceOverridePayload {
   __typename?: "DeleteAttendanceOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendanceOverride` that was deleted by this mutation. */
  attendanceOverride?: Maybe<IAttendanceOverride>;
  deletedAttendanceOverrideId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendanceOverride`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Attendance` that is related to this `AttendanceOverride`. */
  attendanceByAttendanceId?: Maybe<IAttendance>;
  /** Reads a single `Booking` that is related to this `AttendanceOverride`. */
  bookingByBookingId?: Maybe<IBooking>;
  /** An edge for our `AttendanceOverride`. May be used by Relay 1. */
  attendanceOverrideEdge?: Maybe<IAttendanceOverridesEdge>;
}

/** The output of our delete `AttendanceOverride` mutation. */
export interface IDeleteAttendanceOverridePayloadAttendanceOverrideEdgeArgs {
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
}

/** The output of our delete `Attendance` mutation. */
export interface IDeleteAttendancePayload {
   __typename?: "DeleteAttendancePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendance` that was deleted by this mutation. */
  attendance?: Maybe<IAttendance>;
  deletedAttendanceId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `Attendance`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Attendee` that is related to this `Attendance`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Attendance`. May be used by Relay 1. */
  attendanceEdge?: Maybe<IAttendancesEdge>;
}

/** The output of our delete `Attendance` mutation. */
export interface IDeleteAttendancePayloadAttendanceEdgeArgs {
  orderBy?: Maybe<IAttendancesOrderBy[]>;
}

/** All input for the `deleteAttendeeById` mutation. */
export interface IDeleteAttendeeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteAttendeeClubByAttendeeIdAndClubId` mutation. */
export interface IDeleteAttendeeClubByAttendeeIdAndClubIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  attendeeId: Scalars["Uuid"];
  clubId: Scalars["Uuid"];
}

/** All input for the `deleteAttendeeClub` mutation. */
export interface IDeleteAttendeeClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `AttendeeClub` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `AttendeeClub` mutation. */
export interface IDeleteAttendeeClubPayload {
   __typename?: "DeleteAttendeeClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendeeClub` that was deleted by this mutation. */
  attendeeClub?: Maybe<IAttendeeClub>;
  deletedAttendeeClubId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendeeClub`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Club` that is related to this `AttendeeClub`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `AttendeeClub`. May be used by Relay 1. */
  attendeeClubEdge?: Maybe<IAttendeeClubsEdge>;
}

/** The output of our delete `AttendeeClub` mutation. */
export interface IDeleteAttendeeClubPayloadAttendeeClubEdgeArgs {
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
}

/** All input for the `deleteAttendee` mutation. */
export interface IDeleteAttendeeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Attendee` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Attendee` mutation. */
export interface IDeleteAttendeePayload {
   __typename?: "DeleteAttendeePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendee` that was deleted by this mutation. */
  attendee?: Maybe<IAttendee>;
  deletedAttendeeId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Attendee`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Attendee`. May be used by Relay 1. */
  attendeeEdge?: Maybe<IAttendeesEdge>;
}

/** The output of our delete `Attendee` mutation. */
export interface IDeleteAttendeePayloadAttendeeEdgeArgs {
  orderBy?: Maybe<IAttendeesOrderBy[]>;
}

/** All input for the `deleteBookingById` mutation. */
export interface IDeleteBookingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteBooking` mutation. */
export interface IDeleteBookingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Booking` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Booking` mutation. */
export interface IDeleteBookingPayload {
   __typename?: "DeleteBookingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Booking` that was deleted by this mutation. */
  booking?: Maybe<IBooking>;
  deletedBookingId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Booking`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `Booking`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Booking`. May be used by Relay 1. */
  bookingEdge?: Maybe<IBookingsEdge>;
}

/** The output of our delete `Booking` mutation. */
export interface IDeleteBookingPayloadBookingEdgeArgs {
  orderBy?: Maybe<IBookingsOrderBy[]>;
}

/** All input for the `deleteBrandBarcodeByBrandIdAndGtinId` mutation. */
export interface IDeleteBrandBarcodeByBrandIdAndGtinIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  brandId: Scalars["Uuid"];
  gtinId: Scalars["String"];
}

/** All input for the `deleteBrandBarcode` mutation. */
export interface IDeleteBrandBarcodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `BrandBarcode` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `BrandBarcode` mutation. */
export interface IDeleteBrandBarcodePayload {
   __typename?: "DeleteBrandBarcodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `BrandBarcode` that was deleted by this mutation. */
  brandBarcode?: Maybe<IBrandBarcode>;
  deletedBrandBarcodeId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `BrandBarcode`. */
  brandByBrandId?: Maybe<IBrand>;
  /** An edge for our `BrandBarcode`. May be used by Relay 1. */
  brandBarcodeEdge?: Maybe<IBrandBarcodesEdge>;
}

/** The output of our delete `BrandBarcode` mutation. */
export interface IDeleteBrandBarcodePayloadBrandBarcodeEdgeArgs {
  orderBy?: Maybe<IBrandBarcodesOrderBy[]>;
}

/** All input for the `deleteBrandById` mutation. */
export interface IDeleteBrandByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteBrand` mutation. */
export interface IDeleteBrandInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Brand` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Brand` mutation. */
export interface IDeleteBrandPayload {
   __typename?: "DeleteBrandPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Brand` that was deleted by this mutation. */
  brand?: Maybe<IBrand>;
  deletedBrandId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<IBrandsEdge>;
}

/** The output of our delete `Brand` mutation. */
export interface IDeleteBrandPayloadBrandEdgeArgs {
  orderBy?: Maybe<IBrandsOrderBy[]>;
}

/** All input for the `deleteCategoryById` mutation. */
export interface IDeleteCategoryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteCategory` mutation. */
export interface IDeleteCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Category` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Category` mutation. */
export interface IDeleteCategoryPayload {
   __typename?: "DeleteCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Category` that was deleted by this mutation. */
  category?: Maybe<ICategory>;
  deletedCategoryId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<ICategoriesEdge>;
}

/** The output of our delete `Category` mutation. */
export interface IDeleteCategoryPayloadCategoryEdgeArgs {
  orderBy?: Maybe<ICategoriesOrderBy[]>;
}

/** All input for the `deleteClassById` mutation. */
export interface IDeleteClassByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteClass` mutation. */
export interface IDeleteClassInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Class` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteClassInstructorByClassIdAndInstructorId` mutation. */
export interface IDeleteClassInstructorByClassIdAndInstructorIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  classId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

/** All input for the `deleteClassInstructor` mutation. */
export interface IDeleteClassInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ClassInstructor` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `ClassInstructor` mutation. */
export interface IDeleteClassInstructorPayload {
   __typename?: "DeleteClassInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ClassInstructor` that was deleted by this mutation. */
  classInstructor?: Maybe<IClassInstructor>;
  deletedClassInstructorId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `ClassInstructor`. */
  classByClassId?: Maybe<IClass>;
  /** Reads a single `Instructor` that is related to this `ClassInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `ClassInstructor`. May be used by Relay 1. */
  classInstructorEdge?: Maybe<IClassInstructorsEdge>;
}

/** The output of our delete `ClassInstructor` mutation. */
export interface IDeleteClassInstructorPayloadClassInstructorEdgeArgs {
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
}

/** The output of our delete `Class` mutation. */
export interface IDeleteClassPayload {
   __typename?: "DeleteClassPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Class` that was deleted by this mutation. */
  class?: Maybe<IClass>;
  deletedClassId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Class`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Class`. May be used by Relay 1. */
  classEdge?: Maybe<IClassesEdge>;
}

/** The output of our delete `Class` mutation. */
export interface IDeleteClassPayloadClassEdgeArgs {
  orderBy?: Maybe<IClassesOrderBy[]>;
}

/** All input for the `deleteClubById` mutation. */
export interface IDeleteClubByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteClubByKsClubId` mutation. */
export interface IDeleteClubByKsClubIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** 1-1 ref to ks_meta.club(id) */
  ksClubId: Scalars["String"];
}

/** All input for the `deleteClub` mutation. */
export interface IDeleteClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Club` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Club` mutation. */
export interface IDeleteClubPayload {
   __typename?: "DeleteClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Club` that was deleted by this mutation. */
  club?: Maybe<IClub>;
  deletedClubId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Club`. May be used by Relay 1. */
  clubEdge?: Maybe<IClubsEdge>;
}

/** The output of our delete `Club` mutation. */
export interface IDeleteClubPayloadClubEdgeArgs {
  orderBy?: Maybe<IClubsOrderBy[]>;
}

/** All input for the `deleteCoachById` mutation. */
export interface IDeleteCoachByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The primary unique identifier for the coach. */
  id: Scalars["Int"];
}

/** All input for the `deleteCoach` mutation. */
export interface IDeleteCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Coach` to be deleted. */
  nodeId: Scalars["ID"];
}

export interface IDeleteCoachMembersInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
  /** List of member ids to delete */
  memberIds: Array<Scalars["ID"]>;
}

export interface IDeleteCoachMembersPayload {
   __typename?: "DeleteCoachMembersPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
}

/** The output of our delete `Coach` mutation. */
export interface IDeleteCoachPayload {
   __typename?: "DeleteCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Coach` that was deleted by this mutation. */
  coach?: Maybe<ICoach>;
  deletedCoachId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Coach`. */
  locationByLocationId?: Maybe<ILocation>;
  /** An edge for our `Coach`. May be used by Relay 1. */
  coachEdge?: Maybe<ICoachesEdge>;
}

/** The output of our delete `Coach` mutation. */
export interface IDeleteCoachPayloadCoachEdgeArgs {
  orderBy?: Maybe<ICoachesOrderBy[]>;
}

/** All input for the `deleteCompositionByFoodId` mutation. */
export interface IDeleteCompositionByFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodId: Scalars["Uuid"];
}

/** All input for the `deleteComposition` mutation. */
export interface IDeleteCompositionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Composition` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Composition` mutation. */
export interface IDeleteCompositionPayload {
   __typename?: "DeleteCompositionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Composition` that was deleted by this mutation. */
  composition?: Maybe<IComposition>;
  deletedCompositionId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Composition`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Composition`. May be used by Relay 1. */
  compositionEdge?: Maybe<ICompositionsEdge>;
}

/** The output of our delete `Composition` mutation. */
export interface IDeleteCompositionPayloadCompositionEdgeArgs {
  orderBy?: Maybe<ICompositionsOrderBy[]>;
}

/** All input for the `deleteCountryById` mutation. */
export interface IDeleteCountryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteCountry` mutation. */
export interface IDeleteCountryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Country` mutation. */
export interface IDeleteCountryPayload {
   __typename?: "DeleteCountryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<ICountry>;
  deletedCountryId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<ICountriesEdge>;
}

/** The output of our delete `Country` mutation. */
export interface IDeleteCountryPayloadCountryEdgeArgs {
  orderBy?: Maybe<ICountriesOrderBy[]>;
}

/** All input for the `deleteDataSourceById` mutation. */
export interface IDeleteDataSourceByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["String"];
}

/** All input for the `deleteDataSourceBySourceName` mutation. */
export interface IDeleteDataSourceBySourceNameInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  sourceName: Scalars["String"];
}

/** All input for the `deleteDataSource` mutation. */
export interface IDeleteDataSourceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `DataSource` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `DataSource` mutation. */
export interface IDeleteDataSourcePayload {
   __typename?: "DeleteDataSourcePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `DataSource` that was deleted by this mutation. */
  dataSource?: Maybe<IDataSource>;
  deletedDataSourceId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `DataSource`. May be used by Relay 1. */
  dataSourceEdge?: Maybe<IDataSourcesEdge>;
}

/** The output of our delete `DataSource` mutation. */
export interface IDeleteDataSourcePayloadDataSourceEdgeArgs {
  orderBy?: Maybe<IDataSourcesOrderBy[]>;
}

/** All input for the `deleteExerciseById` mutation. */
export interface IDeleteExerciseByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteExercise` mutation. */
export interface IDeleteExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Exercise` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteExerciseOverrideByExerciseIdAndWorkspaceId` mutation. */
export interface IDeleteExerciseOverrideByExerciseIdAndWorkspaceIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  exerciseId: Scalars["Uuid"];
  workspaceId: Scalars["Int"];
}

/** All input for the `deleteExerciseOverrideById` mutation. */
export interface IDeleteExerciseOverrideByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteExerciseOverride` mutation. */
export interface IDeleteExerciseOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ExerciseOverride` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `ExerciseOverride` mutation. */
export interface IDeleteExerciseOverridePayload {
   __typename?: "DeleteExerciseOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ExerciseOverride` that was deleted by this mutation. */
  exerciseOverride?: Maybe<IExerciseOverride>;
  deletedExerciseOverrideId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Exercise` that is related to this `ExerciseOverride`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `ExerciseOverride`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `ExerciseOverride`. May be used by Relay 1. */
  exerciseOverrideEdge?: Maybe<IExerciseOverridesEdge>;
}

/** The output of our delete `ExerciseOverride` mutation. */
export interface IDeleteExerciseOverridePayloadExerciseOverrideEdgeArgs {
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
}

/** The output of our delete `Exercise` mutation. */
export interface IDeleteExercisePayload {
   __typename?: "DeleteExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Exercise` that was deleted by this mutation. */
  exercise?: Maybe<IExercise>;
  deletedExerciseId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Exercise`. May be used by Relay 1. */
  exerciseEdge?: Maybe<IExercisesEdge>;
}

/** The output of our delete `Exercise` mutation. */
export interface IDeleteExercisePayloadExerciseEdgeArgs {
  orderBy?: Maybe<IExercisesOrderBy[]>;
}

/** All input for the `deleteFavouriteFoodById` mutation. */
export interface IDeleteFavouriteFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteFavouriteFood` mutation. */
export interface IDeleteFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FavouriteFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `FavouriteFood` mutation. */
export interface IDeleteFavouriteFoodPayload {
   __typename?: "DeleteFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FavouriteFood` that was deleted by this mutation. */
  favouriteFood?: Maybe<IFavouriteFood>;
  deletedFavouriteFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `FavouriteFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `FavouriteFood`. May be used by Relay 1. */
  favouriteFoodEdge?: Maybe<IFavouriteFoodsEdge>;
}

/** The output of our delete `FavouriteFood` mutation. */
export interface IDeleteFavouriteFoodPayloadFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
}

/** All input for the `deleteFeatures` mutation. */
export interface IDeleteFeaturesInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  featureIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  userIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
}

/** The output of our `deleteFeatures` mutation. */
export interface IDeleteFeaturesPayload {
   __typename?: "DeleteFeaturesPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteFoodbankFoodById` mutation. */
export interface IDeleteFoodbankFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteFoodbankFood` mutation. */
export interface IDeleteFoodbankFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodbankFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `FoodbankFood` mutation. */
export interface IDeleteFoodbankFoodPayload {
   __typename?: "DeleteFoodbankFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankFood` that was deleted by this mutation. */
  foodbankFood?: Maybe<IFoodbankFood>;
  deletedFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `FoodbankFood`. */
  brandByBrand?: Maybe<IBrand>;
  /** Reads a single `Country` that is related to this `FoodbankFood`. */
  countryByCountryId?: Maybe<ICountry>;
  /** Reads a single `DataSource` that is related to this `FoodbankFood`. */
  dataSourceBySource?: Maybe<IDataSource>;
  /** An edge for our `FoodbankFood`. May be used by Relay 1. */
  foodbankFoodEdge?: Maybe<IFoodbankFoodsEdge>;
}

/** The output of our delete `FoodbankFood` mutation. */
export interface IDeleteFoodbankFoodPayloadFoodbankFoodEdgeArgs {
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
}

/** All input for the `deleteFoodbankNutritionFactByFoodId` mutation. */
export interface IDeleteFoodbankNutritionFactByFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodId: Scalars["Uuid"];
}

/** All input for the `deleteFoodbankNutritionFact` mutation. */
export interface IDeleteFoodbankNutritionFactInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodbankNutritionFact` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `FoodbankNutritionFact` mutation. */
export interface IDeleteFoodbankNutritionFactPayload {
   __typename?: "DeleteFoodbankNutritionFactPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankNutritionFact` that was deleted by this mutation. */
  foodbankNutritionFact?: Maybe<IFoodbankNutritionFact>;
  deletedNutritionFactId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodbankNutritionFact`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `FoodbankNutritionFact`. May be used by Relay 1. */
  foodbankNutritionFactEdge?: Maybe<IFoodbankNutritionFactsEdge>;
}

/** The output of our delete `FoodbankNutritionFact` mutation. */
export interface IDeleteFoodbankNutritionFactPayloadFoodbankNutritionFactEdgeArgs {
  orderBy?: Maybe<IFoodbankNutritionFactsOrderBy[]>;
}

/** All input for the `deleteFoodById` mutation. */
export interface IDeleteFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteFoodCategoryByFoodIdAndCategoryId` mutation. */
export interface IDeleteFoodCategoryByFoodIdAndCategoryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodId: Scalars["Uuid"];
  categoryId: Scalars["Int"];
}

/** All input for the `deleteFoodCategory` mutation. */
export interface IDeleteFoodCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodCategory` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `FoodCategory` mutation. */
export interface IDeleteFoodCategoryPayload {
   __typename?: "DeleteFoodCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodCategory` that was deleted by this mutation. */
  foodCategory?: Maybe<IFoodCategory>;
  deletedFoodCategoryId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodCategory`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** Reads a single `Category` that is related to this `FoodCategory`. */
  categoryByCategoryId?: Maybe<ICategory>;
  /** An edge for our `FoodCategory`. May be used by Relay 1. */
  foodCategoryEdge?: Maybe<IFoodCategoriesEdge>;
}

/** The output of our delete `FoodCategory` mutation. */
export interface IDeleteFoodCategoryPayloadFoodCategoryEdgeArgs {
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
}

/** All input for the `deleteFood` mutation. */
export interface IDeleteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Food` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Food` mutation. */
export interface IDeleteFoodPayload {
   __typename?: "DeleteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Food` that was deleted by this mutation. */
  food?: Maybe<IFood>;
  deletedFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `Food`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `Food`. May be used by Relay 1. */
  foodEdge?: Maybe<IFoodsEdge>;
}

/** The output of our delete `Food` mutation. */
export interface IDeleteFoodPayloadFoodEdgeArgs {
  orderBy?: Maybe<IFoodsOrderBy[]>;
}

/** All input for the `deleteFullNutritionDay` mutation. */
export interface IDeleteFullNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  day?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `deleteFullNutritionDay` mutation. */
export interface IDeleteFullNutritionDayPayload {
   __typename?: "DeleteFullNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteGtinByFoodIdAndGtin` mutation. */
export interface IDeleteGtinByFoodIdAndGtinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodId: Scalars["Uuid"];
  gtin: Scalars["String"];
}

/** All input for the `deleteGtin` mutation. */
export interface IDeleteGtinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Gtin` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Gtin` mutation. */
export interface IDeleteGtinPayload {
   __typename?: "DeleteGtinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Gtin` that was deleted by this mutation. */
  gtin?: Maybe<IGtin>;
  deletedGtinId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Gtin`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Gtin`. May be used by Relay 1. */
  gtinEdge?: Maybe<IGtinsEdge>;
}

/** The output of our delete `Gtin` mutation. */
export interface IDeleteGtinPayloadGtinEdgeArgs {
  orderBy?: Maybe<IGtinsOrderBy[]>;
}

/** All input for the `deleteHistoryActionById` mutation. */
export interface IDeleteHistoryActionByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteHistoryAction` mutation. */
export interface IDeleteHistoryActionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `HistoryAction` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `HistoryAction` mutation. */
export interface IDeleteHistoryActionPayload {
   __typename?: "DeleteHistoryActionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `HistoryAction` that was deleted by this mutation. */
  historyAction?: Maybe<IHistoryAction>;
  deletedHistoryActionId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `HistoryAction`. May be used by Relay 1. */
  historyActionEdge?: Maybe<IHistoryActionsEdge>;
}

/** The output of our delete `HistoryAction` mutation. */
export interface IDeleteHistoryActionPayloadHistoryActionEdgeArgs {
  orderBy?: Maybe<IHistoryActionsOrderBy[]>;
}

/** All input for the `deleteInsightsById` mutation. */
export interface IDeleteInsightsByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** The output of our `deleteInsightsById` mutation. */
export interface IDeleteInsightsByIdPayload {
   __typename?: "DeleteInsightsByIdPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteInstructorById` mutation. */
export interface IDeleteInstructorByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteInstructor` mutation. */
export interface IDeleteInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Instructor` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Instructor` mutation. */
export interface IDeleteInstructorPayload {
   __typename?: "DeleteInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Instructor` that was deleted by this mutation. */
  instructor?: Maybe<IInstructor>;
  deletedInstructorId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Instructor`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Instructor`. May be used by Relay 1. */
  instructorEdge?: Maybe<IInstructorsEdge>;
}

/** The output of our delete `Instructor` mutation. */
export interface IDeleteInstructorPayloadInstructorEdgeArgs {
  orderBy?: Maybe<IInstructorsOrderBy[]>;
}

export interface IDeleteJournalTargetInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Target ID */
  targetId: Scalars["ID"];
}

export interface IDeleteJournalTargetPayload {
   __typename?: "DeleteJournalTargetPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Deleted target */
  target: IFoodJournalUserTarget;
}

/** All input for the `deleteLocationById` mutation. */
export interface IDeleteLocationByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteLocation` mutation. */
export interface IDeleteLocationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Location` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Location` mutation. */
export interface IDeleteLocationPayload {
   __typename?: "DeleteLocationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Location` that was deleted by this mutation. */
  location?: Maybe<ILocation>;
  deletedLocationId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge?: Maybe<ILocationsEdge>;
}

/** The output of our delete `Location` mutation. */
export interface IDeleteLocationPayloadLocationEdgeArgs {
  orderBy?: Maybe<ILocationsOrderBy[]>;
}

/** All input for the `deleteManagerById` mutation. */
export interface IDeleteManagerByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteManagerClubOrgById` mutation. */
export interface IDeleteManagerClubOrgByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteManagerClubOrg` mutation. */
export interface IDeleteManagerClubOrgInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ManagerClubOrg` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `ManagerClubOrg` mutation. */
export interface IDeleteManagerClubOrgPayload {
   __typename?: "DeleteManagerClubOrgPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ManagerClubOrg` that was deleted by this mutation. */
  managerClubOrg?: Maybe<IManagerClubOrg>;
  deletedManagerClubOrgId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Manager` that is related to this `ManagerClubOrg`. */
  managerByManagerId?: Maybe<IManager>;
  /** An edge for our `ManagerClubOrg`. May be used by Relay 1. */
  managerClubOrgEdge?: Maybe<IManagerClubOrgsEdge>;
}

/** The output of our delete `ManagerClubOrg` mutation. */
export interface IDeleteManagerClubOrgPayloadManagerClubOrgEdgeArgs {
  orderBy?: Maybe<IManagerClubOrgsOrderBy[]>;
}

/** All input for the `deleteManager` mutation. */
export interface IDeleteManagerInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Manager` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Manager` mutation. */
export interface IDeleteManagerPayload {
   __typename?: "DeleteManagerPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Manager` that was deleted by this mutation. */
  manager?: Maybe<IManager>;
  deletedManagerId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Manager`. May be used by Relay 1. */
  managerEdge?: Maybe<IManagersEdge>;
}

/** The output of our delete `Manager` mutation. */
export interface IDeleteManagerPayloadManagerEdgeArgs {
  orderBy?: Maybe<IManagersOrderBy[]>;
}

/** All input for the `deleteMealItemById` mutation. */
export interface IDeleteMealItemByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMealItem` mutation. */
export interface IDeleteMealItemInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MealItem` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MealItem` mutation. */
export interface IDeleteMealItemPayload {
   __typename?: "DeleteMealItemPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MealItem` that was deleted by this mutation. */
  mealItem?: Maybe<IMealItem>;
  deletedMealItemId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MemberMeal` that is related to this `MealItem`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** Reads a single `Food` that is related to this `MealItem`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MealItem`. May be used by Relay 1. */
  mealItemEdge?: Maybe<IMealItemsEdge>;
}

/** The output of our delete `MealItem` mutation. */
export interface IDeleteMealItemPayloadMealItemEdgeArgs {
  orderBy?: Maybe<IMealItemsOrderBy[]>;
}

export interface IDeleteMealPhotoInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Image ID */
  imageId: Scalars["ID"];
}

export interface IDeleteMealPhotoPayload {
   __typename?: "DeleteMealPhotoPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

/** All input for the `deleteMemberById` mutation. */
export interface IDeleteMemberByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The primary unique identifier for the member. */
  id: Scalars["Int"];
}

/** All input for the `deleteMemberCheckinById` mutation. */
export interface IDeleteMemberCheckinByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberCheckin` mutation. */
export interface IDeleteMemberCheckinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberCheckin` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberCheckin` mutation. */
export interface IDeleteMemberCheckinPayload {
   __typename?: "DeleteMemberCheckinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberCheckin` that was deleted by this mutation. */
  memberCheckin?: Maybe<IMemberCheckin>;
  deletedMemberCheckinId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberCheckin`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberCheckin`. May be used by Relay 1. */
  memberCheckinEdge?: Maybe<IMemberCheckinsEdge>;
}

/** The output of our delete `MemberCheckin` mutation. */
export interface IDeleteMemberCheckinPayloadMemberCheckinEdgeArgs {
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
}

/** All input for the `deleteMemberEvaluatedRecipeById` mutation. */
export interface IDeleteMemberEvaluatedRecipeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberEvaluatedRecipe` mutation. */
export interface IDeleteMemberEvaluatedRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberEvaluatedRecipe` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberEvaluatedRecipe` mutation. */
export interface IDeleteMemberEvaluatedRecipePayload {
   __typename?: "DeleteMemberEvaluatedRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberEvaluatedRecipe` that was deleted by this mutation. */
  memberEvaluatedRecipe?: Maybe<IMemberEvaluatedRecipe>;
  deletedMemberEvaluatedRecipeId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `MemberEvaluatedRecipe`. */
  foodByFoodId?: Maybe<IFood>;
  /** Reads a single `MemberRecipe` that is related to this `MemberEvaluatedRecipe`. */
  memberRecipeByRecipeId?: Maybe<IMemberRecipe>;
  /** An edge for our `MemberEvaluatedRecipe`. May be used by Relay 1. */
  memberEvaluatedRecipeEdge?: Maybe<IMemberEvaluatedRecipesEdge>;
}

/** The output of our delete `MemberEvaluatedRecipe` mutation. */
export interface IDeleteMemberEvaluatedRecipePayloadMemberEvaluatedRecipeEdgeArgs {
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
}

/** All input for the `deleteMemberFavouriteFoodById` mutation. */
export interface IDeleteMemberFavouriteFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberFavouriteFoodByMemberIdAndFoodId` mutation. */
export interface IDeleteMemberFavouriteFoodByMemberIdAndFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  foodId: Scalars["Int"];
}

/** All input for the `deleteMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryId` mutation. */
export interface IDeleteMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  label: Scalars["String"];
  macrosEntryId: IMacrosEntryIdInput;
}

/** All input for the `deleteMemberFavouriteFoodByMemberIdAndMyFoodId` mutation. */
export interface IDeleteMemberFavouriteFoodByMemberIdAndMyFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

/** All input for the `deleteMemberFavouriteFood` mutation. */
export interface IDeleteMemberFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberFavouriteFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberFavouriteFood` mutation. */
export interface IDeleteMemberFavouriteFoodPayload {
   __typename?: "DeleteMemberFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberFavouriteFood` that was deleted by this mutation. */
  memberFavouriteFood?: Maybe<IMemberFavouriteFood>;
  deletedMemberFavouriteFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberFavouriteFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberFavouriteFood`. May be used by Relay 1. */
  memberFavouriteFoodEdge?: Maybe<IMemberFavouriteFoodsEdge>;
}

/** The output of our delete `MemberFavouriteFood` mutation. */
export interface IDeleteMemberFavouriteFoodPayloadMemberFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IMemberFavouriteFoodsOrderBy[]>;
}

/** All input for the `deleteMember` mutation. */
export interface IDeleteMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Member` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteMemberMealById` mutation. */
export interface IDeleteMemberMealByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberMeal` mutation. */
export interface IDeleteMemberMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMeal` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberMeal` mutation. */
export interface IDeleteMemberMealPayload {
   __typename?: "DeleteMemberMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMeal` that was deleted by this mutation. */
  memberMeal?: Maybe<IMemberMeal>;
  deletedMemberMealId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our delete `MemberMeal` mutation. */
export interface IDeleteMemberMealPayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the `deleteMemberMetricByMemberIdAndDateAndKey` mutation. */
export interface IDeleteMemberMetricByMemberIdAndDateAndKeyInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  key: IMetricKey;
}

/** All input for the `deleteMemberMetric` mutation. */
export interface IDeleteMemberMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMetric` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberMetric` mutation. */
export interface IDeleteMemberMetricPayload {
   __typename?: "DeleteMemberMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMetric` that was deleted by this mutation. */
  memberMetric?: Maybe<IMemberMetric>;
  deletedMemberMetricId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMetric`. May be used by Relay 1. */
  memberMetricEdge?: Maybe<IMemberMetricsEdge>;
}

/** The output of our delete `MemberMetric` mutation. */
export interface IDeleteMemberMetricPayloadMemberMetricEdgeArgs {
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
}

/** All input for the `deleteMemberMetrics` mutation. */
export interface IDeleteMemberMetricsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

/** The output of our `deleteMemberMetrics` mutation. */
export interface IDeleteMemberMetricsPayload {
   __typename?: "DeleteMemberMetricsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteMemberMyFoodById` mutation. */
export interface IDeleteMemberMyFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberMyFood` mutation. */
export interface IDeleteMemberMyFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMyFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberMyFood` mutation. */
export interface IDeleteMemberMyFoodPayload {
   __typename?: "DeleteMemberMyFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMyFood` that was deleted by this mutation. */
  memberMyFood?: Maybe<IMemberMyFood>;
  deletedMemberMyFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMyFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMyFood`. May be used by Relay 1. */
  memberMyFoodEdge?: Maybe<IMemberMyFoodsEdge>;
}

/** The output of our delete `MemberMyFood` mutation. */
export interface IDeleteMemberMyFoodPayloadMemberMyFoodEdgeArgs {
  orderBy?: Maybe<IMemberMyFoodsOrderBy[]>;
}

/** All input for the `deleteMemberNutritionMetricByMemberIdAndDate` mutation. */
export interface IDeleteMemberNutritionMetricByMemberIdAndDateInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

/** All input for the `deleteMemberNutritionMetric` mutation. */
export interface IDeleteMemberNutritionMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberNutritionMetric` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberNutritionMetric` mutation. */
export interface IDeleteMemberNutritionMetricPayload {
   __typename?: "DeleteMemberNutritionMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionMetric` that was deleted by this mutation. */
  memberNutritionMetric?: Maybe<IMemberNutritionMetric>;
  deletedMemberNutritionMetricId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberNutritionMetric`. May be used by Relay 1. */
  memberNutritionMetricEdge?: Maybe<IMemberNutritionMetricsEdge>;
}

/** The output of our delete `MemberNutritionMetric` mutation. */
export interface IDeleteMemberNutritionMetricPayloadMemberNutritionMetricEdgeArgs {
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
}

/** All input for the `deleteMemberNutritionPlanById` mutation. */
export interface IDeleteMemberNutritionPlanByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberNutritionPlan` mutation. */
export interface IDeleteMemberNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberNutritionPlan` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberNutritionPlan` mutation. */
export interface IDeleteMemberNutritionPlanPayload {
   __typename?: "DeleteMemberNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionPlan` that was deleted by this mutation. */
  memberNutritionPlan?: Maybe<IMemberNutritionPlan>;
  deletedMemberNutritionPlanId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionPlan`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `NutritionPlan` that is related to this `MemberNutritionPlan`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `MemberNutritionPlan`. May be used by Relay 1. */
  memberNutritionPlanEdge?: Maybe<IMemberNutritionPlansEdge>;
}

/** The output of our delete `MemberNutritionPlan` mutation. */
export interface IDeleteMemberNutritionPlanPayloadMemberNutritionPlanEdgeArgs {
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
}

/** The output of our delete `Member` mutation. */
export interface IDeleteMemberPayload {
   __typename?: "DeleteMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Member` that was deleted by this mutation. */
  member?: Maybe<IMember>;
  deletedMemberId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<IMembersEdge>;
}

/** The output of our delete `Member` mutation. */
export interface IDeleteMemberPayloadMemberEdgeArgs {
  orderBy?: Maybe<IMembersOrderBy[]>;
}

/** All input for the `deleteMemberRecentFoodById` mutation. */
export interface IDeleteMemberRecentFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberRecentFoodByMemberIdAndFatSecretId` mutation. */
export interface IDeleteMemberRecentFoodByMemberIdAndFatSecretIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  fatSecretId: Scalars["Int"];
}

/** All input for the `deleteMemberRecentFoodByMemberIdAndFoodId` mutation. */
export interface IDeleteMemberRecentFoodByMemberIdAndFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  foodId: Scalars["Uuid"];
}

/** All input for the `deleteMemberRecentFoodByMemberIdAndMacroEntryId` mutation. */
export interface IDeleteMemberRecentFoodByMemberIdAndMacroEntryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  macroEntryId: IMacroEntryIdInput;
}

/** All input for the `deleteMemberRecentFoodByMemberIdAndMyFoodId` mutation. */
export interface IDeleteMemberRecentFoodByMemberIdAndMyFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

/** All input for the `deleteMemberRecentFood` mutation. */
export interface IDeleteMemberRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberRecentFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberRecentFood` mutation. */
export interface IDeleteMemberRecentFoodPayload {
   __typename?: "DeleteMemberRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecentFood` that was deleted by this mutation. */
  memberRecentFood?: Maybe<IMemberRecentFood>;
  deletedMemberRecentFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MemberRecentFood`. May be used by Relay 1. */
  memberRecentFoodEdge?: Maybe<IMemberRecentFoodsEdge>;
}

/** The output of our delete `MemberRecentFood` mutation. */
export interface IDeleteMemberRecentFoodPayloadMemberRecentFoodEdgeArgs {
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
}

/** All input for the `deleteMemberRecipeById` mutation. */
export interface IDeleteMemberRecipeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberRecipe` mutation. */
export interface IDeleteMemberRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberRecipe` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberRecipe` mutation. */
export interface IDeleteMemberRecipePayload {
   __typename?: "DeleteMemberRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecipe` that was deleted by this mutation. */
  memberRecipe?: Maybe<IMemberRecipe>;
  deletedMemberRecipeId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecipe`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `MemberMeal` that is related to this `MemberRecipe`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `MemberRecipe`. May be used by Relay 1. */
  memberRecipeEdge?: Maybe<IMemberRecipesEdge>;
}

/** The output of our delete `MemberRecipe` mutation. */
export interface IDeleteMemberRecipePayloadMemberRecipeEdgeArgs {
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
}

/** All input for the `deleteMemberReminderById` mutation. */
export interface IDeleteMemberReminderByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberReminder` mutation. */
export interface IDeleteMemberReminderInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberReminder` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberReminder` mutation. */
export interface IDeleteMemberReminderPayload {
   __typename?: "DeleteMemberReminderPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberReminder` that was deleted by this mutation. */
  memberReminder?: Maybe<IMemberReminder>;
  deletedMemberReminderId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberReminder`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Coach` that is related to this `MemberReminder`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `MemberReminder`. May be used by Relay 1. */
  memberReminderEdge?: Maybe<IMemberRemindersEdge>;
}

/** The output of our delete `MemberReminder` mutation. */
export interface IDeleteMemberReminderPayloadMemberReminderEdgeArgs {
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
}

/** All input for the `deleteMembers` mutation. */
export interface IDeleteMembersInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberIds: Array<Maybe<Scalars["Int"]>>;
}

/** The output of our `deleteMembers` mutation. */
export interface IDeleteMembersPayload {
   __typename?: "DeleteMembersPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteMemberStepsMetricByMemberIdAndDate` mutation. */
export interface IDeleteMemberStepsMetricByMemberIdAndDateInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

/** All input for the `deleteMemberStepsMetric` mutation. */
export interface IDeleteMemberStepsMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberStepsMetric` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberStepsMetric` mutation. */
export interface IDeleteMemberStepsMetricPayload {
   __typename?: "DeleteMemberStepsMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberStepsMetric` that was deleted by this mutation. */
  memberStepsMetric?: Maybe<IMemberStepsMetric>;
  deletedMemberStepsMetricId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberStepsMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberStepsMetric`. May be used by Relay 1. */
  memberStepsMetricEdge?: Maybe<IMemberStepsMetricsEdge>;
}

/** The output of our delete `MemberStepsMetric` mutation. */
export interface IDeleteMemberStepsMetricPayloadMemberStepsMetricEdgeArgs {
  orderBy?: Maybe<IMemberStepsMetricsOrderBy[]>;
}

/** All input for the `deleteMemberTrainingProgramById` mutation. */
export interface IDeleteMemberTrainingProgramByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberTrainingProgram` mutation. */
export interface IDeleteMemberTrainingProgramInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberTrainingProgram` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberTrainingProgram` mutation. */
export interface IDeleteMemberTrainingProgramPayload {
   __typename?: "DeleteMemberTrainingProgramPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTrainingProgram` that was deleted by this mutation. */
  memberTrainingProgram?: Maybe<IMemberTrainingProgram>;
  deletedMemberTrainingProgramId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberTrainingProgram`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `TrainingProgram` that is related to this `MemberTrainingProgram`. */
  trainingProgramByTrainingProgramId?: Maybe<ITrainingProgram>;
  /** An edge for our `MemberTrainingProgram`. May be used by Relay 1. */
  memberTrainingProgramEdge?: Maybe<IMemberTrainingProgramsEdge>;
}

/** The output of our delete `MemberTrainingProgram` mutation. */
export interface IDeleteMemberTrainingProgramPayloadMemberTrainingProgramEdgeArgs {
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
}

/** All input for the `deleteMemberWaterMetricByDateAndMemberId` mutation. */
export interface IDeleteMemberWaterMetricByDateAndMemberIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  date: Scalars["Date"];
  memberId: Scalars["Int"];
}

/** All input for the `deleteMemberWaterMetricById` mutation. */
export interface IDeleteMemberWaterMetricByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberWaterMetric` mutation. */
export interface IDeleteMemberWaterMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberWaterMetric` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberWaterMetric` mutation. */
export interface IDeleteMemberWaterMetricPayload {
   __typename?: "DeleteMemberWaterMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWaterMetric` that was deleted by this mutation. */
  memberWaterMetric?: Maybe<IMemberWaterMetric>;
  deletedMemberWaterMetricId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWaterMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberWaterMetric`. May be used by Relay 1. */
  memberWaterMetricEdge?: Maybe<IMemberWaterMetricsEdge>;
}

/** The output of our delete `MemberWaterMetric` mutation. */
export interface IDeleteMemberWaterMetricPayloadMemberWaterMetricEdgeArgs {
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
}

/** All input for the `deleteMemberWorkoutById` mutation. */
export interface IDeleteMemberWorkoutByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMemberWorkout` mutation. */
export interface IDeleteMemberWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberWorkout` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MemberWorkout` mutation. */
export interface IDeleteMemberWorkoutPayload {
   __typename?: "DeleteMemberWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWorkout` that was deleted by this mutation. */
  memberWorkout?: Maybe<IMemberWorkout>;
  deletedMemberWorkoutId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `MemberWorkout`. May be used by Relay 1. */
  memberWorkoutEdge?: Maybe<IMemberWorkoutsEdge>;
}

/** The output of our delete `MemberWorkout` mutation. */
export interface IDeleteMemberWorkoutPayloadMemberWorkoutEdgeArgs {
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
}

/** All input for the `deleteMentorEventById` mutation. */
export interface IDeleteMentorEventByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteMentorEvent` mutation. */
export interface IDeleteMentorEventInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentorEvent` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MentorEvent` mutation. */
export interface IDeleteMentorEventPayload {
   __typename?: "DeleteMentorEventPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentorEvent` that was deleted by this mutation. */
  mentorEvent?: Maybe<IMentorEvent>;
  deletedMentorEventId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `MentorEvent`. May be used by Relay 1. */
  mentorEventEdge?: Maybe<IMentorEventsEdge>;
}

/** The output of our delete `MentorEvent` mutation. */
export interface IDeleteMentorEventPayloadMentorEventEdgeArgs {
  orderBy?: Maybe<IMentorEventsOrderBy[]>;
}

/** All input for the `deleteMentoringReportById` mutation. */
export interface IDeleteMentoringReportByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMentoringReportByToken` mutation. */
export interface IDeleteMentoringReportByTokenInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Unique token for member access to report on the member portal */
  token: Scalars["String"];
}

/** All input for the `deleteMentoringReport` mutation. */
export interface IDeleteMentoringReportInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentoringReport` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteMentoringReportMessageById` mutation. */
export interface IDeleteMentoringReportMessageByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteMentoringReportMessage` mutation. */
export interface IDeleteMentoringReportMessageInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentoringReportMessage` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `MentoringReportMessage` mutation. */
export interface IDeleteMentoringReportMessagePayload {
   __typename?: "DeleteMentoringReportMessagePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReportMessage` that was deleted by this mutation. */
  mentoringReportMessage?: Maybe<IMentoringReportMessage>;
  deletedMentoringReportMessageId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MentoringReport` that is related to this `MentoringReportMessage`. */
  mentoringReportByMentoringReportId?: Maybe<IMentoringReport>;
  /** An edge for our `MentoringReportMessage`. May be used by Relay 1. */
  mentoringReportMessageEdge?: Maybe<IMentoringReportMessagesEdge>;
}

/** The output of our delete `MentoringReportMessage` mutation. */
export interface IDeleteMentoringReportMessagePayloadMentoringReportMessageEdgeArgs {
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
}

/** The output of our delete `MentoringReport` mutation. */
export interface IDeleteMentoringReportPayload {
   __typename?: "DeleteMentoringReportPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReport` that was deleted by this mutation. */
  mentoringReport?: Maybe<IMentoringReport>;
  deletedMentoringReportId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Coach` that is related to this `MentoringReport`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads a single `Member` that is related to this `MentoringReport`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MentoringReport`. May be used by Relay 1. */
  mentoringReportEdge?: Maybe<IMentoringReportsEdge>;
}

/** The output of our delete `MentoringReport` mutation. */
export interface IDeleteMentoringReportPayloadMentoringReportEdgeArgs {
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
}

export interface IDeleteMetricByIdInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Measurement ID */
  metricId: Scalars["ID"];
}

export interface IDeleteMetricByIdPayload {
   __typename?: "DeleteMetricByIdPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

/** All input for the `deleteMyRecipe` mutation. */
export interface IDeleteMyRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `deleteMyRecipe` mutation. */
export interface IDeleteMyRecipePayload {
   __typename?: "DeleteMyRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteNotificationById` mutation. */
export interface IDeleteNotificationByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteNotification` mutation. */
export interface IDeleteNotificationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Notification` mutation. */
export interface IDeleteNotificationPayload {
   __typename?: "DeleteNotificationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<INotification>;
  deletedNotificationId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<INotificationsEdge>;
}

/** The output of our delete `Notification` mutation. */
export interface IDeleteNotificationPayloadNotificationEdgeArgs {
  orderBy?: Maybe<INotificationsOrderBy[]>;
}

/** All input for the `deleteNutritionDayById` mutation. */
export interface IDeleteNutritionDayByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteNutritionDay` mutation. */
export interface IDeleteNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDay` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteNutritionDayMealByNutritionDayIdAndMealId` mutation. */
export interface IDeleteNutritionDayMealByNutritionDayIdAndMealIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionDayId: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
}

/** All input for the `deleteNutritionDayMeal` mutation. */
export interface IDeleteNutritionDayMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDayMeal` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionDayMeal` mutation. */
export interface IDeleteNutritionDayMealPayload {
   __typename?: "DeleteNutritionDayMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDayMeal` that was deleted by this mutation. */
  nutritionDayMeal?: Maybe<INutritionDayMeal>;
  deletedNutritionDayMealId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionDayMeal`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `MemberMeal` that is related to this `NutritionDayMeal`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `NutritionDayMeal`. May be used by Relay 1. */
  nutritionDayMealEdge?: Maybe<INutritionDayMealsEdge>;
}

/** The output of our delete `NutritionDayMeal` mutation. */
export interface IDeleteNutritionDayMealPayloadNutritionDayMealEdgeArgs {
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
}

/** The output of our delete `NutritionDay` mutation. */
export interface IDeleteNutritionDayPayload {
   __typename?: "DeleteNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDay` that was deleted by this mutation. */
  nutritionDay?: Maybe<INutritionDay>;
  deletedNutritionDayId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our delete `NutritionDay` mutation. */
export interface IDeleteNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the `deleteNutritionDictionaryById` mutation. */
export interface IDeleteNutritionDictionaryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteNutritionDictionary` mutation. */
export interface IDeleteNutritionDictionaryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDictionary` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionDictionary` mutation. */
export interface IDeleteNutritionDictionaryPayload {
   __typename?: "DeleteNutritionDictionaryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDictionary` that was deleted by this mutation. */
  nutritionDictionary?: Maybe<INutritionDictionary>;
  deletedNutritionDictionaryId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDictionary` that is related to this `NutritionDictionary`. */
  nutritionDictionaryByParentNutritionId?: Maybe<INutritionDictionary>;
  /** An edge for our `NutritionDictionary`. May be used by Relay 1. */
  nutritionDictionaryEdge?: Maybe<INutritionDictionariesEdge>;
}

/** The output of our delete `NutritionDictionary` mutation. */
export interface IDeleteNutritionDictionaryPayloadNutritionDictionaryEdgeArgs {
  orderBy?: Maybe<INutritionDictionariesOrderBy[]>;
}

/** All input for the `deleteNutritionPlanById` mutation. */
export interface IDeleteNutritionPlanByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteNutritionPlanDayByNutritionPlanIdAndNutritionDayId` mutation. */
export interface IDeleteNutritionPlanDayByNutritionPlanIdAndNutritionDayIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlanId: Scalars["Uuid"];
  nutritionDayId: Scalars["Uuid"];
}

/** All input for the `deleteNutritionPlanDay` mutation. */
export interface IDeleteNutritionPlanDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlanDay` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionPlanDay` mutation. */
export interface IDeleteNutritionPlanDayPayload {
   __typename?: "DeleteNutritionPlanDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanDay` that was deleted by this mutation. */
  nutritionPlanDay?: Maybe<INutritionPlanDay>;
  deletedNutritionPlanDayId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanDay`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanDay`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** An edge for our `NutritionPlanDay`. May be used by Relay 1. */
  nutritionPlanDayEdge?: Maybe<INutritionPlanDaysEdge>;
}

/** The output of our delete `NutritionPlanDay` mutation. */
export interface IDeleteNutritionPlanDayPayloadNutritionPlanDayEdgeArgs {
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
}

/** All input for the `deleteNutritionPlan` mutation. */
export interface IDeleteNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlan` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionPlan` mutation. */
export interface IDeleteNutritionPlanPayload {
   __typename?: "DeleteNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlan` that was deleted by this mutation. */
  nutritionPlan?: Maybe<INutritionPlan>;
  deletedNutritionPlanId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `NutritionPlan`. May be used by Relay 1. */
  nutritionPlanEdge?: Maybe<INutritionPlansEdge>;
}

/** The output of our delete `NutritionPlan` mutation. */
export interface IDeleteNutritionPlanPayloadNutritionPlanEdgeArgs {
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
}

/** All input for the `deleteNutritionPlanScheduleByNutritionPlanIdAndOrderIndex` mutation. */
export interface IDeleteNutritionPlanScheduleByNutritionPlanIdAndOrderIndexInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlanId: Scalars["Uuid"];
  orderIndex: Scalars["Int"];
}

/** All input for the `deleteNutritionPlanSchedule` mutation. */
export interface IDeleteNutritionPlanScheduleInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlanSchedule` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionPlanSchedule` mutation. */
export interface IDeleteNutritionPlanSchedulePayload {
   __typename?: "DeleteNutritionPlanSchedulePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanSchedule` that was deleted by this mutation. */
  nutritionPlanSchedule?: Maybe<INutritionPlanSchedule>;
  deletedNutritionPlanScheduleId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanSchedule`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanSchedule`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `NutritionPlanSchedule`. May be used by Relay 1. */
  nutritionPlanScheduleEdge?: Maybe<INutritionPlanSchedulesEdge>;
}

/** The output of our delete `NutritionPlanSchedule` mutation. */
export interface IDeleteNutritionPlanSchedulePayloadNutritionPlanScheduleEdgeArgs {
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
}

/** All input for the `deleteNutritionProfileById` mutation. */
export interface IDeleteNutritionProfileByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteNutritionProfile` mutation. */
export interface IDeleteNutritionProfileInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionProfile` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteNutritionProfileMealById` mutation. */
export interface IDeleteNutritionProfileMealByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteNutritionProfileMeal` mutation. */
export interface IDeleteNutritionProfileMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionProfileMeal` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `NutritionProfileMeal` mutation. */
export interface IDeleteNutritionProfileMealPayload {
   __typename?: "DeleteNutritionProfileMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfileMeal` that was deleted by this mutation. */
  nutritionProfileMeal?: Maybe<INutritionProfileMeal>;
  deletedNutritionProfileMealId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionProfile` that is related to this `NutritionProfileMeal`. */
  nutritionProfileByNutritionProfileId?: Maybe<INutritionProfile>;
  /** An edge for our `NutritionProfileMeal`. May be used by Relay 1. */
  nutritionProfileMealEdge?: Maybe<INutritionProfileMealsEdge>;
}

/** The output of our delete `NutritionProfileMeal` mutation. */
export interface IDeleteNutritionProfileMealPayloadNutritionProfileMealEdgeArgs {
  orderBy?: Maybe<INutritionProfileMealsOrderBy[]>;
}

/** The output of our delete `NutritionProfile` mutation. */
export interface IDeleteNutritionProfilePayload {
   __typename?: "DeleteNutritionProfilePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfile` that was deleted by this mutation. */
  nutritionProfile?: Maybe<INutritionProfile>;
  deletedNutritionProfileId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionProfile`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionProfile`. May be used by Relay 1. */
  nutritionProfileEdge?: Maybe<INutritionProfilesEdge>;
}

/** The output of our delete `NutritionProfile` mutation. */
export interface IDeleteNutritionProfilePayloadNutritionProfileEdgeArgs {
  orderBy?: Maybe<INutritionProfilesOrderBy[]>;
}

/** All input for the `deleteProgramWorkoutByProgramIdAndWorkoutId` mutation. */
export interface IDeleteProgramWorkoutByProgramIdAndWorkoutIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  programId: Scalars["Int"];
  workoutId: Scalars["Uuid"];
}

/** All input for the `deleteProgramWorkout` mutation. */
export interface IDeleteProgramWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ProgramWorkout` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `ProgramWorkout` mutation. */
export interface IDeleteProgramWorkoutPayload {
   __typename?: "DeleteProgramWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ProgramWorkout` that was deleted by this mutation. */
  programWorkout?: Maybe<IProgramWorkout>;
  deletedProgramWorkoutId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `TrainingProgram` that is related to this `ProgramWorkout`. */
  trainingProgramByProgramId?: Maybe<ITrainingProgram>;
  /** Reads a single `Workout` that is related to this `ProgramWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `ProgramWorkout`. May be used by Relay 1. */
  programWorkoutEdge?: Maybe<IProgramWorkoutsEdge>;
}

/** The output of our delete `ProgramWorkout` mutation. */
export interface IDeleteProgramWorkoutPayloadProgramWorkoutEdgeArgs {
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
}

export interface IDeleteProgressPictureInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Picture ID */
  pictureId: Scalars["ID"];
}

export interface IDeleteProgressPicturePayload {
   __typename?: "DeleteProgressPicturePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

/** All input for the `deleteRecentFoodById` mutation. */
export interface IDeleteRecentFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteRecentFood` mutation. */
export interface IDeleteRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `RecentFood` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `RecentFood` mutation. */
export interface IDeleteRecentFoodPayload {
   __typename?: "DeleteRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `RecentFood` that was deleted by this mutation. */
  recentFood?: Maybe<IRecentFood>;
  deletedRecentFoodId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `RecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `RecentFood`. May be used by Relay 1. */
  recentFoodEdge?: Maybe<IRecentFoodsEdge>;
}

/** The output of our delete `RecentFood` mutation. */
export interface IDeleteRecentFoodPayloadRecentFoodEdgeArgs {
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
}

/** All input for the `deleteReservationRequestById` mutation. */
export interface IDeleteReservationRequestByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `deleteReservationRequestById` mutation. */
export interface IDeleteReservationRequestByIdPayload {
   __typename?: "DeleteReservationRequestByIdPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteServingById` mutation. */
export interface IDeleteServingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteServing` mutation. */
export interface IDeleteServingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Serving` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Serving` mutation. */
export interface IDeleteServingPayload {
   __typename?: "DeleteServingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Serving` that was deleted by this mutation. */
  serving?: Maybe<IServing>;
  deletedServingId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Serving`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Serving`. May be used by Relay 1. */
  servingEdge?: Maybe<IServingsEdge>;
}

/** The output of our delete `Serving` mutation. */
export interface IDeleteServingPayloadServingEdgeArgs {
  orderBy?: Maybe<IServingsOrderBy[]>;
}

/** All input for the `deleteSessionById` mutation. */
export interface IDeleteSessionByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteSession` mutation. */
export interface IDeleteSessionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Session` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteSessionInstructorBySessionIdAndInstructorId` mutation. */
export interface IDeleteSessionInstructorBySessionIdAndInstructorIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  sessionId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

/** All input for the `deleteSessionInstructor` mutation. */
export interface IDeleteSessionInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `SessionInstructor` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `SessionInstructor` mutation. */
export interface IDeleteSessionInstructorPayload {
   __typename?: "DeleteSessionInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `SessionInstructor` that was deleted by this mutation. */
  sessionInstructor?: Maybe<ISessionInstructor>;
  deletedSessionInstructorId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `SessionInstructor`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Instructor` that is related to this `SessionInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `SessionInstructor`. May be used by Relay 1. */
  sessionInstructorEdge?: Maybe<ISessionInstructorsEdge>;
}

/** The output of our delete `SessionInstructor` mutation. */
export interface IDeleteSessionInstructorPayloadSessionInstructorEdgeArgs {
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
}

/** The output of our delete `Session` mutation. */
export interface IDeleteSessionPayload {
   __typename?: "DeleteSessionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Session` that was deleted by this mutation. */
  session?: Maybe<ISession>;
  deletedSessionId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<ISessionsEdge>;
}

/** The output of our delete `Session` mutation. */
export interface IDeleteSessionPayloadSessionEdgeArgs {
  orderBy?: Maybe<ISessionsOrderBy[]>;
}

/** All input for the `deleteSettingById` mutation. */
export interface IDeleteSettingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteSettingByKey` mutation. */
export interface IDeleteSettingByKeyInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  key: Scalars["String"];
}

/** All input for the `deleteSetting` mutation. */
export interface IDeleteSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Setting` mutation. */
export interface IDeleteSettingPayload {
   __typename?: "DeleteSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<ISetting>;
  deletedSettingId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<ISettingsEdge>;
}

/** The output of our delete `Setting` mutation. */
export interface IDeleteSettingPayloadSettingEdgeArgs {
  orderBy?: Maybe<ISettingsOrderBy[]>;
}

/** All input for the `deleteTagById` mutation. */
export interface IDeleteTagByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteTagFromMember` mutation. */
export interface IDeleteTagFromMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  tag?: Maybe<Scalars["Int"]>;
  member?: Maybe<Scalars["Int"]>;
}

/** The output of our `deleteTagFromMember` mutation. */
export interface IDeleteTagFromMemberPayload {
   __typename?: "DeleteTagFromMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteTag` mutation. */
export interface IDeleteTagInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Tag` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Tag` mutation. */
export interface IDeleteTagPayload {
   __typename?: "DeleteTagPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Tag` that was deleted by this mutation. */
  tag?: Maybe<ITag>;
  deletedTagId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<ITagsEdge>;
}

/** The output of our delete `Tag` mutation. */
export interface IDeleteTagPayloadTagEdgeArgs {
  orderBy?: Maybe<ITagsOrderBy[]>;
}

/** All input for the `deleteTimeslotById` mutation. */
export interface IDeleteTimeslotByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteTimeslot` mutation. */
export interface IDeleteTimeslotInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Timeslot` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `Timeslot` mutation. */
export interface IDeleteTimeslotPayload {
   __typename?: "DeleteTimeslotPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Timeslot` that was deleted by this mutation. */
  timeslot?: Maybe<ITimeslot>;
  deletedTimeslotId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `Timeslot`. */
  classByClassId?: Maybe<IClass>;
  /** An edge for our `Timeslot`. May be used by Relay 1. */
  timeslotEdge?: Maybe<ITimeslotsEdge>;
}

/** The output of our delete `Timeslot` mutation. */
export interface IDeleteTimeslotPayloadTimeslotEdgeArgs {
  orderBy?: Maybe<ITimeslotsOrderBy[]>;
}

export interface IDeleteTrainingPlanAssignmentsInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingPlanAssignmentIds: Array<Scalars["ID"]>;
}

export interface IDeleteTrainingPlanAssignmentsPayload {
   __typename?: "DeleteTrainingPlanAssignmentsPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IDeleteTrainingPlanInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of training plan to delete */
  trainingPlanId: Scalars["ID"];
}

export interface IDeleteTrainingPlanPayload {
   __typename?: "DeleteTrainingPlanPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** deleted training plan */
  trainingPlan: ITrainingPlan;
}

export interface IDeleteTrainingPlanSharingInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingSharingId: Scalars["ID"];
}

export interface IDeleteTrainingPlanSharingPayload {
   __typename?: "DeleteTrainingPlanSharingPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IDeleteTrainingProgramByIdInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of training program to be deleted */
  id: Scalars["Int"];
}

export interface IDeleteTrainingProgramByIdPayload {
   __typename?: "DeleteTrainingProgramByIdPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** deleted training program */
  trainingProgram: IOldTrainingProgram;
}

/** All input for the `deleteUserSettingById` mutation. */
export interface IDeleteUserSettingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Int"];
}

/** All input for the `deleteUserSetting` mutation. */
export interface IDeleteUserSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `UserSetting` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `UserSetting` mutation. */
export interface IDeleteUserSettingPayload {
   __typename?: "DeleteUserSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `UserSetting` that was deleted by this mutation. */
  userSetting?: Maybe<IUserSetting>;
  deletedUserSettingId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  settingBySettingId?: Maybe<ISetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<IUserSettingsEdge>;
}

/** The output of our delete `UserSetting` mutation. */
export interface IDeleteUserSettingPayloadUserSettingEdgeArgs {
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
}

/** All input for the `deleteUsersFeatures` mutation. */
export interface IDeleteUsersFeaturesInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  userIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
}

/** The output of our `deleteUsersFeatures` mutation. */
export interface IDeleteUsersFeaturesPayload {
   __typename?: "DeleteUsersFeaturesPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `deleteWorkoutById` mutation. */
export interface IDeleteWorkoutByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteWorkoutExerciseByIdAndWorkoutIdAndExerciseId` mutation. */
export interface IDeleteWorkoutExerciseByIdAndWorkoutIdAndExerciseIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
  workoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
}

/** All input for the `deleteWorkoutExercise` mutation. */
export interface IDeleteWorkoutExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutExercise` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `WorkoutExercise` mutation. */
export interface IDeleteWorkoutExercisePayload {
   __typename?: "DeleteWorkoutExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExercise` that was deleted by this mutation. */
  workoutExercise?: Maybe<IWorkoutExercise>;
  deletedWorkoutExerciseId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutExercise`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExercise`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** An edge for our `WorkoutExercise`. May be used by Relay 1. */
  workoutExerciseEdge?: Maybe<IWorkoutExercisesEdge>;
}

/** The output of our delete `WorkoutExercise` mutation. */
export interface IDeleteWorkoutExercisePayloadWorkoutExerciseEdgeArgs {
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
}

/** All input for the `deleteWorkout` mutation. */
export interface IDeleteWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Workout` to be deleted. */
  nodeId: Scalars["ID"];
}

/** All input for the `deleteWorkoutNodeById` mutation. */
export interface IDeleteWorkoutNodeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteWorkoutNodeEventById` mutation. */
export interface IDeleteWorkoutNodeEventByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
}

/** All input for the `deleteWorkoutNodeEvent` mutation. */
export interface IDeleteWorkoutNodeEventInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutNodeEvent` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `WorkoutNodeEvent` mutation. */
export interface IDeleteWorkoutNodeEventPayload {
   __typename?: "DeleteWorkoutNodeEventPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNodeEvent` that was deleted by this mutation. */
  workoutNodeEvent?: Maybe<IWorkoutNodeEvent>;
  deletedWorkoutNodeEventId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutNodeEvent`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Coach` that is related to this `WorkoutNodeEvent`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `WorkoutNodeEvent`. May be used by Relay 1. */
  workoutNodeEventEdge?: Maybe<IWorkoutNodeEventsEdge>;
}

/** The output of our delete `WorkoutNodeEvent` mutation. */
export interface IDeleteWorkoutNodeEventPayloadWorkoutNodeEventEdgeArgs {
  orderBy?: Maybe<IWorkoutNodeEventsOrderBy[]>;
}

/** All input for the `deleteWorkoutNode` mutation. */
export interface IDeleteWorkoutNodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutNode` to be deleted. */
  nodeId: Scalars["ID"];
}

/** The output of our delete `WorkoutNode` mutation. */
export interface IDeleteWorkoutNodePayload {
   __typename?: "DeleteWorkoutNodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNode` that was deleted by this mutation. */
  workoutNode?: Maybe<IWorkoutNode>;
  deletedWorkoutNodeId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `WorkoutNode` that is related to this `WorkoutNode`. */
  workoutNodeByParentId?: Maybe<IWorkoutNode>;
  /** Reads a single `Workout` that is related to this `WorkoutNode`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutNode`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `WorkoutNode`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `WorkoutNode`. May be used by Relay 1. */
  workoutNodeEdge?: Maybe<IWorkoutNodesEdge>;
}

/** The output of our delete `WorkoutNode` mutation. */
export interface IDeleteWorkoutNodePayloadWorkoutNodeEdgeArgs {
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
}

/** The output of our delete `Workout` mutation. */
export interface IDeleteWorkoutPayload {
   __typename?: "DeleteWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Workout` that was deleted by this mutation. */
  workout?: Maybe<IWorkout>;
  deletedWorkoutId?: Maybe<Scalars["ID"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Workout`. May be used by Relay 1. */
  workoutEdge?: Maybe<IWorkoutsEdge>;
}

/** The output of our delete `Workout` mutation. */
export interface IDeleteWorkoutPayloadWorkoutEdgeArgs {
  orderBy?: Maybe<IWorkoutsOrderBy[]>;
}

export interface IDeleteWorkoutSessionInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of workout session to delete */
  workoutId: Scalars["ID"];
}

export interface IDeleteWorkoutSessionPayload {
   __typename?: "DeleteWorkoutSessionPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** deleted workout session */
  workout: IWorkoutSession;
}

export interface IDeleteWorkoutTemplateAssignmentsInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workoutIds: Array<Scalars["ID"]>;
  userIds: Array<Scalars["ID"]>;
}

export interface IDeleteWorkoutTemplateAssignmentsPayload {
   __typename?: "DeleteWorkoutTemplateAssignmentsPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IDeleteWorkoutTemplateDirectoryInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of directory to delete */
  dirId: Scalars["ID"];
}

export interface IDeleteWorkoutTemplateDirectoryPayload {
   __typename?: "DeleteWorkoutTemplateDirectoryPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** deleted workout template directory */
  workoutTemplateDirectory: IWorkoutTemplateDirectory;
}

export interface IDeleteWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workoutTemplateId: Scalars["ID"];
}

export interface IDeleteWorkoutTemplatePayload {
   __typename?: "DeleteWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** deleted workout template */
  workoutTemplate: IWorkoutTemplate;
}

export interface IDeleteWorkoutTemplateSharingInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  templateSharingId: Scalars["ID"];
}

export interface IDeleteWorkoutTemplateSharingPayload {
   __typename?: "DeleteWorkoutTemplateSharingPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

/** All input for the `duplicateMeal` mutation. */
export interface IDuplicateMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  mealId: Scalars["Uuid"];
  dayId: Scalars["Uuid"];
  withSuffix?: Maybe<Scalars["Boolean"]>;
}

/** The output of our `duplicateMeal` mutation. */
export interface IDuplicateMealPayload {
   __typename?: "DuplicateMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberMeal?: Maybe<IMemberMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our `duplicateMeal` mutation. */
export interface IDuplicateMealPayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the `duplicateNutritionDay` mutation. */
export interface IDuplicateNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  dayId: Scalars["Uuid"];
  planId: Scalars["Uuid"];
  withSuffix?: Maybe<Scalars["Boolean"]>;
}

/** The output of our `duplicateNutritionDay` mutation. */
export interface IDuplicateNutritionDayPayload {
   __typename?: "DuplicateNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our `duplicateNutritionDay` mutation. */
export interface IDuplicateNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the `duplicateNutritionPlan` mutation. */
export interface IDuplicateNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  planId: Scalars["Uuid"];
}

/** The output of our `duplicateNutritionPlan` mutation. */
export interface IDuplicateNutritionPlanPayload {
   __typename?: "DuplicateNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlan?: Maybe<INutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `NutritionPlan`. May be used by Relay 1. */
  nutritionPlanEdge?: Maybe<INutritionPlansEdge>;
}

/** The output of our `duplicateNutritionPlan` mutation. */
export interface IDuplicateNutritionPlanPayloadNutritionPlanEdgeArgs {
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
}

export interface IDuplicateProgramByIdInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** program to be cloned */
  programId: Scalars["Int"];
}

export interface IDuplicateProgramByIdPayload {
   __typename?: "DuplicateProgramByIdPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingProgram: IFullOldProgram;
}

export interface IDuplicateWorkoutInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout to be cloned */
  workoutId: Scalars["Uuid"];
  /** recipient program */
  programId: Scalars["Int"];
}

export interface IDuplicateWorkoutPayload {
   __typename?: "DuplicateWorkoutPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workout: IOldWorkout;
}

export interface IExercise  extends INode {
   __typename?: "Exercise";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `WorkoutExercise`. */
  workoutExercisesByExerciseId: IWorkoutExercisesConnection;
  /** Reads and enables pagination through a set of `ExerciseOverride`. */
  exerciseOverridesByExerciseId: IExerciseOverridesConnection;
  /** Reads and enables pagination through a set of `WorkoutNode`. */
  workoutNodesByExerciseId: IWorkoutNodesConnection;
  /** Reads and enables pagination through a set of `WorkoutExerciseAttempt`. */
  workoutExerciseAttemptsByExerciseId: IWorkoutExerciseAttemptsConnection;
  alias?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `WorkoutExerciseAttempt`. */
  attempts: IWorkoutExerciseAttemptsConnection;
  /** Reads and enables pagination through a set of `TopWeight`. */
  topWeights: ITopWeightsConnection;
}

export interface IExerciseWorkoutExercisesByExerciseIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseCondition>;
}

export interface IExerciseExerciseOverridesByExerciseIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
  condition?: Maybe<IExerciseOverrideCondition>;
}

export interface IExerciseWorkoutNodesByExerciseIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
  condition?: Maybe<IWorkoutNodeCondition>;
}

export interface IExerciseWorkoutExerciseAttemptsByExerciseIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExerciseAttemptsOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseAttemptCondition>;
}

export interface IExerciseAttemptsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IExerciseTopWeightsArgs {
  memberId?: Maybe<Scalars["Int"]>;
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IExerciseAttempt {
   __typename?: "ExerciseAttempt";
  id: Scalars["ID"];
  date: Scalars["NaiveDate"];
  exerciseName: Scalars["String"];
  effort?: Maybe<Scalars["String"]>;
  effortValue?: Maybe<Scalars["Float"]>;
  effortUnit?: Maybe<Scalars["String"]>;
  weight?: Maybe<Scalars["String"]>;
  weightValue?: Maybe<Scalars["Float"]>;
  weightUnit?: Maybe<Scalars["String"]>;
  targetEffort?: Maybe<Scalars["String"]>;
  targetEffortValue?: Maybe<Scalars["Float"]>;
  targetEffortUnit?: Maybe<Scalars["String"]>;
  targetWeight?: Maybe<Scalars["String"]>;
  targetWeightValue?: Maybe<Scalars["Float"]>;
  targetWeightUnit?: Maybe<Scalars["String"]>;
}

export interface IExerciseAttemptsConnection {
   __typename?: "ExerciseAttemptsConnection";
  /** List of available training plan slots */
  nodes: IExerciseAttempt[];
  /** Total number of available training plan slots */
  totalCount: Scalars["Int"];
}

/**
 * A condition to be used against `Exercise` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IExerciseCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `meta` field. */
  meta?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `targetMuscle` field. */
  targetMuscle?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `knownAs` field. */
  knownAs?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `equipment` field. */
  equipment?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `alternatives` field. */
  alternatives?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `family` field. */
  family?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `instructions` field. */
  instructions?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `media` field. */
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Exercise` */
export interface IExerciseInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface IExerciseOverride  extends INode {
   __typename?: "ExerciseOverride";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  exerciseId: Scalars["Uuid"];
  workspaceId?: Maybe<Scalars["Int"]>;
  coachId: Scalars["Int"];
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
  /** Reads a single `Exercise` that is related to this `ExerciseOverride`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `ExerciseOverride`. */
  coachByCoachId?: Maybe<ICoach>;
}

/**
 * A condition to be used against `ExerciseOverride` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IExerciseOverrideCondition {
  /** Checks for equality with the object’s `exerciseId` field. */
  exerciseId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `meta` field. */
  meta?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `targetMuscle` field. */
  targetMuscle?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `knownAs` field. */
  knownAs?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `equipment` field. */
  equipment?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `family` field. */
  family?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `instructions` field. */
  instructions?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `alternatives` field. */
  alternatives?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `isArchived` field. */
  isArchived?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `media` field. */
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
}

/** An input for mutations affecting `ExerciseOverride` */
export interface IExerciseOverrideInput {
  exerciseId: Scalars["Uuid"];
  workspaceId?: Maybe<Scalars["Int"]>;
  coachId: Scalars["Int"];
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** Represents an update to a `ExerciseOverride`. Fields that are set will be updated. */
export interface IExerciseOverridePatch {
  exerciseId?: Maybe<Scalars["Uuid"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `ExerciseOverride` values. */
export interface IExerciseOverridesConnection {
   __typename?: "ExerciseOverridesConnection";
  /** A list of `ExerciseOverride` objects. */
  nodes: Array<Maybe<IExerciseOverride>>;
  /** A list of edges which contains the `ExerciseOverride` and cursor to aid in pagination. */
  edges: IExerciseOverridesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ExerciseOverride` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ExerciseOverride` edge in the connection. */
export interface IExerciseOverridesEdge {
   __typename?: "ExerciseOverridesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ExerciseOverride` at the end of the edge. */
  node?: Maybe<IExerciseOverride>;
}

/** Methods to use when ordering `ExerciseOverride`. */
export enum IExerciseOverridesOrderBy {
  Natural = "NATURAL",
  ExerciseIdAsc = "EXERCISE_ID_ASC",
  ExerciseIdDesc = "EXERCISE_ID_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  DescriptionAsc = "DESCRIPTION_ASC",
  DescriptionDesc = "DESCRIPTION_DESC",
  MetaAsc = "META_ASC",
  MetaDesc = "META_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  TargetMuscleAsc = "TARGET_MUSCLE_ASC",
  TargetMuscleDesc = "TARGET_MUSCLE_DESC",
  KnownAsAsc = "KNOWN_AS_ASC",
  KnownAsDesc = "KNOWN_AS_DESC",
  EquipmentAsc = "EQUIPMENT_ASC",
  EquipmentDesc = "EQUIPMENT_DESC",
  FamilyAsc = "FAMILY_ASC",
  FamilyDesc = "FAMILY_DESC",
  InstructionsAsc = "INSTRUCTIONS_ASC",
  InstructionsDesc = "INSTRUCTIONS_DESC",
  AlternativesAsc = "ALTERNATIVES_ASC",
  AlternativesDesc = "ALTERNATIVES_DESC",
  IsArchivedAsc = "IS_ARCHIVED_ASC",
  IsArchivedDesc = "IS_ARCHIVED_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MediaAsc = "MEDIA_ASC",
  MediaDesc = "MEDIA_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `Exercise`. Fields that are set will be updated. */
export interface IExercisePatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  type?: Maybe<Scalars["String"]>;
  targetMuscle?: Maybe<Scalars["String"]>;
  knownAs?: Maybe<Scalars["String"]>;
  equipment?: Maybe<Scalars["String"]>;
  alternatives?: Maybe<Scalars["Json"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  family?: Maybe<Scalars["String"]>;
  instructions?: Maybe<Scalars["String"]>;
  media?: Maybe<Array<Maybe<Scalars["String"]>>>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Exercise` values. */
export interface IExercisesConnection {
   __typename?: "ExercisesConnection";
  /** A list of `Exercise` objects. */
  nodes: Array<Maybe<IExercise>>;
  /** A list of edges which contains the `Exercise` and cursor to aid in pagination. */
  edges: IExercisesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Exercise` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Exercise` edge in the connection. */
export interface IExercisesEdge {
   __typename?: "ExercisesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Exercise` at the end of the edge. */
  node?: Maybe<IExercise>;
}

/** Methods to use when ordering `Exercise`. */
export enum IExercisesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  DescriptionAsc = "DESCRIPTION_ASC",
  DescriptionDesc = "DESCRIPTION_DESC",
  MetaAsc = "META_ASC",
  MetaDesc = "META_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  TargetMuscleAsc = "TARGET_MUSCLE_ASC",
  TargetMuscleDesc = "TARGET_MUSCLE_DESC",
  KnownAsAsc = "KNOWN_AS_ASC",
  KnownAsDesc = "KNOWN_AS_DESC",
  EquipmentAsc = "EQUIPMENT_ASC",
  EquipmentDesc = "EQUIPMENT_DESC",
  AlternativesAsc = "ALTERNATIVES_ASC",
  AlternativesDesc = "ALTERNATIVES_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  FamilyAsc = "FAMILY_ASC",
  FamilyDesc = "FAMILY_DESC",
  InstructionsAsc = "INSTRUCTIONS_ASC",
  InstructionsDesc = "INSTRUCTIONS_DESC",
  MediaAsc = "MEDIA_ASC",
  MediaDesc = "MEDIA_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IFatSecretBarcodeResult {
   __typename?: "FatSecretBarcodeResult";
  id: Scalars["String"];
  foodItem?: Maybe<IFatSecretFoodItem>;
  servings?: Maybe<Array<Maybe<IFatSecretServing>>>;
}

export interface IFatSecretFoodId {
   __typename?: "FatSecretFoodId";
  id: Scalars["String"];
}

export interface IFatSecretFoodItem {
   __typename?: "FatSecretFoodItem";
  foodId: Scalars["String"];
  name: Scalars["String"];
  type: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  brand?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
  servings?: Maybe<Array<Maybe<IFatSecretServing>>>;
}

export interface IFatSecretFoodItemResult {
   __typename?: "FatSecretFoodItemResult";
  foodItem?: Maybe<IFatSecretFoodItem>;
  servings?: Maybe<Array<Maybe<IFatSecretServing>>>;
}

export interface IFatSecretFoodSearchResult {
   __typename?: "FatSecretFoodSearchResult";
  totalCount?: Maybe<Scalars["Int"]>;
  count?: Maybe<Scalars["Int"]>;
  page?: Maybe<Scalars["Int"]>;
  nodes: Array<Maybe<IFatSecretFoodItem>>;
}

export interface IFatSecretServing {
   __typename?: "FatSecretServing";
  id?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
  amount?: Maybe<Scalars["Float"]>;
  unit?: Maybe<Scalars["String"]>;
  numberOfUnits?: Maybe<Scalars["Float"]>;
  measurementDescription?: Maybe<Scalars["String"]>;
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbohydrate?: Maybe<Scalars["Float"]>;
  saturatedFat?: Maybe<Scalars["Float"]>;
  polyunsaturatedFat?: Maybe<Scalars["Float"]>;
  monounsaturatedFat?: Maybe<Scalars["Float"]>;
  transFat?: Maybe<Scalars["Float"]>;
  cholesterol?: Maybe<Scalars["Float"]>;
  sodium?: Maybe<Scalars["Float"]>;
  potassium?: Maybe<Scalars["Float"]>;
  fiber?: Maybe<Scalars["Float"]>;
  sugar?: Maybe<Scalars["Float"]>;
  vitaminA?: Maybe<Scalars["Float"]>;
  vitaminC?: Maybe<Scalars["Float"]>;
  calcium?: Maybe<Scalars["Float"]>;
  iron?: Maybe<Scalars["Float"]>;
}

export interface IFavouriteFood  extends INode {
   __typename?: "FavouriteFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  userId?: Maybe<Scalars["Int"]>;
  createdAt: Scalars["Datetime"];
  ksUserId?: Maybe<Scalars["String"]>;
  /** Reads a single `Food` that is related to this `FavouriteFood`. */
  foodByFoodId?: Maybe<IFood>;
}

/**
 * A condition to be used against `FavouriteFood` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IFavouriteFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `FavouriteFood` */
export interface IFavouriteFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  foodId: Scalars["Uuid"];
  userId?: Maybe<Scalars["Int"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `FavouriteFood`. Fields that are set will be updated. */
export interface IFavouriteFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  userId?: Maybe<Scalars["Int"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `FavouriteFood` values. */
export interface IFavouriteFoodsConnection {
   __typename?: "FavouriteFoodsConnection";
  /** A list of `FavouriteFood` objects. */
  nodes: Array<Maybe<IFavouriteFood>>;
  /** A list of edges which contains the `FavouriteFood` and cursor to aid in pagination. */
  edges: IFavouriteFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `FavouriteFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `FavouriteFood` edge in the connection. */
export interface IFavouriteFoodsEdge {
   __typename?: "FavouriteFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `FavouriteFood` at the end of the edge. */
  node?: Maybe<IFavouriteFood>;
}

/** Methods to use when ordering `FavouriteFood`. */
export enum IFavouriteFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A table for storing all possible features which meant to be available for a subset of all Keystone users. */
export interface IFeature {
   __typename?: "Feature";
  id: Scalars["Uuid"];
  name: Scalars["String"];
  comment: Scalars["String"];
  createdAt: Scalars["Datetime"];
}

/** A connection to a list of `Feature` values. */
export interface IFeaturesConnection {
   __typename?: "FeaturesConnection";
  /** A list of `Feature` objects. */
  nodes: Array<Maybe<IFeature>>;
  /** A list of edges which contains the `Feature` and cursor to aid in pagination. */
  edges: IFeaturesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
}

/** A `Feature` edge in the connection. */
export interface IFeaturesEdge {
   __typename?: "FeaturesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Feature` at the end of the edge. */
  node?: Maybe<IFeature>;
}

export interface IFood  extends INode {
   __typename?: "Food";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  /** Name of food */
  title: Scalars["String"];
  /** Owner of the food (empty if external) */
  memberId?: Maybe<Scalars["Int"]>;
  /** Brand of the food */
  brand?: Maybe<Scalars["String"]>;
  /** Calories in 100 g/ml */
  calories?: Maybe<Scalars["BigFloat"]>;
  /** Protein in 100 g/ml */
  protein?: Maybe<Scalars["BigFloat"]>;
  /** Fat in 100 g/ml */
  fat?: Maybe<Scalars["BigFloat"]>;
  /** Carbs in 100 g/ml */
  carbs?: Maybe<Scalars["BigFloat"]>;
  /** Fibre in 100 g/ml */
  fibre?: Maybe<Scalars["BigFloat"]>;
  /** Alcohol in 100 g/ml */
  alcohol?: Maybe<Scalars["BigFloat"]>;
  /** A list of servings */
  servings: Array<Maybe<IFoodServing>>;
  /** ID from the external provider (FatSecret, MFP). Text because could be any type */
  externalId?: Maybe<Scalars["String"]>;
  /** ID name of the external provider (FatSecret, MFP) */
  provider?: Maybe<IFoodProvider>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  defaultServingIndex: Scalars["Int"];
  /** Saturated fat (grams) in 100 g */
  saturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Polyunsaturated fat (grams) in 100 g */
  polyunsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Monounsaturated fat (grams) in 100 g */
  monounsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Trans fat (grams) in 100 g */
  transFat?: Maybe<Scalars["BigFloat"]>;
  /** Cholesterol (milligrams) in 100 g */
  cholesterol?: Maybe<Scalars["BigFloat"]>;
  /** Sodium (milligrams) in 100 g */
  sodium?: Maybe<Scalars["BigFloat"]>;
  /** Potassium (milligrams) in 100 g */
  potassium?: Maybe<Scalars["BigFloat"]>;
  /** Sugar (grams) in 100 g */
  sugar?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin A in 100 g, based on a 2000 calorie diet */
  vitaminA?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin C in 100 g, based on a 2000 calorie diet */
  vitaminC?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Calcium in 100 g, based on a 2000 calorie diet */
  calcium?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Iron in 100 g, based on a 2000 calorie diet */
  iron?: Maybe<Scalars["BigFloat"]>;
  /** Food provider name in keystone_foodbank */
  origin?: Maybe<Scalars["String"]>;
  /** Reads a single `Member` that is related to this `Food`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads and enables pagination through a set of `MemberRecentFood`. */
  memberRecentFoodsByFoodId: IMemberRecentFoodsConnection;
  /** Reads and enables pagination through a set of `MealItem`. */
  mealItemsByFoodId: IMealItemsConnection;
  /** Reads and enables pagination through a set of `MemberEvaluatedRecipe`. */
  memberEvaluatedRecipesByFoodId: IMemberEvaluatedRecipesConnection;
  /** Reads and enables pagination through a set of `FavouriteFood`. */
  favouriteFoodsByFoodId: IFavouriteFoodsConnection;
  /** Reads and enables pagination through a set of `RecentFood`. */
  recentFoodsByFoodId: IRecentFoodsConnection;
  isMyFood?: Maybe<Scalars["Boolean"]>;
}

export interface IFoodMemberRecentFoodsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
  condition?: Maybe<IMemberRecentFoodCondition>;
}

export interface IFoodMealItemsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMealItemsOrderBy[]>;
  condition?: Maybe<IMealItemCondition>;
}

export interface IFoodMemberEvaluatedRecipesByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
  condition?: Maybe<IMemberEvaluatedRecipeCondition>;
}

export interface IFoodFavouriteFoodsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
  condition?: Maybe<IFavouriteFoodCondition>;
}

export interface IFoodRecentFoodsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
  condition?: Maybe<IRecentFoodCondition>;
}

export interface IFoodbankFood  extends INode {
   __typename?: "FoodbankFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** GTIN code of product (aka barcode number) */
  gtin?: Maybe<Scalars["String"]>;
  brand?: Maybe<Scalars["Uuid"]>;
  countryId?: Maybe<Scalars["Int"]>;
  /** ID of food from Data Lake */
  externalId: Scalars["String"];
  source: Scalars["String"];
  /** Is food available for search or not */
  isHidden: Scalars["Boolean"];
  comment?: Maybe<Scalars["String"]>;
  /** Reads a single `Brand` that is related to this `FoodbankFood`. */
  brandByBrand?: Maybe<IBrand>;
  /** Reads a single `Country` that is related to this `FoodbankFood`. */
  countryByCountryId?: Maybe<ICountry>;
  /** Reads a single `DataSource` that is related to this `FoodbankFood`. */
  dataSourceBySource?: Maybe<IDataSource>;
  /** Reads a single `FoodbankNutritionFact` that is related to this `FoodbankFood`. */
  foodbankNutritionFactByFoodId?: Maybe<IFoodbankNutritionFact>;
  /** Reads and enables pagination through a set of `FoodbankNutritionFact`. */
  foodbankNutritionFactsByFoodId: IFoodbankNutritionFactsConnection;
  /** Reads and enables pagination through a set of `Serving`. */
  servingsByFoodId: IServingsConnection;
  /** Reads a single `Composition` that is related to this `FoodbankFood`. */
  compositionByFoodId?: Maybe<IComposition>;
  /** Reads and enables pagination through a set of `Composition`. */
  compositionsByFoodId: ICompositionsConnection;
  /** Reads and enables pagination through a set of `FoodCategory`. */
  foodCategoriesByFoodId: IFoodCategoriesConnection;
  /** Reads and enables pagination through a set of `Gtin`. */
  gtinsByFoodId: IGtinsConnection;
}

export interface IFoodbankFoodFoodbankNutritionFactsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankNutritionFactsOrderBy[]>;
  condition?: Maybe<IFoodbankNutritionFactCondition>;
}

export interface IFoodbankFoodServingsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IServingsOrderBy[]>;
  condition?: Maybe<IServingCondition>;
}

export interface IFoodbankFoodCompositionsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICompositionsOrderBy[]>;
  condition?: Maybe<ICompositionCondition>;
}

export interface IFoodbankFoodFoodCategoriesByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
  condition?: Maybe<IFoodCategoryCondition>;
}

export interface IFoodbankFoodGtinsByFoodIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IGtinsOrderBy[]>;
  condition?: Maybe<IGtinCondition>;
}

/**
 * A condition to be used against `FoodbankFood` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IFoodbankFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `alternativeNames` field. */
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `gtin` field. */
  gtin?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `brand` field. */
  brand?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isHidden` field. */
  isHidden?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `FoodbankFood` */
export interface IFoodbankFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** GTIN code of product (aka barcode number) */
  gtin?: Maybe<Scalars["String"]>;
  brand?: Maybe<Scalars["Uuid"]>;
  countryId?: Maybe<Scalars["Int"]>;
  /** ID of food from Data Lake */
  externalId: Scalars["String"];
  source: Scalars["String"];
  /** Is food available for search or not */
  isHidden?: Maybe<Scalars["Boolean"]>;
  comment?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `FoodbankFood`. Fields that are set will be updated. */
export interface IFoodbankFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** GTIN code of product (aka barcode number) */
  gtin?: Maybe<Scalars["String"]>;
  brand?: Maybe<Scalars["Uuid"]>;
  countryId?: Maybe<Scalars["Int"]>;
  /** ID of food from Data Lake */
  externalId?: Maybe<Scalars["String"]>;
  source?: Maybe<Scalars["String"]>;
  /** Is food available for search or not */
  isHidden?: Maybe<Scalars["Boolean"]>;
  comment?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `FoodbankFood` values. */
export interface IFoodbankFoodsConnection {
   __typename?: "FoodbankFoodsConnection";
  /** A list of `FoodbankFood` objects. */
  nodes: Array<Maybe<IFoodbankFood>>;
  /** A list of edges which contains the `FoodbankFood` and cursor to aid in pagination. */
  edges: IFoodbankFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `FoodbankFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `FoodbankFood` edge in the connection. */
export interface IFoodbankFoodsEdge {
   __typename?: "FoodbankFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `FoodbankFood` at the end of the edge. */
  node?: Maybe<IFoodbankFood>;
}

/** Methods to use when ordering `FoodbankFood`. */
export enum IFoodbankFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  AlternativeNamesAsc = "ALTERNATIVE_NAMES_ASC",
  AlternativeNamesDesc = "ALTERNATIVE_NAMES_DESC",
  GtinAsc = "GTIN_ASC",
  GtinDesc = "GTIN_DESC",
  BrandAsc = "BRAND_ASC",
  BrandDesc = "BRAND_DESC",
  CountryIdAsc = "COUNTRY_ID_ASC",
  CountryIdDesc = "COUNTRY_ID_DESC",
  ExternalIdAsc = "EXTERNAL_ID_ASC",
  ExternalIdDesc = "EXTERNAL_ID_DESC",
  SourceAsc = "SOURCE_ASC",
  SourceDesc = "SOURCE_DESC",
  IsHiddenAsc = "IS_HIDDEN_ASC",
  IsHiddenDesc = "IS_HIDDEN_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IFoodbankNutritionFact  extends INode {
   __typename?: "FoodbankNutritionFact";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  foodId: Scalars["Uuid"];
  p1?: Maybe<Scalars["Float"]>;
  p2?: Maybe<Scalars["Float"]>;
  p3?: Maybe<Scalars["Float"]>;
  p4?: Maybe<Scalars["Float"]>;
  p5?: Maybe<Scalars["Float"]>;
  p6?: Maybe<Scalars["Float"]>;
  p7?: Maybe<Scalars["Float"]>;
  p8?: Maybe<Scalars["Float"]>;
  p9?: Maybe<Scalars["Float"]>;
  p10?: Maybe<Scalars["Float"]>;
  p11?: Maybe<Scalars["Float"]>;
  p12?: Maybe<Scalars["Float"]>;
  p13?: Maybe<Scalars["Float"]>;
  p14?: Maybe<Scalars["Float"]>;
  p15?: Maybe<Scalars["Float"]>;
  p16?: Maybe<Scalars["Float"]>;
  p17?: Maybe<Scalars["Float"]>;
  p18?: Maybe<Scalars["Float"]>;
  p19?: Maybe<Scalars["Float"]>;
  p20?: Maybe<Scalars["Float"]>;
  /** Reads a single `FoodbankFood` that is related to this `FoodbankNutritionFact`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
}

/**
 * A condition to be used against `FoodbankNutritionFact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IFoodbankNutritionFactCondition {
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `p1` field. */
  p1?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p2` field. */
  p2?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p3` field. */
  p3?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p4` field. */
  p4?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p5` field. */
  p5?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p6` field. */
  p6?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p7` field. */
  p7?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p8` field. */
  p8?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p9` field. */
  p9?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p10` field. */
  p10?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p11` field. */
  p11?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p12` field. */
  p12?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p13` field. */
  p13?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p14` field. */
  p14?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p15` field. */
  p15?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p16` field. */
  p16?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p17` field. */
  p17?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p18` field. */
  p18?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p19` field. */
  p19?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `p20` field. */
  p20?: Maybe<Scalars["Float"]>;
}

/** An input for mutations affecting `FoodbankNutritionFact` */
export interface IFoodbankNutritionFactInput {
  foodId: Scalars["Uuid"];
  p1?: Maybe<Scalars["Float"]>;
  p2?: Maybe<Scalars["Float"]>;
  p3?: Maybe<Scalars["Float"]>;
  p4?: Maybe<Scalars["Float"]>;
  p5?: Maybe<Scalars["Float"]>;
  p6?: Maybe<Scalars["Float"]>;
  p7?: Maybe<Scalars["Float"]>;
  p8?: Maybe<Scalars["Float"]>;
  p9?: Maybe<Scalars["Float"]>;
  p10?: Maybe<Scalars["Float"]>;
  p11?: Maybe<Scalars["Float"]>;
  p12?: Maybe<Scalars["Float"]>;
  p13?: Maybe<Scalars["Float"]>;
  p14?: Maybe<Scalars["Float"]>;
  p15?: Maybe<Scalars["Float"]>;
  p16?: Maybe<Scalars["Float"]>;
  p17?: Maybe<Scalars["Float"]>;
  p18?: Maybe<Scalars["Float"]>;
  p19?: Maybe<Scalars["Float"]>;
  p20?: Maybe<Scalars["Float"]>;
}

/** Represents an update to a `FoodbankNutritionFact`. Fields that are set will be updated. */
export interface IFoodbankNutritionFactPatch {
  foodId?: Maybe<Scalars["Uuid"]>;
  p1?: Maybe<Scalars["Float"]>;
  p2?: Maybe<Scalars["Float"]>;
  p3?: Maybe<Scalars["Float"]>;
  p4?: Maybe<Scalars["Float"]>;
  p5?: Maybe<Scalars["Float"]>;
  p6?: Maybe<Scalars["Float"]>;
  p7?: Maybe<Scalars["Float"]>;
  p8?: Maybe<Scalars["Float"]>;
  p9?: Maybe<Scalars["Float"]>;
  p10?: Maybe<Scalars["Float"]>;
  p11?: Maybe<Scalars["Float"]>;
  p12?: Maybe<Scalars["Float"]>;
  p13?: Maybe<Scalars["Float"]>;
  p14?: Maybe<Scalars["Float"]>;
  p15?: Maybe<Scalars["Float"]>;
  p16?: Maybe<Scalars["Float"]>;
  p17?: Maybe<Scalars["Float"]>;
  p18?: Maybe<Scalars["Float"]>;
  p19?: Maybe<Scalars["Float"]>;
  p20?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `FoodbankNutritionFact` values. */
export interface IFoodbankNutritionFactsConnection {
   __typename?: "FoodbankNutritionFactsConnection";
  /** A list of `FoodbankNutritionFact` objects. */
  nodes: Array<Maybe<IFoodbankNutritionFact>>;
  /** A list of edges which contains the `FoodbankNutritionFact` and cursor to aid in pagination. */
  edges: IFoodbankNutritionFactsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `FoodbankNutritionFact` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `FoodbankNutritionFact` edge in the connection. */
export interface IFoodbankNutritionFactsEdge {
   __typename?: "FoodbankNutritionFactsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `FoodbankNutritionFact` at the end of the edge. */
  node?: Maybe<IFoodbankNutritionFact>;
}

/** Methods to use when ordering `FoodbankNutritionFact`. */
export enum IFoodbankNutritionFactsOrderBy {
  Natural = "NATURAL",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  P1Asc = "P1_ASC",
  P1Desc = "P1_DESC",
  P2Asc = "P2_ASC",
  P2Desc = "P2_DESC",
  P3Asc = "P3_ASC",
  P3Desc = "P3_DESC",
  P4Asc = "P4_ASC",
  P4Desc = "P4_DESC",
  P5Asc = "P5_ASC",
  P5Desc = "P5_DESC",
  P6Asc = "P6_ASC",
  P6Desc = "P6_DESC",
  P7Asc = "P7_ASC",
  P7Desc = "P7_DESC",
  P8Asc = "P8_ASC",
  P8Desc = "P8_DESC",
  P9Asc = "P9_ASC",
  P9Desc = "P9_DESC",
  P10Asc = "P10_ASC",
  P10Desc = "P10_DESC",
  P11Asc = "P11_ASC",
  P11Desc = "P11_DESC",
  P12Asc = "P12_ASC",
  P12Desc = "P12_DESC",
  P13Asc = "P13_ASC",
  P13Desc = "P13_DESC",
  P14Asc = "P14_ASC",
  P14Desc = "P14_DESC",
  P15Asc = "P15_ASC",
  P15Desc = "P15_DESC",
  P16Asc = "P16_ASC",
  P16Desc = "P16_DESC",
  P17Asc = "P17_ASC",
  P17Desc = "P17_DESC",
  P18Asc = "P18_ASC",
  P18Desc = "P18_DESC",
  P19Asc = "P19_ASC",
  P19Desc = "P19_DESC",
  P20Asc = "P20_ASC",
  P20Desc = "P20_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A connection to a list of `FoodCategory` values. */
export interface IFoodCategoriesConnection {
   __typename?: "FoodCategoriesConnection";
  /** A list of `FoodCategory` objects. */
  nodes: Array<Maybe<IFoodCategory>>;
  /** A list of edges which contains the `FoodCategory` and cursor to aid in pagination. */
  edges: IFoodCategoriesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `FoodCategory` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `FoodCategory` edge in the connection. */
export interface IFoodCategoriesEdge {
   __typename?: "FoodCategoriesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `FoodCategory` at the end of the edge. */
  node?: Maybe<IFoodCategory>;
}

/** Methods to use when ordering `FoodCategory`. */
export enum IFoodCategoriesOrderBy {
  Natural = "NATURAL",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  CategoryIdAsc = "CATEGORY_ID_ASC",
  CategoryIdDesc = "CATEGORY_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Category of specific food */
export interface IFoodCategory  extends INode {
   __typename?: "FoodCategory";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  foodId: Scalars["Uuid"];
  categoryId: Scalars["Int"];
  /** Reads a single `FoodbankFood` that is related to this `FoodCategory`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** Reads a single `Category` that is related to this `FoodCategory`. */
  categoryByCategoryId?: Maybe<ICategory>;
}

/**
 * A condition to be used against `FoodCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IFoodCategoryCondition {
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars["Int"]>;
}

/** An input for mutations affecting `FoodCategory` */
export interface IFoodCategoryInput {
  foodId: Scalars["Uuid"];
  categoryId: Scalars["Int"];
}

/** Represents an update to a `FoodCategory`. Fields that are set will be updated. */
export interface IFoodCategoryPatch {
  foodId?: Maybe<Scalars["Uuid"]>;
  categoryId?: Maybe<Scalars["Int"]>;
}

/** A condition to be used against `Food` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `brand` field. */
  brand?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `calories` field. */
  calories?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `protein` field. */
  protein?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `fat` field. */
  fat?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `carbs` field. */
  carbs?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `fibre` field. */
  fibre?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `alcohol` field. */
  alcohol?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `servings` field. */
  servings?: Maybe<Array<Maybe<IFoodServingInput>>>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `provider` field. */
  provider?: Maybe<IFoodProvider>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `defaultServingIndex` field. */
  defaultServingIndex?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `saturatedFat` field. */
  saturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `polyunsaturatedFat` field. */
  polyunsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `monounsaturatedFat` field. */
  monounsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `transFat` field. */
  transFat?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `cholesterol` field. */
  cholesterol?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `sodium` field. */
  sodium?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `potassium` field. */
  potassium?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `sugar` field. */
  sugar?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `vitaminA` field. */
  vitaminA?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `vitaminC` field. */
  vitaminC?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `calcium` field. */
  calcium?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `iron` field. */
  iron?: Maybe<Scalars["BigFloat"]>;
  /** Checks for equality with the object’s `origin` field. */
  origin?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Food` */
export interface IFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  /** Name of food */
  title: Scalars["String"];
  /** Owner of the food (empty if external) */
  memberId?: Maybe<Scalars["Int"]>;
  /** Brand of the food */
  brand?: Maybe<Scalars["String"]>;
  /** Calories in 100 g/ml */
  calories?: Maybe<Scalars["BigFloat"]>;
  /** Protein in 100 g/ml */
  protein?: Maybe<Scalars["BigFloat"]>;
  /** Fat in 100 g/ml */
  fat?: Maybe<Scalars["BigFloat"]>;
  /** Carbs in 100 g/ml */
  carbs?: Maybe<Scalars["BigFloat"]>;
  /** Fibre in 100 g/ml */
  fibre?: Maybe<Scalars["BigFloat"]>;
  /** Alcohol in 100 g/ml */
  alcohol?: Maybe<Scalars["BigFloat"]>;
  /** A list of servings */
  servings: Array<Maybe<IFoodServingInput>>;
  /** ID from the external provider (FatSecret, MFP). Text because could be any type */
  externalId?: Maybe<Scalars["String"]>;
  /** ID name of the external provider (FatSecret, MFP) */
  provider?: Maybe<IFoodProvider>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  defaultServingIndex?: Maybe<Scalars["Int"]>;
  /** Saturated fat (grams) in 100 g */
  saturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Polyunsaturated fat (grams) in 100 g */
  polyunsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Monounsaturated fat (grams) in 100 g */
  monounsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Trans fat (grams) in 100 g */
  transFat?: Maybe<Scalars["BigFloat"]>;
  /** Cholesterol (milligrams) in 100 g */
  cholesterol?: Maybe<Scalars["BigFloat"]>;
  /** Sodium (milligrams) in 100 g */
  sodium?: Maybe<Scalars["BigFloat"]>;
  /** Potassium (milligrams) in 100 g */
  potassium?: Maybe<Scalars["BigFloat"]>;
  /** Sugar (grams) in 100 g */
  sugar?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin A in 100 g, based on a 2000 calorie diet */
  vitaminA?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin C in 100 g, based on a 2000 calorie diet */
  vitaminC?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Calcium in 100 g, based on a 2000 calorie diet */
  calcium?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Iron in 100 g, based on a 2000 calorie diet */
  iron?: Maybe<Scalars["BigFloat"]>;
  /** Food provider name in keystone_foodbank */
  origin?: Maybe<Scalars["String"]>;
}

export interface IFoodItemInput {
  region?: Maybe<Scalars["String"]>;
  language?: Maybe<Scalars["String"]>;
}

export interface IFoodJournalDate {
   __typename?: "FoodJournalDate";
  date: Scalars["NaiveDate"];
  target?: Maybe<IFoodJournalUserTarget>;
  journal?: Maybe<IFoodJournalDay>;
}

export interface IFoodJournalDay {
   __typename?: "FoodJournalDay";
  id: Scalars["ID"];
  date: Scalars["NaiveDate"];
  protein: Scalars["Float"];
  fat: Scalars["Float"];
  carbs: Scalars["Float"];
  vegetables: Scalars["Float"];
  water: Scalars["Int"];
  meals: IFoodJournalMealsConnection;
  isApproved?: Maybe<Scalars["Boolean"]>;
  coachNotes?: Maybe<Scalars["String"]>;
}

export interface IFoodJournalDayTargetTemplate {
   __typename?: "FoodJournalDayTargetTemplate";
  id: Scalars["ID"];
  name: Scalars["String"];
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  vegetables?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Int"]>;
  mealsNum?: Maybe<Scalars["Int"]>;
  meals: IFoodJournalMealTargetsConnection;
}

export interface IFoodJournalDayTargetTemplatesConnection {
   __typename?: "FoodJournalDayTargetTemplatesConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalDayTargetTemplate[];
}

export interface IFoodJournalFood {
   __typename?: "FoodJournalFood";
  id: Scalars["ID"];
  name: Scalars["String"];
  sources: IFoodJournalFoodSource[];
  description?: Maybe<Scalars["String"]>;
  pic?: Maybe<Scalars["String"]>;
}

export interface IFoodJournalFoodConnection {
   __typename?: "FoodJournalFoodConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalFood[];
}

export enum IFoodJournalFoodSource {
  Protein = "PROTEIN",
  Fat = "FAT",
  Carbs = "CARBS",
  Vegetables = "VEGETABLES",
}

export interface IFoodJournalMeal {
   __typename?: "FoodJournalMeal";
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  orderIndex: Scalars["Int"];
  protein: Scalars["Float"];
  fat: Scalars["Float"];
  carbs: Scalars["Float"];
  vegetables: Scalars["Float"];
  food: IFoodJournalMealFoodConnection;
  images: IFoodJournalMealImagesConnection;
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
}

export interface IFoodJournalMealFood {
   __typename?: "FoodJournalMealFood";
  food: IFoodJournalFood;
  portions: Scalars["Float"];
}

export interface IFoodJournalMealFoodConnection {
   __typename?: "FoodJournalMealFoodConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalMealFood[];
}

export interface IFoodJournalMealFoodInput {
  /** ID of food added to meal */
  id: Scalars["ID"];
  /** Number of portions added to meal */
  portions: Scalars["Float"];
}

export interface IFoodJournalMealImage {
   __typename?: "FoodJournalMealImage";
  id: Scalars["ID"];
  previewLink?: Maybe<Scalars["String"]>;
  originalLink?: Maybe<Scalars["String"]>;
  localPath?: Maybe<Scalars["String"]>;
  isApproved?: Maybe<Scalars["Boolean"]>;
  coachNotes?: Maybe<Scalars["String"]>;
  createdAt: Scalars["NaiveDateTime"];
}

export interface IFoodJournalMealImagesConnection {
   __typename?: "FoodJournalMealImagesConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalMealImage[];
}

export interface IFoodJournalMealInput {
  /** Date of meal */
  date: Scalars["NaiveDate"];
  /** Order in the list of meals */
  orderIndex: Scalars["Int"];
  /** Name of the meal */
  name?: Maybe<Scalars["String"]>;
  /** List of food added to meal */
  food: IFoodJournalMealFoodInput[];
}

export interface IFoodJournalMealsConnection {
   __typename?: "FoodJournalMealsConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalMeal[];
}

export interface IFoodJournalMealTarget {
   __typename?: "FoodJournalMealTarget";
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  vegetables?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Int"]>;
}

export interface IFoodJournalMealTargetsConnection {
   __typename?: "FoodJournalMealTargetsConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalMealTarget[];
}

export interface IFoodJournalPreviewDate {
   __typename?: "FoodJournalPreviewDate";
  date: Scalars["NaiveDate"];
  target?: Maybe<IFoodJournalUserTarget>;
  data?: Maybe<IFoodJournalPreviewDay>;
}

export interface IFoodJournalPreviewDatesConnection {
   __typename?: "FoodJournalPreviewDatesConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalPreviewDate[];
}

export interface IFoodJournalPreviewDay {
   __typename?: "FoodJournalPreviewDay";
  id: Scalars["ID"];
  date: Scalars["NaiveDate"];
  protein: Scalars["Float"];
  fat: Scalars["Float"];
  carbs: Scalars["Float"];
  vegetables: Scalars["Float"];
  water: Scalars["Int"];
  meals: IFoodJournalPreviewMealsConnection;
  isApproved?: Maybe<Scalars["Boolean"]>;
  coachNotes?: Maybe<Scalars["String"]>;
}

export interface IFoodJournalPreviewMeal {
   __typename?: "FoodJournalPreviewMeal";
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  orderIndex: Scalars["Int"];
  protein: Scalars["Float"];
  fat: Scalars["Float"];
  carbs: Scalars["Float"];
  vegetables: Scalars["Float"];
  image?: Maybe<IFoodJournalMealImage>;
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
}

export interface IFoodJournalPreviewMealsConnection {
   __typename?: "FoodJournalPreviewMealsConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalPreviewMeal[];
}

export interface IFoodJournalUserTarget {
   __typename?: "FoodJournalUserTarget";
  id: Scalars["ID"];
  templateId?: Maybe<Scalars["ID"]>;
  authorId: Scalars["ID"];
  userId: Scalars["ID"];
  startDate: Scalars["NaiveDate"];
  endDate?: Maybe<Scalars["NaiveDate"]>;
  daysOfWeek: IWeekday[];
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  vegetables?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Int"]>;
  mealsNum?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["NaiveDateTime"]>;
  createdAt: Scalars["NaiveDateTime"];
}

export interface IFoodJournalUserTargetsConnection {
   __typename?: "FoodJournalUserTargetsConnection";
  totalCount: Scalars["Int"];
  nodes: IFoodJournalUserTarget[];
}

/** Represents an update to a `Food`. Fields that are set will be updated. */
export interface IFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  /** Name of food */
  title?: Maybe<Scalars["String"]>;
  /** Owner of the food (empty if external) */
  memberId?: Maybe<Scalars["Int"]>;
  /** Brand of the food */
  brand?: Maybe<Scalars["String"]>;
  /** Calories in 100 g/ml */
  calories?: Maybe<Scalars["BigFloat"]>;
  /** Protein in 100 g/ml */
  protein?: Maybe<Scalars["BigFloat"]>;
  /** Fat in 100 g/ml */
  fat?: Maybe<Scalars["BigFloat"]>;
  /** Carbs in 100 g/ml */
  carbs?: Maybe<Scalars["BigFloat"]>;
  /** Fibre in 100 g/ml */
  fibre?: Maybe<Scalars["BigFloat"]>;
  /** Alcohol in 100 g/ml */
  alcohol?: Maybe<Scalars["BigFloat"]>;
  /** A list of servings */
  servings?: Maybe<Array<Maybe<IFoodServingInput>>>;
  /** ID from the external provider (FatSecret, MFP). Text because could be any type */
  externalId?: Maybe<Scalars["String"]>;
  /** ID name of the external provider (FatSecret, MFP) */
  provider?: Maybe<IFoodProvider>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  defaultServingIndex?: Maybe<Scalars["Int"]>;
  /** Saturated fat (grams) in 100 g */
  saturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Polyunsaturated fat (grams) in 100 g */
  polyunsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Monounsaturated fat (grams) in 100 g */
  monounsaturatedFat?: Maybe<Scalars["BigFloat"]>;
  /** Trans fat (grams) in 100 g */
  transFat?: Maybe<Scalars["BigFloat"]>;
  /** Cholesterol (milligrams) in 100 g */
  cholesterol?: Maybe<Scalars["BigFloat"]>;
  /** Sodium (milligrams) in 100 g */
  sodium?: Maybe<Scalars["BigFloat"]>;
  /** Potassium (milligrams) in 100 g */
  potassium?: Maybe<Scalars["BigFloat"]>;
  /** Sugar (grams) in 100 g */
  sugar?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin A in 100 g, based on a 2000 calorie diet */
  vitaminA?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Vitamin C in 100 g, based on a 2000 calorie diet */
  vitaminC?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Calcium in 100 g, based on a 2000 calorie diet */
  calcium?: Maybe<Scalars["BigFloat"]>;
  /** Percentage of daily recommended Iron in 100 g, based on a 2000 calorie diet */
  iron?: Maybe<Scalars["BigFloat"]>;
  /** Food provider name in keystone_foodbank */
  origin?: Maybe<Scalars["String"]>;
}

export enum IFoodProvider {
  Fs = "FS",
  Macro = "MACRO",
  OldMyFood = "OLD_MY_FOOD",
  Ks = "KS",
}

export interface IFoodRequest {
   __typename?: "FoodRequest";
  id: Scalars["ID"];
  frontUrl: Scalars["String"];
  factsUrl: Scalars["String"];
  gtin: Scalars["String"];
  userId: Scalars["Uuid"];
  isApproved: Scalars["Boolean"];
  isProcessed: Scalars["Boolean"];
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
  user?: Maybe<IUser>;
}

/** A connection to a list of `Food` values. */
export interface IFoodsConnection {
   __typename?: "FoodsConnection";
  /** A list of `Food` objects. */
  nodes: Array<Maybe<IFood>>;
  /** A list of edges which contains the `Food` and cursor to aid in pagination. */
  edges: IFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Food` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Food` edge in the connection. */
export interface IFoodsEdge {
   __typename?: "FoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Food` at the end of the edge. */
  node?: Maybe<IFood>;
}

export interface IFoodServing {
   __typename?: "FoodServing";
  num?: Maybe<Scalars["BigFloat"]>;
  name?: Maybe<Scalars["String"]>;
  volume?: Maybe<Scalars["BigFloat"]>;
  unit?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `FoodServing` */
export interface IFoodServingInput {
  num?: Maybe<Scalars["BigFloat"]>;
  name?: Maybe<Scalars["String"]>;
  volume?: Maybe<Scalars["BigFloat"]>;
  unit?: Maybe<Scalars["String"]>;
}

/** Methods to use when ordering `Food`. */
export enum IFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TitleAsc = "TITLE_ASC",
  TitleDesc = "TITLE_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  BrandAsc = "BRAND_ASC",
  BrandDesc = "BRAND_DESC",
  CaloriesAsc = "CALORIES_ASC",
  CaloriesDesc = "CALORIES_DESC",
  ProteinAsc = "PROTEIN_ASC",
  ProteinDesc = "PROTEIN_DESC",
  FatAsc = "FAT_ASC",
  FatDesc = "FAT_DESC",
  CarbsAsc = "CARBS_ASC",
  CarbsDesc = "CARBS_DESC",
  FibreAsc = "FIBRE_ASC",
  FibreDesc = "FIBRE_DESC",
  AlcoholAsc = "ALCOHOL_ASC",
  AlcoholDesc = "ALCOHOL_DESC",
  ServingsAsc = "SERVINGS_ASC",
  ServingsDesc = "SERVINGS_DESC",
  ExternalIdAsc = "EXTERNAL_ID_ASC",
  ExternalIdDesc = "EXTERNAL_ID_DESC",
  ProviderAsc = "PROVIDER_ASC",
  ProviderDesc = "PROVIDER_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  DefaultServingIndexAsc = "DEFAULT_SERVING_INDEX_ASC",
  DefaultServingIndexDesc = "DEFAULT_SERVING_INDEX_DESC",
  SaturatedFatAsc = "SATURATED_FAT_ASC",
  SaturatedFatDesc = "SATURATED_FAT_DESC",
  PolyunsaturatedFatAsc = "POLYUNSATURATED_FAT_ASC",
  PolyunsaturatedFatDesc = "POLYUNSATURATED_FAT_DESC",
  MonounsaturatedFatAsc = "MONOUNSATURATED_FAT_ASC",
  MonounsaturatedFatDesc = "MONOUNSATURATED_FAT_DESC",
  TransFatAsc = "TRANS_FAT_ASC",
  TransFatDesc = "TRANS_FAT_DESC",
  CholesterolAsc = "CHOLESTEROL_ASC",
  CholesterolDesc = "CHOLESTEROL_DESC",
  SodiumAsc = "SODIUM_ASC",
  SodiumDesc = "SODIUM_DESC",
  PotassiumAsc = "POTASSIUM_ASC",
  PotassiumDesc = "POTASSIUM_DESC",
  SugarAsc = "SUGAR_ASC",
  SugarDesc = "SUGAR_DESC",
  VitaminAAsc = "VITAMIN_A_ASC",
  VitaminADesc = "VITAMIN_A_DESC",
  VitaminCAsc = "VITAMIN_C_ASC",
  VitaminCDesc = "VITAMIN_C_DESC",
  CalciumAsc = "CALCIUM_ASC",
  CalciumDesc = "CALCIUM_DESC",
  IronAsc = "IRON_ASC",
  IronDesc = "IRON_DESC",
  OriginAsc = "ORIGIN_ASC",
  OriginDesc = "ORIGIN_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IFullOldConnection {
   __typename?: "FullOldConnection";
  totalCount: Scalars["Int"];
}

export interface IFullOldProgram {
   __typename?: "FullOldProgram";
  id: Scalars["Int"];
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  duration?: Maybe<Scalars["Int"]>;
  cycles?: Maybe<Scalars["Json"]>;
  tags: Array<Scalars["String"]>;
  createdAt: Scalars["NaiveDateTime"];
  updatedAt: Scalars["NaiveDateTime"];
  coachByCoachId: IOldCoach;
  programWorkoutsByProgramId: IFullOldConnection;
  builderVersion: Scalars["Int"];
}

export interface IFullWorkoutTemplateDirectory {
   __typename?: "FullWorkoutTemplateDirectory";
  id: Scalars["ID"];
  name: Scalars["String"];
  parentId?: Maybe<Scalars["ID"]>;
  subdirectories: IWorkoutTemplateDirectoriesConnection;
  workoutTemplates: IWorkoutTemplatesConnection;
  path: IWorkoutTemplateDirectory[];
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
}

export interface IGtin  extends INode {
   __typename?: "Gtin";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  foodId: Scalars["Uuid"];
  gtin: Scalars["String"];
  /** Reads a single `FoodbankFood` that is related to this `Gtin`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
}

/** A condition to be used against `Gtin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IGtinCondition {
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `gtin` field. */
  gtin?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Gtin` */
export interface IGtinInput {
  foodId: Scalars["Uuid"];
  gtin: Scalars["String"];
}

/** Represents an update to a `Gtin`. Fields that are set will be updated. */
export interface IGtinPatch {
  foodId?: Maybe<Scalars["Uuid"]>;
  gtin?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Gtin` values. */
export interface IGtinsConnection {
   __typename?: "GtinsConnection";
  /** A list of `Gtin` objects. */
  nodes: Array<Maybe<IGtin>>;
  /** A list of edges which contains the `Gtin` and cursor to aid in pagination. */
  edges: IGtinsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Gtin` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Gtin` edge in the connection. */
export interface IGtinsEdge {
   __typename?: "GtinsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Gtin` at the end of the edge. */
  node?: Maybe<IGtin>;
}

/** Methods to use when ordering `Gtin`. */
export enum IGtinsOrderBy {
  Natural = "NATURAL",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  GtinAsc = "GTIN_ASC",
  GtinDesc = "GTIN_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** List of actions performed on tables */
export interface IHistoryAction  extends INode {
   __typename?: "HistoryAction";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
}

/**
 * A condition to be used against `HistoryAction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IHistoryActionCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `HistoryAction` */
export interface IHistoryActionInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
}

/** Represents an update to a `HistoryAction`. Fields that are set will be updated. */
export interface IHistoryActionPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `HistoryAction` values. */
export interface IHistoryActionsConnection {
   __typename?: "HistoryActionsConnection";
  /** A list of `HistoryAction` objects. */
  nodes: Array<Maybe<IHistoryAction>>;
  /** A list of edges which contains the `HistoryAction` and cursor to aid in pagination. */
  edges: IHistoryActionsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `HistoryAction` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `HistoryAction` edge in the connection. */
export interface IHistoryActionsEdge {
   __typename?: "HistoryActionsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `HistoryAction` at the end of the edge. */
  node?: Maybe<IHistoryAction>;
}

/** Methods to use when ordering `HistoryAction`. */
export enum IHistoryActionsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IInsightBody {
   __typename?: "InsightBody";
  bfp?: Maybe<Array<Maybe<IInsightBodyNode>>>;
  bodyWeight?: Maybe<Array<Maybe<IInsightBodyNode>>>;
  bfm?: Maybe<Array<Maybe<IInsightBodyNode>>>;
  smm?: Maybe<Array<Maybe<IInsightBodyNode>>>;
  circumference?: Maybe<Array<Maybe<IInsightCircumferenceNode>>>;
}

export interface IInsightBodyNode {
   __typename?: "InsightBodyNode";
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Float"]>;
}

export interface IInsightCircumferenceNode {
   __typename?: "InsightCircumferenceNode";
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Float"]>;
  parts?: Maybe<Scalars["Json"]>;
}

export interface IInsightFeeling {
   __typename?: "InsightFeeling";
  gratitude?: Maybe<Array<Maybe<IInsightFeelingNode>>>;
  motivation?: Maybe<Array<Maybe<IInsightFeelingNode>>>;
  stressOptimization?: Maybe<Array<Maybe<IInsightFeelingNode>>>;
  sleep?: Maybe<Array<Maybe<IInsightFeelingNode>>>;
}

export interface IInsightFeelingNode {
   __typename?: "InsightFeelingNode";
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Float"]>;
}

export interface IInsightNutritionNode {
   __typename?: "InsightNutritionNode";
  trackedDays?: Maybe<Scalars["Int"]>;
  calsAccuracy?: Maybe<Scalars["Float"]>;
  proteinAccuracy?: Maybe<Scalars["Float"]>;
  fatAccuracy?: Maybe<Scalars["Float"]>;
  carbsAccuracy?: Maybe<Scalars["Float"]>;
}

export interface IInsightTraining {
   __typename?: "InsightTraining";
  sessionCount?: Maybe<Scalars["Int"]>;
  weights?: Maybe<Array<Maybe<IInsightTrainingNode>>>;
  steps?: Maybe<Array<Maybe<IInsightTrainingNode>>>;
}

export interface IInsightTrainingNode {
   __typename?: "InsightTrainingNode";
  weekNumber?: Maybe<Scalars["String"]>;
  averageValue?: Maybe<Scalars["Float"]>;
  totalValue?: Maybe<Scalars["Float"]>;
}

export interface IInstructor  extends INode {
   __typename?: "Instructor";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  ksAccountId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  clubId?: Maybe<Scalars["Uuid"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  status: IInstructorStatus;
  /** Reads a single `Club` that is related to this `Instructor`. */
  clubByClubId?: Maybe<IClub>;
  /** Reads and enables pagination through a set of `SessionInstructor`. */
  sessionInstructorsByInstructorId: ISessionInstructorsConnection;
  /** Reads and enables pagination through a set of `ClassInstructor`. */
  classInstructorsByInstructorId: IClassInstructorsConnection;
}

export interface IInstructorSessionInstructorsByInstructorIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
  condition?: Maybe<ISessionInstructorCondition>;
}

export interface IInstructorClassInstructorsByInstructorIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
  condition?: Maybe<IClassInstructorCondition>;
}

/**
 * A condition to be used against `Instructor` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IInstructorCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `ksAccountId` field. */
  ksAccountId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsClubId` field. */
  defaultKsClubId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsOrgId` field. */
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<IInstructorStatus>;
}

/** An input for mutations affecting `Instructor` */
export interface IInstructorInput {
  id?: Maybe<Scalars["Uuid"]>;
  ksAccountId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  status?: Maybe<IInstructorStatus>;
}

/** Represents an update to a `Instructor`. Fields that are set will be updated. */
export interface IInstructorPatch {
  id?: Maybe<Scalars["Uuid"]>;
  ksAccountId?: Maybe<Scalars["String"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  nickname?: Maybe<Scalars["String"]>;
  phone?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  status?: Maybe<IInstructorStatus>;
}

/** A connection to a list of `Instructor` values. */
export interface IInstructorsConnection {
   __typename?: "InstructorsConnection";
  /** A list of `Instructor` objects. */
  nodes: Array<Maybe<IInstructor>>;
  /** A list of edges which contains the `Instructor` and cursor to aid in pagination. */
  edges: IInstructorsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Instructor` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Instructor` edge in the connection. */
export interface IInstructorsEdge {
   __typename?: "InstructorsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Instructor` at the end of the edge. */
  node?: Maybe<IInstructor>;
}

/** Methods to use when ordering `Instructor`. */
export enum IInstructorsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  KsAccountIdAsc = "KS_ACCOUNT_ID_ASC",
  KsAccountIdDesc = "KS_ACCOUNT_ID_DESC",
  FirstNameAsc = "FIRST_NAME_ASC",
  FirstNameDesc = "FIRST_NAME_DESC",
  LastNameAsc = "LAST_NAME_ASC",
  LastNameDesc = "LAST_NAME_DESC",
  NicknameAsc = "NICKNAME_ASC",
  NicknameDesc = "NICKNAME_DESC",
  PhoneAsc = "PHONE_ASC",
  PhoneDesc = "PHONE_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  DefaultKsClubIdAsc = "DEFAULT_KS_CLUB_ID_ASC",
  DefaultKsClubIdDesc = "DEFAULT_KS_CLUB_ID_DESC",
  DefaultKsOrgIdAsc = "DEFAULT_KS_ORG_ID_ASC",
  DefaultKsOrgIdDesc = "DEFAULT_KS_ORG_ID_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IInstructorStatus {
  Active = "ACTIVE",
  Archived = "ARCHIVED",
  Deleted = "DELETED",
}

export interface IInvite {
   __typename?: "Invite";
  email: Scalars["String"];
  token: Scalars["String"];
  expiryDate: Scalars["Datetime"];
  isAccepted: Scalars["Boolean"];
  locationId: Scalars["Int"];
  coachId: Scalars["Int"];
  firstName: Scalars["String"];
  inviterId?: Maybe<Scalars["Int"]>;
  createdAt: Scalars["Datetime"];
  workspaceId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface IInviteMemberByCoachInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
  email: Scalars["String"];
  firstName: Scalars["String"];
  coach: Scalars["ID"];
  location?: Maybe<Scalars["ID"]>;
}

export interface IInviteMemberByCoachPayload {
   __typename?: "InviteMemberByCoachPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Invite` values. */
export interface IInvitesConnection {
   __typename?: "InvitesConnection";
  /** A list of `Invite` objects. */
  nodes: Array<Maybe<IInvite>>;
  /** A list of edges which contains the `Invite` and cursor to aid in pagination. */
  edges: IInvitesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
}

/** A `Invite` edge in the connection. */
export interface IInvitesEdge {
   __typename?: "InvitesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Invite` at the end of the edge. */
  node?: Maybe<IInvite>;
}

export interface IKeystoneBarcodeInput {
  region?: Maybe<Scalars["String"]>;
  language?: Maybe<Scalars["String"]>;
}

export interface IKeystoneClub {
   __typename?: "KeystoneClub";
  id: Scalars["ID"];
  name: Scalars["String"];
  orgId?: Maybe<Scalars["ID"]>;
  status: IKeystoneClubStatus;
  address?: Maybe<Scalars["String"]>;
  contactEmail?: Maybe<Scalars["String"]>;
  contactPhone?: Maybe<Scalars["String"]>;
  comment?: Maybe<Scalars["String"]>;
}

export interface IKeystoneClubsConnection {
   __typename?: "KeystoneClubsConnection";
  /** List of available clubs */
  nodes: IKeystoneClub[];
  /** Total number of clubs */
  totalCount: Scalars["Int"];
}

export enum IKeystoneClubStatus {
  Active = "ACTIVE",
  NeedAttention = "NEED_ATTENTION",
  Disabled = "DISABLED",
}

export interface IKeystoneFeature {
   __typename?: "KeystoneFeature";
  name: Scalars["String"];
}

export interface IKeystoneFeaturesConnection {
   __typename?: "KeystoneFeaturesConnection";
  /** List of available features */
  nodes: IKeystoneFeature[];
  /** Total number of features */
  totalCount: Scalars["Int"];
}

export interface IKeystoneFoodbankFoodItem {
   __typename?: "KeystoneFoodbankFoodItem";
  id: Scalars["String"];
  name: Scalars["String"];
  brand?: Maybe<Scalars["String"]>;
  origin?: Maybe<Scalars["String"]>;
  nutritionFacts: IKeystoneNutritionFact;
  servings: Array<Maybe<IKeystoneServing>>;
  defaultServingIndex?: Maybe<Scalars["Int"]>;
  externalId?: Maybe<Scalars["String"]>;
  provider?: Maybe<Scalars["String"]>;
  type?: Maybe<Scalars["Int"]>;
  class?: Maybe<Scalars["Int"]>;
  isMyFood?: Maybe<Scalars["Boolean"]>;
  isGeneric?: Maybe<Scalars["Boolean"]>;
}

export interface IKeystoneFoodBrand {
   __typename?: "KeystoneFoodBrand";
  id: Scalars["ID"];
  name: Scalars["String"];
}

export interface IKeystoneFoodBrandsConnection {
   __typename?: "KeystoneFoodBrandsConnection";
  /** List of available brands */
  nodes: IKeystoneFoodBrand[];
  /** Total number of brands */
  totalCount: Scalars["Int"];
}

export interface IKeystoneFoodItem {
   __typename?: "KeystoneFoodItem";
  id: Scalars["String"];
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  brand?: Maybe<Scalars["String"]>;
  origin?: Maybe<Scalars["String"]>;
  hasStar?: Maybe<Scalars["Boolean"]>;
  servingName: Scalars["String"];
  servingVolume?: Maybe<Scalars["String"]>;
  servingUnit: Scalars["String"];
  servingMult: Scalars["String"];
  refCals?: Maybe<Scalars["String"]>;
  refProtein?: Maybe<Scalars["String"]>;
  refFat?: Maybe<Scalars["String"]>;
  refCarbs?: Maybe<Scalars["String"]>;
}

export interface IKeystoneFoodlakeFoodInput {
  id?: Maybe<Scalars["String"]>;
  servings: Array<Maybe<IKeystoneFoodlakeServing>>;
  nutritionFacts: IKeystoneFoodlakeNutritionFact;
  barcode?: Maybe<Scalars["String"]>;
  name: Scalars["String"];
  brandName: Scalars["String"];
  country: Scalars["Int"];
  comment?: Maybe<Scalars["String"]>;
  defaultUnit: Scalars["String"];
}

export interface IKeystoneFoodlakeNutritionFact {
  cals?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  saturatedFat?: Maybe<Scalars["Float"]>;
  polyunsaturatedFat?: Maybe<Scalars["Float"]>;
  monounsaturatedFat?: Maybe<Scalars["Float"]>;
  transFat?: Maybe<Scalars["Float"]>;
  cholesterol?: Maybe<Scalars["Float"]>;
  sodium?: Maybe<Scalars["Float"]>;
  potassium?: Maybe<Scalars["Float"]>;
  sugar?: Maybe<Scalars["Float"]>;
  vitaminA?: Maybe<Scalars["Float"]>;
  vitaminC?: Maybe<Scalars["Float"]>;
  calcium?: Maybe<Scalars["Float"]>;
  iron?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Float"]>;
  ash?: Maybe<Scalars["Float"]>;
}

export interface IKeystoneFoodlakeServing {
  name: Scalars["String"];
  volume?: Maybe<Scalars["Float"]>;
  unit: Scalars["String"];
  multiplier: Scalars["Float"];
  isDefaultServing: Scalars["Boolean"];
}

export interface IKeystoneFoodRequestObject {
   __typename?: "KeystoneFoodRequestObject";
  body: IFoodRequest;
  coach: IUser;
  country: Scalars["String"];
}

export interface IKeystoneFoodRequestPayload {
   __typename?: "KeystoneFoodRequestPayload";
  requestsLeft: Scalars["Int"];
  request?: Maybe<IKeystoneFoodRequestObject>;
}

export interface IKeystoneFoodSearchResult {
   __typename?: "KeystoneFoodSearchResult";
  totalCount?: Maybe<Scalars["Int"]>;
  count?: Maybe<Scalars["Int"]>;
  page?: Maybe<Scalars["Int"]>;
  nodes: Array<Maybe<IKeystoneFoodItem>>;
}

export interface IKeystoneNutritionFact {
   __typename?: "KeystoneNutritionFact";
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  saturatedFat?: Maybe<Scalars["Float"]>;
  polyunsaturatedFat?: Maybe<Scalars["Float"]>;
  monounsaturatedFat?: Maybe<Scalars["Float"]>;
  transFat?: Maybe<Scalars["Float"]>;
  cholesterol?: Maybe<Scalars["Float"]>;
  sodium?: Maybe<Scalars["Float"]>;
  potassium?: Maybe<Scalars["Float"]>;
  sugar?: Maybe<Scalars["Float"]>;
  vitaminA?: Maybe<Scalars["Float"]>;
  vitaminC?: Maybe<Scalars["Float"]>;
  calcium?: Maybe<Scalars["Float"]>;
  iron?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Float"]>;
  ash?: Maybe<Scalars["Float"]>;
}

export interface IKeystoneOrg {
   __typename?: "KeystoneOrg";
  id: Scalars["ID"];
  name: Scalars["String"];
  contactEmail?: Maybe<Scalars["String"]>;
  status: IKeystoneOrgStatus;
  countryId: Scalars["Int"];
  comment?: Maybe<Scalars["String"]>;
}

export interface IKeystoneOrgsConnection {
   __typename?: "KeystoneOrgsConnection";
  /** List of available orgs */
  nodes: IKeystoneOrg[];
  /** Total number of orgs */
  totalCount: Scalars["Int"];
}

export enum IKeystoneOrgStatus {
  Active = "ACTIVE",
  NeedAttention = "NEED_ATTENTION",
  Disabled = "DISABLED",
}

export interface IKeystoneSearchInput {
  page_number?: Maybe<Scalars["Int"]>;
  max_results?: Maybe<Scalars["Int"]>;
  region?: Maybe<Scalars["String"]>;
}

export interface IKeystoneServing {
   __typename?: "KeystoneServing";
  num?: Maybe<Scalars["Float"]>;
  name?: Maybe<Scalars["String"]>;
  volume?: Maybe<Scalars["Float"]>;
  unit?: Maybe<Scalars["String"]>;
}

export interface IKsClub {
   __typename?: "KsClub";
  id: Scalars["Uuid"];
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
  orgId?: Maybe<Scalars["Uuid"]>;
  countryId: Scalars["Int"];
  status: IClubStatus;
  address?: Maybe<Scalars["String"]>;
  contactEmail?: Maybe<Scalars["String"]>;
  contactPhone?: Maybe<Scalars["String"]>;
  comment?: Maybe<Scalars["String"]>;
  memberGroupId?: Maybe<Scalars["Uuid"]>;
  coachGroupId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `KsClub` values. */
export interface IKsClubsConnection {
   __typename?: "KsClubsConnection";
  /** A list of `KsClub` objects. */
  nodes: Array<Maybe<IKsClub>>;
  /** A list of edges which contains the `KsClub` and cursor to aid in pagination. */
  edges: IKsClubsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
}

/** A `KsClub` edge in the connection. */
export interface IKsClubsEdge {
   __typename?: "KsClubsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `KsClub` at the end of the edge. */
  node?: Maybe<IKsClub>;
}

/** A connection to a list of `KsCountry` values. */
export interface IKsCountriesConnection {
   __typename?: "KsCountriesConnection";
  /** A list of `KsCountry` objects. */
  nodes: Array<Maybe<IKsCountry>>;
  /** A list of edges which contains the `KsCountry` and cursor to aid in pagination. */
  edges: IKsCountriesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
}

/** A `KsCountry` edge in the connection. */
export interface IKsCountriesEdge {
   __typename?: "KsCountriesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `KsCountry` at the end of the edge. */
  node?: Maybe<IKsCountry>;
}

export interface IKsCountry {
   __typename?: "KsCountry";
  id: Scalars["Int"];
  name: Scalars["String"];
  alternativeNames?: Maybe<Array<Maybe<Scalars["String"]>>>;
}

export interface IKsFoodbankFoodItem {
   __typename?: "KSFoodbankFoodItem";
  id: Scalars["ID"];
  name: Scalars["String"];
  brand?: Maybe<Scalars["String"]>;
  origin?: Maybe<Scalars["String"]>;
  nutritionFacts: IKsNutritionFact;
  servings: IKsFoodbankServingsConnection;
  externalId?: Maybe<Scalars["ID"]>;
  provider?: Maybe<Scalars["String"]>;
  type?: Maybe<Scalars["Int"]>;
  class?: Maybe<Scalars["Int"]>;
  isMyFood: Scalars["Boolean"];
  isGeneric: Scalars["Boolean"];
}

export interface IKsFoodbankFoodItemsConnection {
   __typename?: "KSFoodbankFoodItemsConnection";
  /** List of available food items */
  nodes: IKsFoodbankFoodItem[];
  /** Total number of food items */
  totalCount: Scalars["Int"];
}

export interface IKsFoodbankServing {
   __typename?: "KSFoodbankServing";
  num: Scalars["Float"];
  name: Scalars["String"];
  volume?: Maybe<Scalars["Float"]>;
  unit: Scalars["String"];
  isDefaultServing: Scalars["Boolean"];
  multiplier: Scalars["Float"];
}

export interface IKsFoodbankServingsConnection {
   __typename?: "KSFoodbankServingsConnection";
  /** List of available food servings */
  nodes: IKsFoodbankServing[];
  /** Total number of food servings */
  totalCount: Scalars["Int"];
}

export interface IKsNutritionFact {
   __typename?: "KSNutritionFact";
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  saturatedFat?: Maybe<Scalars["Float"]>;
  polyunsaturatedFat?: Maybe<Scalars["Float"]>;
  monounsaturatedFat?: Maybe<Scalars["Float"]>;
  transFat?: Maybe<Scalars["Float"]>;
  cholesterol?: Maybe<Scalars["Float"]>;
  sodium?: Maybe<Scalars["Float"]>;
  potassium?: Maybe<Scalars["Float"]>;
  sugar?: Maybe<Scalars["Float"]>;
  vitaminA?: Maybe<Scalars["Float"]>;
  vitaminC?: Maybe<Scalars["Float"]>;
  calcium?: Maybe<Scalars["Float"]>;
  iron?: Maybe<Scalars["Float"]>;
  water?: Maybe<Scalars["Float"]>;
  ash?: Maybe<Scalars["Float"]>;
}

export interface ILastMetricsByDatePayload {
   __typename?: "LastMetricsByDatePayload";
  bodyWeight?: Maybe<ILastMetricValue>;
  bodyFatPercentage?: Maybe<ILastMetricValue>;
  bodyFatMass?: Maybe<ILastMetricValue>;
  skeletalMuscleMass?: Maybe<ILastMetricValue>;
  circumference?: Maybe<ILastMetricValue>;
  skinFolds?: Maybe<ILastMetricValue>;
  sleepHours?: Maybe<ILastMetricValue>;
  heartRate?: Maybe<ILastMetricValue>;
  heartRateVar?: Maybe<ILastMetricValue>;
  bodyTemp?: Maybe<ILastMetricValue>;
}

export interface ILastMetricValue {
   __typename?: "LastMetricValue";
  id: Scalars["ID"];
  date: Scalars["NaiveDate"];
  value: Scalars["Float"];
  delta?: Maybe<Scalars["Float"]>;
  previousValue?: Maybe<ILastMetricValue>;
}

export interface ILocation  extends INode {
   __typename?: "Location";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  address?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `Coach`. */
  coachesByLocationId: ICoachesConnection;
  /** Reads and enables pagination through a set of `Member`. */
  membersByLocationId: IMembersConnection;
}

export interface ILocationCoachesByLocationIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICoachesOrderBy[]>;
  condition?: Maybe<ICoachCondition>;
}

export interface ILocationMembersByLocationIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMembersOrderBy[]>;
  condition?: Maybe<IMemberCondition>;
}

/**
 * A condition to be used against `Location` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface ILocationCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `address` field. */
  address?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Location` */
export interface ILocationInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
  address?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Location`. Fields that are set will be updated. */
export interface ILocationPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  address?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Location` values. */
export interface ILocationsConnection {
   __typename?: "LocationsConnection";
  /** A list of `Location` objects. */
  nodes: Array<Maybe<ILocation>>;
  /** A list of edges which contains the `Location` and cursor to aid in pagination. */
  edges: ILocationsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Location` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Location` edge in the connection. */
export interface ILocationsEdge {
   __typename?: "LocationsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Location` at the end of the edge. */
  node?: Maybe<ILocation>;
}

/** Methods to use when ordering `Location`. */
export enum ILocationsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  AddressAsc = "ADDRESS_ASC",
  AddressDesc = "ADDRESS_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMacro {
   __typename?: "Macro";
  protein?: Maybe<Scalars["Int"]>;
  fat?: Maybe<Scalars["Int"]>;
  carbs?: Maybe<Scalars["Int"]>;
}

export interface IMacroEntryId {
   __typename?: "MacroEntryId";
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
  label?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `MacroEntryId` */
export interface IMacroEntryIdInput {
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
  label?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Macro` */
export interface IMacroInput {
  protein?: Maybe<Scalars["Int"]>;
  fat?: Maybe<Scalars["Int"]>;
  carbs?: Maybe<Scalars["Int"]>;
}

export interface IMacrosEntryId {
   __typename?: "MacrosEntryId";
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
}

/** An input for mutations affecting `MacrosEntryId` */
export interface IMacrosEntryIdInput {
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
}

export interface IManager  extends INode {
   __typename?: "Manager";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  ksUserId: Scalars["String"];
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  importedAt: Scalars["Datetime"];
  /** Reads and enables pagination through a set of `ManagerClubOrg`. */
  managerClubOrgsByManagerId: IManagerClubOrgsConnection;
}

export interface IManagerManagerClubOrgsByManagerIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IManagerClubOrgsOrderBy[]>;
  condition?: Maybe<IManagerClubOrgCondition>;
}

export interface IManagerClubOrg  extends INode {
   __typename?: "ManagerClubOrg";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  managerId: Scalars["Int"];
  ksClubId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Keystone user id of user who created the assignment */
  assignedBy: Scalars["String"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Manager` that is related to this `ManagerClubOrg`. */
  managerByManagerId?: Maybe<IManager>;
}

/**
 * A condition to be used against `ManagerClubOrg` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IManagerClubOrgCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `managerId` field. */
  managerId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksClubId` field. */
  ksClubId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `assignedBy` field. */
  assignedBy?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `ManagerClubOrg` */
export interface IManagerClubOrgInput {
  id?: Maybe<Scalars["Uuid"]>;
  managerId: Scalars["Int"];
  ksClubId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Keystone user id of user who created the assignment */
  assignedBy: Scalars["String"];
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `ManagerClubOrg`. Fields that are set will be updated. */
export interface IManagerClubOrgPatch {
  id?: Maybe<Scalars["Uuid"]>;
  managerId?: Maybe<Scalars["Int"]>;
  ksClubId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Keystone user id of user who created the assignment */
  assignedBy?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `ManagerClubOrg` values. */
export interface IManagerClubOrgsConnection {
   __typename?: "ManagerClubOrgsConnection";
  /** A list of `ManagerClubOrg` objects. */
  nodes: Array<Maybe<IManagerClubOrg>>;
  /** A list of edges which contains the `ManagerClubOrg` and cursor to aid in pagination. */
  edges: IManagerClubOrgsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ManagerClubOrg` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ManagerClubOrg` edge in the connection. */
export interface IManagerClubOrgsEdge {
   __typename?: "ManagerClubOrgsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ManagerClubOrg` at the end of the edge. */
  node?: Maybe<IManagerClubOrg>;
}

/** Methods to use when ordering `ManagerClubOrg`. */
export enum IManagerClubOrgsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  ManagerIdAsc = "MANAGER_ID_ASC",
  ManagerIdDesc = "MANAGER_ID_DESC",
  KsClubIdAsc = "KS_CLUB_ID_ASC",
  KsClubIdDesc = "KS_CLUB_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  AssignedByAsc = "ASSIGNED_BY_ASC",
  AssignedByDesc = "ASSIGNED_BY_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A condition to be used against `Manager` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IManagerCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsClubId` field. */
  defaultKsClubId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsOrgId` field. */
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `importedAt` field. */
  importedAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `Manager` */
export interface IManagerInput {
  id?: Maybe<Scalars["Int"]>;
  ksUserId: Scalars["String"];
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  importedAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `Manager`. Fields that are set will be updated. */
export interface IManagerPatch {
  id?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  importedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `Manager` values. */
export interface IManagersConnection {
   __typename?: "ManagersConnection";
  /** A list of `Manager` objects. */
  nodes: Array<Maybe<IManager>>;
  /** A list of edges which contains the `Manager` and cursor to aid in pagination. */
  edges: IManagersEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Manager` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Manager` edge in the connection. */
export interface IManagersEdge {
   __typename?: "ManagersEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Manager` at the end of the edge. */
  node?: Maybe<IManager>;
}

/** Methods to use when ordering `Manager`. */
export enum IManagersOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  DefaultKsClubIdAsc = "DEFAULT_KS_CLUB_ID_ASC",
  DefaultKsClubIdDesc = "DEFAULT_KS_CLUB_ID_DESC",
  DefaultKsOrgIdAsc = "DEFAULT_KS_ORG_ID_ASC",
  DefaultKsOrgIdDesc = "DEFAULT_KS_ORG_ID_DESC",
  ImportedAtAsc = "IMPORTED_AT_ASC",
  ImportedAtDesc = "IMPORTED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMealItem  extends INode {
   __typename?: "MealItem";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  /** Default serving size */
  serving?: Maybe<IFoodServing>;
  /** Order of item in a specific meal */
  orderIndex?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `MemberMeal` that is related to this `MealItem`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** Reads a single `Food` that is related to this `MealItem`. */
  foodByFoodId?: Maybe<IFood>;
}

/**
 * A condition to be used against `MealItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IMealItemCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `serving` field. */
  serving?: Maybe<IFoodServingInput>;
  /** Checks for equality with the object’s `orderIndex` field. */
  orderIndex?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MealItem` */
export interface IMealItemInput {
  id?: Maybe<Scalars["Uuid"]>;
  mealId: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  /** Default serving size */
  serving?: Maybe<IFoodServingInput>;
  /** Order of item in a specific meal */
  orderIndex?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MealItem`. Fields that are set will be updated. */
export interface IMealItemPatch {
  id?: Maybe<Scalars["Uuid"]>;
  mealId?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Default serving size */
  serving?: Maybe<IFoodServingInput>;
  /** Order of item in a specific meal */
  orderIndex?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MealItem` values. */
export interface IMealItemsConnection {
   __typename?: "MealItemsConnection";
  /** A list of `MealItem` objects. */
  nodes: Array<Maybe<IMealItem>>;
  /** A list of edges which contains the `MealItem` and cursor to aid in pagination. */
  edges: IMealItemsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MealItem` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MealItem` edge in the connection. */
export interface IMealItemsEdge {
   __typename?: "MealItemsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MealItem` at the end of the edge. */
  node?: Maybe<IMealItem>;
}

/** Methods to use when ordering `MealItem`. */
export enum IMealItemsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MealIdAsc = "MEAL_ID_ASC",
  MealIdDesc = "MEAL_ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  ServingAsc = "SERVING_ASC",
  ServingDesc = "SERVING_DESC",
  OrderIndexAsc = "ORDER_INDEX_ASC",
  OrderIndexDesc = "ORDER_INDEX_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A member of the label. */
export interface IMember  extends INode {
   __typename?: "Member";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  /** The primary unique identifier for the member. */
  id: Scalars["Int"];
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  /** The member’s first name. */
  firstName: Scalars["String"];
  /** The member’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  /** The time this member was created. */
  createdAt: Scalars["Datetime"];
  goalSummary?: Maybe<Scalars["String"]>;
  checkedInAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status: IPersonStatus;
  /** Member goal: lose weight / get tuned / build muscle / ... */
  goal?: Maybe<Scalars["String"]>;
  /** For collecting initial profile data in the app (on boarding screen) */
  isOnBoarded: Scalars["Boolean"];
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads and enables pagination through a set of `NutritionProfile`. */
  nutritionProfilesByMemberId: INutritionProfilesConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  memberMetricsByMemberId: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberTrainingProgram`. */
  memberTrainingProgramsByMemberId: IMemberTrainingProgramsConnection;
  /** Reads and enables pagination through a set of `MemberWorkout`. */
  memberWorkoutsByMemberId: IMemberWorkoutsConnection;
  /** Reads and enables pagination through a set of `MemberNutritionMetric`. */
  memberNutritionMetricsByMemberId: IMemberNutritionMetricsConnection;
  /** Reads and enables pagination through a set of `MemberFavouriteFood`. */
  memberFavouriteFoodsByMemberId: IMemberFavouriteFoodsConnection;
  /** Reads and enables pagination through a set of `MemberTag`. */
  memberTagsByMemberId: IMemberTagsConnection;
  /** Reads and enables pagination through a set of `MemberWaterMetric`. */
  memberWaterMetricsByMemberId: IMemberWaterMetricsConnection;
  /** Reads and enables pagination through a set of `MemberRecentFood`. */
  memberRecentFoodsByMemberId: IMemberRecentFoodsConnection;
  /** Reads and enables pagination through a set of `MemberMyFood`. */
  memberMyFoodsByMemberId: IMemberMyFoodsConnection;
  /** Reads and enables pagination through a set of `MemberStepsMetric`. */
  memberStepsMetricsByMemberId: IMemberStepsMetricsConnection;
  /** Reads and enables pagination through a set of `MemberCheckin`. */
  memberCheckinsByMemberId: IMemberCheckinsConnection;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  memberMealsByMemberId: IMemberMealsConnection;
  /** Reads and enables pagination through a set of `Food`. */
  foodsByMemberId: IFoodsConnection;
  /** Reads and enables pagination through a set of `NutritionDay`. */
  nutritionDaysByMemberId: INutritionDaysConnection;
  /** Reads and enables pagination through a set of `MemberNutritionPlan`. */
  memberNutritionPlansByMemberId: IMemberNutritionPlansConnection;
  /** Reads and enables pagination through a set of `MemberReminder`. */
  memberRemindersByMemberId: IMemberRemindersConnection;
  /** Reads and enables pagination through a set of `MemberRecipe`. */
  memberRecipesByMemberId: IMemberRecipesConnection;
  /** Reads and enables pagination through a set of `MentoringReport`. */
  mentoringReportsByMemberId: IMentoringReportsConnection;
  accountStatus?: Maybe<IPersonStatus>;
  /** Reads and enables pagination through a set of `Food`. */
  allMyFood: IFoodsConnection;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  allMyMeals: IMemberMealsConnection;
  /** Reads and enables pagination through a set of `MemberEvaluatedRecipe`. */
  allMyRecipes: IMemberEvaluatedRecipesConnection;
  club?: Maybe<IKsClub>;
  dateOfBirth?: Maybe<Scalars["Date"]>;
  email?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `Feature`. */
  features: IFeaturesConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  feelingsByDate: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberFeelingsHistoryItem`. */
  feelingsHistory: IMemberFeelingsHistoryItemsConnection;
  fullName?: Maybe<Scalars["String"]>;
  gender?: Maybe<Scalars["String"]>;
  height?: Maybe<Scalars["Float"]>;
  invitationToken?: Maybe<Scalars["String"]>;
  lastCheckin?: Maybe<IMemberCheckin>;
  latestActivity?: Maybe<Scalars["Date"]>;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  measurementsByDate: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberMeasurementsHistoryItem`. */
  measurementsHistory: IMemberMeasurementsHistoryItemsConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  measurementsLatest: IMemberMetricsConnection;
  org?: Maybe<IOrganisation>;
  profilePicDir?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `MemberReservation`. */
  reservations: IMemberReservationsConnection;
  riskStatus?: Maybe<Scalars["Float"]>;
  /** Reads and enables pagination through a set of `UserSetting`. */
  settings: IUserSettingsConnection;
  /** Reads and enables pagination through a set of `Tag`. */
  tags: ITagsConnection;
  trainingPlanAssignment?: Maybe<IMemberTrainingPlanAssignment>;
  trainingProgram?: Maybe<Scalars["String"]>;
  searchFood?: Maybe<IFatSecretFoodSearchResult>;
  foodItemById?: Maybe<IFatSecretFoodItemResult>;
  findIdForBarcode?: Maybe<IFatSecretFoodId>;
  findFoodByBarcode?: Maybe<IFatSecretBarcodeResult>;
  findFoodItemByBarcode?: Maybe<IKeystoneFoodbankFoodItem>;
  workoutTemplates: IWorkoutTemplatesConnection;
  assignedWorkoutTemplates: IWorkoutTemplatesConnection;
  workoutSessions: IWorkoutSessionsConnection;
  workoutSessionsByDate: IWorkoutSessionsConnection;
  workoutSessionsByMonth: IWorkoutSessionsConnection;
  workoutSessionsMetaByInterval: IWorkoutMetaConnection;
  assignedTrainingPlans: ITrainingPlanAssignmentsConnection;
  keystoneFoodSearch: IKeystoneFoodSearchResult;
  exerciseAttemptsByName: IExerciseAttemptsConnection;
  weeklyTrainingStat: IWeeklyTrainingStat;
}

/** A member of the label. */
export interface IMemberNutritionProfilesByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionProfilesOrderBy[]>;
  condition?: Maybe<INutritionProfileCondition>;
}

/** A member of the label. */
export interface IMemberMemberMetricsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
  condition?: Maybe<IMemberMetricCondition>;
}

/** A member of the label. */
export interface IMemberMemberTrainingProgramsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
  condition?: Maybe<IMemberTrainingProgramCondition>;
}

/** A member of the label. */
export interface IMemberMemberWorkoutsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
  condition?: Maybe<IMemberWorkoutCondition>;
}

/** A member of the label. */
export interface IMemberMemberNutritionMetricsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
  condition?: Maybe<IMemberNutritionMetricCondition>;
}

/** A member of the label. */
export interface IMemberMemberFavouriteFoodsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberFavouriteFoodsOrderBy[]>;
  condition?: Maybe<IMemberFavouriteFoodCondition>;
}

/** A member of the label. */
export interface IMemberMemberTagsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTagsOrderBy[]>;
  condition?: Maybe<IMemberTagCondition>;
}

/** A member of the label. */
export interface IMemberMemberWaterMetricsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
  condition?: Maybe<IMemberWaterMetricCondition>;
}

/** A member of the label. */
export interface IMemberMemberRecentFoodsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
  condition?: Maybe<IMemberRecentFoodCondition>;
}

/** A member of the label. */
export interface IMemberMemberMyFoodsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMyFoodsOrderBy[]>;
  condition?: Maybe<IMemberMyFoodCondition>;
}

/** A member of the label. */
export interface IMemberMemberStepsMetricsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberStepsMetricsOrderBy[]>;
  condition?: Maybe<IMemberStepsMetricCondition>;
}

/** A member of the label. */
export interface IMemberMemberCheckinsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
  condition?: Maybe<IMemberCheckinCondition>;
}

/** A member of the label. */
export interface IMemberMemberMealsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
  condition?: Maybe<IMemberMealCondition>;
}

/** A member of the label. */
export interface IMemberFoodsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodsOrderBy[]>;
  condition?: Maybe<IFoodCondition>;
}

/** A member of the label. */
export interface IMemberNutritionDaysByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
  condition?: Maybe<INutritionDayCondition>;
}

/** A member of the label. */
export interface IMemberMemberNutritionPlansByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
  condition?: Maybe<IMemberNutritionPlanCondition>;
}

/** A member of the label. */
export interface IMemberMemberRemindersByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
  condition?: Maybe<IMemberReminderCondition>;
}

/** A member of the label. */
export interface IMemberMemberRecipesByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
  condition?: Maybe<IMemberRecipeCondition>;
}

/** A member of the label. */
export interface IMemberMentoringReportsByMemberIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
  condition?: Maybe<IMentoringReportCondition>;
}

/** A member of the label. */
export interface IMemberAllMyFoodArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberAllMyMealsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberAllMyRecipesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberFeaturesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberFeelingsByDateArgs {
  date?: Maybe<Scalars["Date"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberFeelingsHistoryArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberMeasurementsByDateArgs {
  date?: Maybe<Scalars["Date"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberMeasurementsHistoryArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberMeasurementsLatestArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberReservationsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberSettingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberTagsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/** A member of the label. */
export interface IMemberSearchFoodArgs {
  term?: Maybe<Scalars["String"]>;
  meta?: Maybe<ISearchInput>;
}

/** A member of the label. */
export interface IMemberFoodItemByIdArgs {
  id?: Maybe<Scalars["String"]>;
  meta?: Maybe<IFoodItemInput>;
}

/** A member of the label. */
export interface IMemberFindIdForBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IBarcodeInput>;
}

/** A member of the label. */
export interface IMemberFindFoodByBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IBarcodeInput>;
}

/** A member of the label. */
export interface IMemberFindFoodItemByBarcodeArgs {
  barcode?: Maybe<Scalars["String"]>;
  meta?: Maybe<IKeystoneBarcodeInput>;
}

/** A member of the label. */
export interface IMemberWorkoutSessionsByDateArgs {
  date?: Maybe<Scalars["NaiveDate"]>;
}

/** A member of the label. */
export interface IMemberWorkoutSessionsByMonthArgs {
  month?: Maybe<Scalars["NaiveDate"]>;
}

/** A member of the label. */
export interface IMemberWorkoutSessionsMetaByIntervalArgs {
  startDate: Scalars["NaiveDate"];
  interval: Scalars["Int"];
}

/** A member of the label. */
export interface IMemberAssignedTrainingPlansArgs {
  filter?: Maybe<IAssignmentFilter>;
  date?: Maybe<Scalars["NaiveDate"]>;
}

/** A member of the label. */
export interface IMemberKeystoneFoodSearchArgs {
  term?: Maybe<Scalars["String"]>;
  meta?: Maybe<IKeystoneSearchInput>;
}

/** A member of the label. */
export interface IMemberExerciseAttemptsByNameArgs {
  name: Scalars["String"];
  limit?: Maybe<Scalars["Int"]>;
  dayLimit?: Maybe<Scalars["Int"]>;
}

/** A member of the label. */
export interface IMemberWeeklyTrainingStatArgs {
  date: Scalars["NaiveDate"];
}

export interface IMemberCheckin  extends INode {
   __typename?: "MemberCheckin";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  notes?: Maybe<Scalars["String"]>;
  createdAt: Scalars["Datetime"];
  updatedAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberCheckin`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberCheckin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberCheckinCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberCheckin` */
export interface IMemberCheckinInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  notes?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberCheckin`. Fields that are set will be updated. */
export interface IMemberCheckinPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  notes?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberCheckin` values. */
export interface IMemberCheckinsConnection {
   __typename?: "MemberCheckinsConnection";
  /** A list of `MemberCheckin` objects. */
  nodes: Array<Maybe<IMemberCheckin>>;
  /** A list of edges which contains the `MemberCheckin` and cursor to aid in pagination. */
  edges: IMemberCheckinsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberCheckin` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberCheckin` edge in the connection. */
export interface IMemberCheckinsEdge {
   __typename?: "MemberCheckinsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberCheckin` at the end of the edge. */
  node?: Maybe<IMemberCheckin>;
}

/** Methods to use when ordering `MemberCheckin`. */
export enum IMemberCheckinsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IMemberCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `goalSummary` field. */
  goalSummary?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `checkedInAt` field. */
  checkedInAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsOrgId` field. */
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `defaultKsClubId` field. */
  defaultKsClubId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<IPersonStatus>;
  /** Checks for equality with the object’s `goal` field. */
  goal?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isOnBoarded` field. */
  isOnBoarded?: Maybe<Scalars["Boolean"]>;
}

export interface IMemberEvaluatedRecipe  extends INode {
   __typename?: "MemberEvaluatedRecipe";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  recipeId: Scalars["Uuid"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Food` that is related to this `MemberEvaluatedRecipe`. */
  foodByFoodId?: Maybe<IFood>;
  /** Reads a single `MemberRecipe` that is related to this `MemberEvaluatedRecipe`. */
  memberRecipeByRecipeId?: Maybe<IMemberRecipe>;
}

/**
 * A condition to be used against `MemberEvaluatedRecipe` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberEvaluatedRecipeCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `recipeId` field. */
  recipeId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberEvaluatedRecipe` */
export interface IMemberEvaluatedRecipeInput {
  id?: Maybe<Scalars["Uuid"]>;
  foodId: Scalars["Uuid"];
  recipeId: Scalars["Uuid"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberEvaluatedRecipe`. Fields that are set will be updated. */
export interface IMemberEvaluatedRecipePatch {
  id?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  recipeId?: Maybe<Scalars["Uuid"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberEvaluatedRecipe` values. */
export interface IMemberEvaluatedRecipesConnection {
   __typename?: "MemberEvaluatedRecipesConnection";
  /** A list of `MemberEvaluatedRecipe` objects. */
  nodes: Array<Maybe<IMemberEvaluatedRecipe>>;
  /** A list of edges which contains the `MemberEvaluatedRecipe` and cursor to aid in pagination. */
  edges: IMemberEvaluatedRecipesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberEvaluatedRecipe` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberEvaluatedRecipe` edge in the connection. */
export interface IMemberEvaluatedRecipesEdge {
   __typename?: "MemberEvaluatedRecipesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberEvaluatedRecipe` at the end of the edge. */
  node?: Maybe<IMemberEvaluatedRecipe>;
}

/** Methods to use when ordering `MemberEvaluatedRecipe`. */
export enum IMemberEvaluatedRecipesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  RecipeIdAsc = "RECIPE_ID_ASC",
  RecipeIdDesc = "RECIPE_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberFavouriteFood  extends INode {
   __typename?: "MemberFavouriteFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  foodId?: Maybe<Scalars["Int"]>;
  label: Scalars["String"];
  macrosEntryId?: Maybe<IMacrosEntryId>;
  entry: Scalars["Json"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  myFoodId?: Maybe<Scalars["Uuid"]>;
  isConverted: Scalars["Boolean"];
  /** Reads a single `Member` that is related to this `MemberFavouriteFood`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberFavouriteFood` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberFavouriteFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `macrosEntryId` field. */
  macrosEntryId?: Maybe<IMacrosEntryIdInput>;
  /** Checks for equality with the object’s `entry` field. */
  entry?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `myFoodId` field. */
  myFoodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `isConverted` field. */
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** An input for mutations affecting `MemberFavouriteFood` */
export interface IMemberFavouriteFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  foodId?: Maybe<Scalars["Int"]>;
  label: Scalars["String"];
  macrosEntryId?: Maybe<IMacrosEntryIdInput>;
  entry: Scalars["Json"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** Represents an update to a `MemberFavouriteFood`. Fields that are set will be updated. */
export interface IMemberFavouriteFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  foodId?: Maybe<Scalars["Int"]>;
  label?: Maybe<Scalars["String"]>;
  macrosEntryId?: Maybe<IMacrosEntryIdInput>;
  entry?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `MemberFavouriteFood` values. */
export interface IMemberFavouriteFoodsConnection {
   __typename?: "MemberFavouriteFoodsConnection";
  /** A list of `MemberFavouriteFood` objects. */
  nodes: Array<Maybe<IMemberFavouriteFood>>;
  /** A list of edges which contains the `MemberFavouriteFood` and cursor to aid in pagination. */
  edges: IMemberFavouriteFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberFavouriteFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberFavouriteFood` edge in the connection. */
export interface IMemberFavouriteFoodsEdge {
   __typename?: "MemberFavouriteFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberFavouriteFood` at the end of the edge. */
  node?: Maybe<IMemberFavouriteFood>;
}

/** Methods to use when ordering `MemberFavouriteFood`. */
export enum IMemberFavouriteFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  LabelAsc = "LABEL_ASC",
  LabelDesc = "LABEL_DESC",
  MacrosEntryIdAsc = "MACROS_ENTRY_ID_ASC",
  MacrosEntryIdDesc = "MACROS_ENTRY_ID_DESC",
  EntryAsc = "ENTRY_ASC",
  EntryDesc = "ENTRY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MyFoodIdAsc = "MY_FOOD_ID_ASC",
  MyFoodIdDesc = "MY_FOOD_ID_DESC",
  IsConvertedAsc = "IS_CONVERTED_ASC",
  IsConvertedDesc = "IS_CONVERTED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberFeelingsHistoryItem {
   __typename?: "MemberFeelingsHistoryItem";
  date?: Maybe<Scalars["Date"]>;
  avgScore?: Maybe<Scalars["BigFloat"]>;
}

/** A connection to a list of `MemberFeelingsHistoryItem` values. */
export interface IMemberFeelingsHistoryItemsConnection {
   __typename?: "MemberFeelingsHistoryItemsConnection";
  /** A list of `MemberFeelingsHistoryItem` objects. */
  nodes: Array<Maybe<IMemberFeelingsHistoryItem>>;
  /** A list of edges which contains the `MemberFeelingsHistoryItem` and cursor to aid in pagination. */
  edges: IMemberFeelingsHistoryItemsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberFeelingsHistoryItem` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberFeelingsHistoryItem` edge in the connection. */
export interface IMemberFeelingsHistoryItemsEdge {
   __typename?: "MemberFeelingsHistoryItemsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberFeelingsHistoryItem` at the end of the edge. */
  node?: Maybe<IMemberFeelingsHistoryItem>;
}

/** An input for mutations affecting `Member` */
export interface IMemberInput {
  /** The primary unique identifier for the member. */
  id?: Maybe<Scalars["Int"]>;
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  /** The member’s first name. */
  firstName: Scalars["String"];
  /** The member’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** The time this member was created. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  goalSummary?: Maybe<Scalars["String"]>;
  checkedInAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status?: Maybe<IPersonStatus>;
  /** Member goal: lose weight / get tuned / build muscle / ... */
  goal?: Maybe<Scalars["String"]>;
  /** For collecting initial profile data in the app (on boarding screen) */
  isOnBoarded?: Maybe<Scalars["Boolean"]>;
}

export interface IMemberMeal  extends INode {
   __typename?: "MemberMeal";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  title: Scalars["String"];
  memberId?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads and enables pagination through a set of `MealItem`. */
  mealItemsByMealId: IMealItemsConnection;
  /** Reads and enables pagination through a set of `NutritionDayMeal`. */
  nutritionDayMealsByMealId: INutritionDayMealsConnection;
  /** Reads and enables pagination through a set of `MemberRecipe`. */
  memberRecipesByMealId: IMemberRecipesConnection;
  nutritionFacts?: Maybe<INutritionFact>;
}

export interface IMemberMealMealItemsByMealIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMealItemsOrderBy[]>;
  condition?: Maybe<IMealItemCondition>;
}

export interface IMemberMealNutritionDayMealsByMealIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
  condition?: Maybe<INutritionDayMealCondition>;
}

export interface IMemberMealMemberRecipesByMealIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
  condition?: Maybe<IMemberRecipeCondition>;
}

/**
 * A condition to be used against `MemberMeal` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IMemberMealCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `MemberMeal` */
export interface IMemberMealInput {
  id?: Maybe<Scalars["Uuid"]>;
  title: Scalars["String"];
  memberId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `MemberMeal`. Fields that are set will be updated. */
export interface IMemberMealPatch {
  id?: Maybe<Scalars["Uuid"]>;
  title?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `MemberMeal` values. */
export interface IMemberMealsConnection {
   __typename?: "MemberMealsConnection";
  /** A list of `MemberMeal` objects. */
  nodes: Array<Maybe<IMemberMeal>>;
  /** A list of edges which contains the `MemberMeal` and cursor to aid in pagination. */
  edges: IMemberMealsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberMeal` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberMeal` edge in the connection. */
export interface IMemberMealsEdge {
   __typename?: "MemberMealsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberMeal` at the end of the edge. */
  node?: Maybe<IMemberMeal>;
}

/** Methods to use when ordering `MemberMeal`. */
export enum IMemberMealsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TitleAsc = "TITLE_ASC",
  TitleDesc = "TITLE_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  AuthorIdAsc = "AUTHOR_ID_ASC",
  AuthorIdDesc = "AUTHOR_ID_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberMeasurementsHistoryItem {
   __typename?: "MemberMeasurementsHistoryItem";
  date?: Maybe<Scalars["Date"]>;
  avgScore?: Maybe<Scalars["BigFloat"]>;
}

/** A connection to a list of `MemberMeasurementsHistoryItem` values. */
export interface IMemberMeasurementsHistoryItemsConnection {
   __typename?: "MemberMeasurementsHistoryItemsConnection";
  /** A list of `MemberMeasurementsHistoryItem` objects. */
  nodes: Array<Maybe<IMemberMeasurementsHistoryItem>>;
  /** A list of edges which contains the `MemberMeasurementsHistoryItem` and cursor to aid in pagination. */
  edges: IMemberMeasurementsHistoryItemsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberMeasurementsHistoryItem` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberMeasurementsHistoryItem` edge in the connection. */
export interface IMemberMeasurementsHistoryItemsEdge {
   __typename?: "MemberMeasurementsHistoryItemsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberMeasurementsHistoryItem` at the end of the edge. */
  node?: Maybe<IMemberMeasurementsHistoryItem>;
}

export interface IMemberMetric  extends INode {
   __typename?: "MemberMetric";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  key: IMetricKey;
  value: Scalars["Float"];
  min?: Maybe<Scalars["Int"]>;
  max?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  parts?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
  /** Reads a single `Member` that is related to this `MemberMetric`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberMetric` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberMetricCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<IMetricKey>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `min` field. */
  min?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `max` field. */
  max?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `parts` field. */
  parts?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `MemberMetric` */
export interface IMemberMetricInput {
  id?: Maybe<Scalars["Int"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  key: IMetricKey;
  value: Scalars["Float"];
  min?: Maybe<Scalars["Int"]>;
  max?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  parts?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `MemberMetric`. Fields that are set will be updated. */
export interface IMemberMetricPatch {
  id?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  key?: Maybe<IMetricKey>;
  value?: Maybe<Scalars["Float"]>;
  min?: Maybe<Scalars["Int"]>;
  max?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  parts?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `MemberMetric` values. */
export interface IMemberMetricsConnection {
   __typename?: "MemberMetricsConnection";
  /** A list of `MemberMetric` objects. */
  nodes: Array<Maybe<IMemberMetric>>;
  /** A list of edges which contains the `MemberMetric` and cursor to aid in pagination. */
  edges: IMemberMetricsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberMetric` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberMetric` edge in the connection. */
export interface IMemberMetricsEdge {
   __typename?: "MemberMetricsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberMetric` at the end of the edge. */
  node?: Maybe<IMemberMetric>;
}

/** Methods to use when ordering `MemberMetric`. */
export enum IMemberMetricsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  KeyAsc = "KEY_ASC",
  KeyDesc = "KEY_DESC",
  ValueAsc = "VALUE_ASC",
  ValueDesc = "VALUE_DESC",
  MinAsc = "MIN_ASC",
  MinDesc = "MIN_DESC",
  MaxAsc = "MAX_ASC",
  MaxDesc = "MAX_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PartsAsc = "PARTS_ASC",
  PartsDesc = "PARTS_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberMyFood  extends INode {
   __typename?: "MemberMyFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  title?: Maybe<Scalars["String"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  isConverted: Scalars["Boolean"];
  /** Reads a single `Member` that is related to this `MemberMyFood`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberMyFood` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberMyFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `calories` field. */
  calories?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `protein` field. */
  protein?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `fat` field. */
  fat?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `carbs` field. */
  carbs?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `fibre` field. */
  fibre?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `alcohol` field. */
  alcohol?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `isConverted` field. */
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** An input for mutations affecting `MemberMyFood` */
export interface IMemberMyFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  title?: Maybe<Scalars["String"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** Represents an update to a `MemberMyFood`. Fields that are set will be updated. */
export interface IMemberMyFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  calories?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  title?: Maybe<Scalars["String"]>;
  fibre?: Maybe<Scalars["Float"]>;
  alcohol?: Maybe<Scalars["Float"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `MemberMyFood` values. */
export interface IMemberMyFoodsConnection {
   __typename?: "MemberMyFoodsConnection";
  /** A list of `MemberMyFood` objects. */
  nodes: Array<Maybe<IMemberMyFood>>;
  /** A list of edges which contains the `MemberMyFood` and cursor to aid in pagination. */
  edges: IMemberMyFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberMyFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberMyFood` edge in the connection. */
export interface IMemberMyFoodsEdge {
   __typename?: "MemberMyFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberMyFood` at the end of the edge. */
  node?: Maybe<IMemberMyFood>;
}

/** Methods to use when ordering `MemberMyFood`. */
export enum IMemberMyFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  CaloriesAsc = "CALORIES_ASC",
  CaloriesDesc = "CALORIES_DESC",
  ProteinAsc = "PROTEIN_ASC",
  ProteinDesc = "PROTEIN_DESC",
  FatAsc = "FAT_ASC",
  FatDesc = "FAT_DESC",
  CarbsAsc = "CARBS_ASC",
  CarbsDesc = "CARBS_DESC",
  TitleAsc = "TITLE_ASC",
  TitleDesc = "TITLE_DESC",
  FibreAsc = "FIBRE_ASC",
  FibreDesc = "FIBRE_DESC",
  AlcoholAsc = "ALCOHOL_ASC",
  AlcoholDesc = "ALCOHOL_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  IsConvertedAsc = "IS_CONVERTED_ASC",
  IsConvertedDesc = "IS_CONVERTED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberNutritionHistoryItem {
   __typename?: "MemberNutritionHistoryItem";
  id?: Maybe<Scalars["Uuid"]>;
  date?: Maybe<Scalars["Date"]>;
  actual?: Maybe<INutritionInfo>;
  target?: Maybe<INutritionInfo>;
}

/** A connection to a list of `MemberNutritionHistoryItem` values. */
export interface IMemberNutritionHistoryItemsConnection {
   __typename?: "MemberNutritionHistoryItemsConnection";
  /** A list of `MemberNutritionHistoryItem` objects. */
  nodes: Array<Maybe<IMemberNutritionHistoryItem>>;
  /** A list of edges which contains the `MemberNutritionHistoryItem` and cursor to aid in pagination. */
  edges: IMemberNutritionHistoryItemsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberNutritionHistoryItem` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberNutritionHistoryItem` edge in the connection. */
export interface IMemberNutritionHistoryItemsEdge {
   __typename?: "MemberNutritionHistoryItemsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberNutritionHistoryItem` at the end of the edge. */
  node?: Maybe<IMemberNutritionHistoryItem>;
}

export interface IMemberNutritionMetric  extends INode {
   __typename?: "MemberNutritionMetric";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  body: Scalars["Json"];
  profileBody?: Maybe<Scalars["Json"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberNutritionMetric`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberNutritionMetric` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberNutritionMetricCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `profileBody` field. */
  profileBody?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberNutritionMetric` */
export interface IMemberNutritionMetricInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  body: Scalars["Json"];
  profileBody?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberNutritionMetric`. Fields that are set will be updated. */
export interface IMemberNutritionMetricPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  body?: Maybe<Scalars["Json"]>;
  profileBody?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberNutritionMetric` values. */
export interface IMemberNutritionMetricsConnection {
   __typename?: "MemberNutritionMetricsConnection";
  /** A list of `MemberNutritionMetric` objects. */
  nodes: Array<Maybe<IMemberNutritionMetric>>;
  /** A list of edges which contains the `MemberNutritionMetric` and cursor to aid in pagination. */
  edges: IMemberNutritionMetricsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberNutritionMetric` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberNutritionMetric` edge in the connection. */
export interface IMemberNutritionMetricsEdge {
   __typename?: "MemberNutritionMetricsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberNutritionMetric` at the end of the edge. */
  node?: Maybe<IMemberNutritionMetric>;
}

/** Methods to use when ordering `MemberNutritionMetric`. */
export enum IMemberNutritionMetricsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  BodyAsc = "BODY_ASC",
  BodyDesc = "BODY_DESC",
  ProfileBodyAsc = "PROFILE_BODY_ASC",
  ProfileBodyDesc = "PROFILE_BODY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberNutritionOverview {
   __typename?: "MemberNutritionOverview";
  date?: Maybe<Scalars["Date"]>;
  goal?: Maybe<Scalars["String"]>;
  cals?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `MemberNutritionOverview` values. */
export interface IMemberNutritionOverviewsConnection {
   __typename?: "MemberNutritionOverviewsConnection";
  /** A list of `MemberNutritionOverview` objects. */
  nodes: Array<Maybe<IMemberNutritionOverview>>;
  /** A list of edges which contains the `MemberNutritionOverview` and cursor to aid in pagination. */
  edges: IMemberNutritionOverviewsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberNutritionOverview` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberNutritionOverview` edge in the connection. */
export interface IMemberNutritionOverviewsEdge {
   __typename?: "MemberNutritionOverviewsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberNutritionOverview` at the end of the edge. */
  node?: Maybe<IMemberNutritionOverview>;
}

export interface IMemberNutritionPlan  extends INode {
   __typename?: "MemberNutritionPlan";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  nutritionPlanId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  startDate: Scalars["Date"];
  endDate?: Maybe<Scalars["Date"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberNutritionPlan`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `NutritionPlan` that is related to this `MemberNutritionPlan`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
}

/**
 * A condition to be used against `MemberNutritionPlan` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberNutritionPlanCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `nutritionPlanId` field. */
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberNutritionPlan` */
export interface IMemberNutritionPlanInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  nutritionPlanId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  startDate: Scalars["Date"];
  endDate?: Maybe<Scalars["Date"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberNutritionPlan`. Fields that are set will be updated. */
export interface IMemberNutritionPlanPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  notes?: Maybe<Scalars["String"]>;
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberNutritionPlan` values. */
export interface IMemberNutritionPlansConnection {
   __typename?: "MemberNutritionPlansConnection";
  /** A list of `MemberNutritionPlan` objects. */
  nodes: Array<Maybe<IMemberNutritionPlan>>;
  /** A list of edges which contains the `MemberNutritionPlan` and cursor to aid in pagination. */
  edges: IMemberNutritionPlansEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberNutritionPlan` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberNutritionPlan` edge in the connection. */
export interface IMemberNutritionPlansEdge {
   __typename?: "MemberNutritionPlansEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberNutritionPlan` at the end of the edge. */
  node?: Maybe<IMemberNutritionPlan>;
}

/** Methods to use when ordering `MemberNutritionPlan`. */
export enum IMemberNutritionPlansOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  NutritionPlanIdAsc = "NUTRITION_PLAN_ID_ASC",
  NutritionPlanIdDesc = "NUTRITION_PLAN_ID_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  StartDateAsc = "START_DATE_ASC",
  StartDateDesc = "START_DATE_DESC",
  EndDateAsc = "END_DATE_ASC",
  EndDateDesc = "END_DATE_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `Member`. Fields that are set will be updated. */
export interface IMemberPatch {
  /** The primary unique identifier for the member. */
  id?: Maybe<Scalars["Int"]>;
  userId?: Maybe<Scalars["Int"]>;
  locationId?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  /** The member’s first name. */
  firstName?: Maybe<Scalars["String"]>;
  /** The member’s last name. */
  lastName?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** The time this member was created. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  goalSummary?: Maybe<Scalars["String"]>;
  checkedInAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  defaultKsOrgId?: Maybe<Scalars["String"]>;
  defaultKsClubId?: Maybe<Scalars["String"]>;
  status?: Maybe<IPersonStatus>;
  /** Member goal: lose weight / get tuned / build muscle / ... */
  goal?: Maybe<Scalars["String"]>;
  /** For collecting initial profile data in the app (on boarding screen) */
  isOnBoarded?: Maybe<Scalars["Boolean"]>;
}

export interface IMemberRecentFood  extends INode {
   __typename?: "MemberRecentFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  fatSecretId?: Maybe<Scalars["Int"]>;
  label: Scalars["String"];
  macroEntryId?: Maybe<IMacroEntryId>;
  entry: Scalars["Json"];
  frequency: Scalars["Int"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  myFoodId?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  isConverted: Scalars["Boolean"];
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
}

/**
 * A condition to be used against `MemberRecentFood` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberRecentFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `fatSecretId` field. */
  fatSecretId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `macroEntryId` field. */
  macroEntryId?: Maybe<IMacroEntryIdInput>;
  /** Checks for equality with the object’s `entry` field. */
  entry?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `myFoodId` field. */
  myFoodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `isConverted` field. */
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** An input for mutations affecting `MemberRecentFood` */
export interface IMemberRecentFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  fatSecretId?: Maybe<Scalars["Int"]>;
  label: Scalars["String"];
  macroEntryId?: Maybe<IMacroEntryIdInput>;
  entry: Scalars["Json"];
  frequency: Scalars["Int"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** Represents an update to a `MemberRecentFood`. Fields that are set will be updated. */
export interface IMemberRecentFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  fatSecretId?: Maybe<Scalars["Int"]>;
  label?: Maybe<Scalars["String"]>;
  macroEntryId?: Maybe<IMacroEntryIdInput>;
  entry?: Maybe<Scalars["Json"]>;
  frequency?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  isConverted?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `MemberRecentFood` values. */
export interface IMemberRecentFoodsConnection {
   __typename?: "MemberRecentFoodsConnection";
  /** A list of `MemberRecentFood` objects. */
  nodes: Array<Maybe<IMemberRecentFood>>;
  /** A list of edges which contains the `MemberRecentFood` and cursor to aid in pagination. */
  edges: IMemberRecentFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberRecentFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberRecentFood` edge in the connection. */
export interface IMemberRecentFoodsEdge {
   __typename?: "MemberRecentFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberRecentFood` at the end of the edge. */
  node?: Maybe<IMemberRecentFood>;
}

/** Methods to use when ordering `MemberRecentFood`. */
export enum IMemberRecentFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  FatSecretIdAsc = "FAT_SECRET_ID_ASC",
  FatSecretIdDesc = "FAT_SECRET_ID_DESC",
  LabelAsc = "LABEL_ASC",
  LabelDesc = "LABEL_DESC",
  MacroEntryIdAsc = "MACRO_ENTRY_ID_ASC",
  MacroEntryIdDesc = "MACRO_ENTRY_ID_DESC",
  EntryAsc = "ENTRY_ASC",
  EntryDesc = "ENTRY_DESC",
  FrequencyAsc = "FREQUENCY_ASC",
  FrequencyDesc = "FREQUENCY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MyFoodIdAsc = "MY_FOOD_ID_ASC",
  MyFoodIdDesc = "MY_FOOD_ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  IsConvertedAsc = "IS_CONVERTED_ASC",
  IsConvertedDesc = "IS_CONVERTED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberRecipe  extends INode {
   __typename?: "MemberRecipe";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  mealId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  servingsNum: Scalars["Float"];
  totalTime?: Maybe<Scalars["Int"]>;
  prepareTime?: Maybe<Scalars["Int"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberRecipe`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `MemberMeal` that is related to this `MemberRecipe`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** Reads and enables pagination through a set of `MemberEvaluatedRecipe`. */
  memberEvaluatedRecipesByRecipeId: IMemberEvaluatedRecipesConnection;
}

export interface IMemberRecipeMemberEvaluatedRecipesByRecipeIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
  condition?: Maybe<IMemberEvaluatedRecipeCondition>;
}

/**
 * A condition to be used against `MemberRecipe` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberRecipeCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `servingsNum` field. */
  servingsNum?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `totalTime` field. */
  totalTime?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `prepareTime` field. */
  prepareTime?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `meta` field. */
  meta?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberRecipe` */
export interface IMemberRecipeInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  mealId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  servingsNum?: Maybe<Scalars["Float"]>;
  totalTime?: Maybe<Scalars["Int"]>;
  prepareTime?: Maybe<Scalars["Int"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberRecipe`. Fields that are set will be updated. */
export interface IMemberRecipePatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  mealId?: Maybe<Scalars["Uuid"]>;
  notes?: Maybe<Scalars["String"]>;
  servingsNum?: Maybe<Scalars["Float"]>;
  totalTime?: Maybe<Scalars["Int"]>;
  prepareTime?: Maybe<Scalars["Int"]>;
  meta?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberRecipe` values. */
export interface IMemberRecipesConnection {
   __typename?: "MemberRecipesConnection";
  /** A list of `MemberRecipe` objects. */
  nodes: Array<Maybe<IMemberRecipe>>;
  /** A list of edges which contains the `MemberRecipe` and cursor to aid in pagination. */
  edges: IMemberRecipesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberRecipe` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberRecipe` edge in the connection. */
export interface IMemberRecipesEdge {
   __typename?: "MemberRecipesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberRecipe` at the end of the edge. */
  node?: Maybe<IMemberRecipe>;
}

/** Methods to use when ordering `MemberRecipe`. */
export enum IMemberRecipesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  MealIdAsc = "MEAL_ID_ASC",
  MealIdDesc = "MEAL_ID_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  ServingsNumAsc = "SERVINGS_NUM_ASC",
  ServingsNumDesc = "SERVINGS_NUM_DESC",
  TotalTimeAsc = "TOTAL_TIME_ASC",
  TotalTimeDesc = "TOTAL_TIME_DESC",
  PrepareTimeAsc = "PREPARE_TIME_ASC",
  PrepareTimeDesc = "PREPARE_TIME_DESC",
  MetaAsc = "META_ASC",
  MetaDesc = "META_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberReminder  extends INode {
   __typename?: "MemberReminder";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  coachId: Scalars["Int"];
  date: Scalars["Date"];
  type: IMemberReminderType;
  title?: Maybe<Scalars["String"]>;
  message?: Maybe<Scalars["String"]>;
  seen: Scalars["Boolean"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberReminder`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Coach` that is related to this `MemberReminder`. */
  coachByCoachId?: Maybe<ICoach>;
}

/**
 * A condition to be used against `MemberReminder` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberReminderCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<IMemberReminderType>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `seen` field. */
  seen?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberReminder` */
export interface IMemberReminderInput {
  id?: Maybe<Scalars["Uuid"]>;
  memberId: Scalars["Int"];
  coachId: Scalars["Int"];
  date: Scalars["Date"];
  type?: Maybe<IMemberReminderType>;
  title?: Maybe<Scalars["String"]>;
  message?: Maybe<Scalars["String"]>;
  seen?: Maybe<Scalars["Boolean"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberReminder`. Fields that are set will be updated. */
export interface IMemberReminderPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  type?: Maybe<IMemberReminderType>;
  title?: Maybe<Scalars["String"]>;
  message?: Maybe<Scalars["String"]>;
  seen?: Maybe<Scalars["Boolean"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberReminder` values. */
export interface IMemberRemindersConnection {
   __typename?: "MemberRemindersConnection";
  /** A list of `MemberReminder` objects. */
  nodes: Array<Maybe<IMemberReminder>>;
  /** A list of edges which contains the `MemberReminder` and cursor to aid in pagination. */
  edges: IMemberRemindersEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberReminder` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberReminder` edge in the connection. */
export interface IMemberRemindersEdge {
   __typename?: "MemberRemindersEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberReminder` at the end of the edge. */
  node?: Maybe<IMemberReminder>;
}

/** Methods to use when ordering `MemberReminder`. */
export enum IMemberRemindersOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  TitleAsc = "TITLE_ASC",
  TitleDesc = "TITLE_DESC",
  MessageAsc = "MESSAGE_ASC",
  MessageDesc = "MESSAGE_DESC",
  SeenAsc = "SEEN_ASC",
  SeenDesc = "SEEN_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IMemberReminderType {
  General = "GENERAL",
  Nutrition = "NUTRITION",
  Training = "TRAINING",
  Measurements = "MEASUREMENTS",
  Feelings = "FEELINGS",
  Report = "REPORT",
  Transfer = "TRANSFER",
}

export interface IMemberReservation {
   __typename?: "MemberReservation";
  className?: Maybe<Scalars["String"]>;
  day?: Maybe<Scalars["Int"]>;
  time?: Maybe<Scalars["Time"]>;
  classId?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  requestId?: Maybe<Scalars["Uuid"]>;
  type?: Maybe<IReservationType>;
  status?: Maybe<IReservationStatus>;
  date?: Maybe<Scalars["Date"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberReservation` values. */
export interface IMemberReservationsConnection {
   __typename?: "MemberReservationsConnection";
  /** A list of `MemberReservation` objects. */
  nodes: Array<Maybe<IMemberReservation>>;
  /** A list of edges which contains the `MemberReservation` and cursor to aid in pagination. */
  edges: IMemberReservationsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberReservation` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberReservation` edge in the connection. */
export interface IMemberReservationsEdge {
   __typename?: "MemberReservationsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberReservation` at the end of the edge. */
  node?: Maybe<IMemberReservation>;
}

/** A connection to a list of `Member` values. */
export interface IMembersConnection {
   __typename?: "MembersConnection";
  /** A list of `Member` objects. */
  nodes: Array<Maybe<IMember>>;
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: IMembersEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Member` edge in the connection. */
export interface IMembersEdge {
   __typename?: "MembersEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Member` at the end of the edge. */
  node?: Maybe<IMember>;
}

/** Methods to use when ordering `Member`. */
export enum IMembersOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  LocationIdAsc = "LOCATION_ID_ASC",
  LocationIdDesc = "LOCATION_ID_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  FirstNameAsc = "FIRST_NAME_ASC",
  FirstNameDesc = "FIRST_NAME_DESC",
  LastNameAsc = "LAST_NAME_ASC",
  LastNameDesc = "LAST_NAME_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  GoalSummaryAsc = "GOAL_SUMMARY_ASC",
  GoalSummaryDesc = "GOAL_SUMMARY_DESC",
  CheckedInAtAsc = "CHECKED_IN_AT_ASC",
  CheckedInAtDesc = "CHECKED_IN_AT_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  DefaultKsOrgIdAsc = "DEFAULT_KS_ORG_ID_ASC",
  DefaultKsOrgIdDesc = "DEFAULT_KS_ORG_ID_DESC",
  DefaultKsClubIdAsc = "DEFAULT_KS_CLUB_ID_ASC",
  DefaultKsClubIdDesc = "DEFAULT_KS_CLUB_ID_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  GoalAsc = "GOAL_ASC",
  GoalDesc = "GOAL_DESC",
  IsOnBoardedAsc = "IS_ON_BOARDED_ASC",
  IsOnBoardedDesc = "IS_ON_BOARDED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberStepsMetric  extends INode {
   __typename?: "MemberStepsMetric";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  value: Scalars["Int"];
  updatedAt: Scalars["Datetime"];
  /** Reads a single `Member` that is related to this `MemberStepsMetric`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberStepsMetric` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberStepsMetricCondition {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MemberStepsMetric` */
export interface IMemberStepsMetricInput {
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  value?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MemberStepsMetric`. Fields that are set will be updated. */
export interface IMemberStepsMetricPatch {
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MemberStepsMetric` values. */
export interface IMemberStepsMetricsConnection {
   __typename?: "MemberStepsMetricsConnection";
  /** A list of `MemberStepsMetric` objects. */
  nodes: Array<Maybe<IMemberStepsMetric>>;
  /** A list of edges which contains the `MemberStepsMetric` and cursor to aid in pagination. */
  edges: IMemberStepsMetricsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberStepsMetric` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberStepsMetric` edge in the connection. */
export interface IMemberStepsMetricsEdge {
   __typename?: "MemberStepsMetricsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberStepsMetric` at the end of the edge. */
  node?: Maybe<IMemberStepsMetric>;
}

/** Methods to use when ordering `MemberStepsMetric`. */
export enum IMemberStepsMetricsOrderBy {
  Natural = "NATURAL",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  ValueAsc = "VALUE_ASC",
  ValueDesc = "VALUE_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberTag {
   __typename?: "MemberTag";
  memberId: Scalars["Int"];
  tagId: Scalars["Int"];
  /** Reads a single `Member` that is related to this `MemberTag`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Tag` that is related to this `MemberTag`. */
  tagByTagId?: Maybe<ITag>;
}

/**
 * A condition to be used against `MemberTag` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IMemberTagCondition {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars["Int"]>;
}

/** An input for mutations affecting `MemberTag` */
export interface IMemberTagInput {
  memberId: Scalars["Int"];
  tagId: Scalars["Int"];
}

/** A connection to a list of `MemberTag` values. */
export interface IMemberTagsConnection {
   __typename?: "MemberTagsConnection";
  /** A list of `MemberTag` objects. */
  nodes: Array<Maybe<IMemberTag>>;
  /** A list of edges which contains the `MemberTag` and cursor to aid in pagination. */
  edges: IMemberTagsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberTag` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberTag` edge in the connection. */
export interface IMemberTagsEdge {
   __typename?: "MemberTagsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberTag` at the end of the edge. */
  node?: Maybe<IMemberTag>;
}

/** Methods to use when ordering `MemberTag`. */
export enum IMemberTagsOrderBy {
  Natural = "NATURAL",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  TagIdAsc = "TAG_ID_ASC",
  TagIdDesc = "TAG_ID_DESC",
}

export interface IMemberTrainingPlanAssignment {
   __typename?: "MemberTrainingPlanAssignment";
  assignmentId?: Maybe<Scalars["Uuid"]>;
  trainingPlanId?: Maybe<Scalars["Uuid"]>;
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  daysLeft?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
}

export interface IMemberTrainingProgram  extends INode {
   __typename?: "MemberTrainingProgram";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  memberId?: Maybe<Scalars["Int"]>;
  trainingProgramId: Scalars["Int"];
  startDate: Scalars["Date"];
  createdAt: Scalars["Datetime"];
  id: Scalars["Uuid"];
  duration?: Maybe<Scalars["Int"]>;
  endDate?: Maybe<Scalars["Date"]>;
  /** Reads a single `Member` that is related to this `MemberTrainingProgram`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `TrainingProgram` that is related to this `MemberTrainingProgram`. */
  trainingProgramByTrainingProgramId?: Maybe<ITrainingProgram>;
}

/**
 * A condition to be used against `MemberTrainingProgram` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberTrainingProgramCondition {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `trainingProgramId` field. */
  trainingProgramId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: Maybe<Scalars["Date"]>;
}

/** An input for mutations affecting `MemberTrainingProgram` */
export interface IMemberTrainingProgramInput {
  memberId?: Maybe<Scalars["Int"]>;
  trainingProgramId: Scalars["Int"];
  startDate: Scalars["Date"];
  createdAt?: Maybe<Scalars["Datetime"]>;
  id?: Maybe<Scalars["Uuid"]>;
  duration?: Maybe<Scalars["Int"]>;
  endDate?: Maybe<Scalars["Date"]>;
}

/** Represents an update to a `MemberTrainingProgram`. Fields that are set will be updated. */
export interface IMemberTrainingProgramPatch {
  memberId?: Maybe<Scalars["Int"]>;
  trainingProgramId?: Maybe<Scalars["Int"]>;
  startDate?: Maybe<Scalars["Date"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  id?: Maybe<Scalars["Uuid"]>;
  duration?: Maybe<Scalars["Int"]>;
  endDate?: Maybe<Scalars["Date"]>;
}

/** A connection to a list of `MemberTrainingProgram` values. */
export interface IMemberTrainingProgramsConnection {
   __typename?: "MemberTrainingProgramsConnection";
  /** A list of `MemberTrainingProgram` objects. */
  nodes: Array<Maybe<IMemberTrainingProgram>>;
  /** A list of edges which contains the `MemberTrainingProgram` and cursor to aid in pagination. */
  edges: IMemberTrainingProgramsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberTrainingProgram` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberTrainingProgram` edge in the connection. */
export interface IMemberTrainingProgramsEdge {
   __typename?: "MemberTrainingProgramsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberTrainingProgram` at the end of the edge. */
  node?: Maybe<IMemberTrainingProgram>;
}

/** Methods to use when ordering `MemberTrainingProgram`. */
export enum IMemberTrainingProgramsOrderBy {
  Natural = "NATURAL",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  TrainingProgramIdAsc = "TRAINING_PROGRAM_ID_ASC",
  TrainingProgramIdDesc = "TRAINING_PROGRAM_ID_DESC",
  StartDateAsc = "START_DATE_ASC",
  StartDateDesc = "START_DATE_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  DurationAsc = "DURATION_ASC",
  DurationDesc = "DURATION_DESC",
  EndDateAsc = "END_DATE_ASC",
  EndDateDesc = "END_DATE_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberWaterMetric  extends INode {
   __typename?: "MemberWaterMetric";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id?: Maybe<Scalars["Uuid"]>;
  date: Scalars["Date"];
  memberId: Scalars["Int"];
  value: Scalars["Int"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  volume?: Maybe<Scalars["Int"]>;
  /** Reads a single `Member` that is related to this `MemberWaterMetric`. */
  memberByMemberId?: Maybe<IMember>;
}

/**
 * A condition to be used against `MemberWaterMetric` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberWaterMetricCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: Maybe<Scalars["Int"]>;
}

/** An input for mutations affecting `MemberWaterMetric` */
export interface IMemberWaterMetricInput {
  id?: Maybe<Scalars["Uuid"]>;
  date: Scalars["Date"];
  memberId: Scalars["Int"];
  value: Scalars["Int"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  volume?: Maybe<Scalars["Int"]>;
}

/** Represents an update to a `MemberWaterMetric`. Fields that are set will be updated. */
export interface IMemberWaterMetricPatch {
  id?: Maybe<Scalars["Uuid"]>;
  date?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
  value?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  volume?: Maybe<Scalars["Int"]>;
}

/** A connection to a list of `MemberWaterMetric` values. */
export interface IMemberWaterMetricsConnection {
   __typename?: "MemberWaterMetricsConnection";
  /** A list of `MemberWaterMetric` objects. */
  nodes: Array<Maybe<IMemberWaterMetric>>;
  /** A list of edges which contains the `MemberWaterMetric` and cursor to aid in pagination. */
  edges: IMemberWaterMetricsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberWaterMetric` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberWaterMetric` edge in the connection. */
export interface IMemberWaterMetricsEdge {
   __typename?: "MemberWaterMetricsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberWaterMetric` at the end of the edge. */
  node?: Maybe<IMemberWaterMetric>;
}

/** Methods to use when ordering `MemberWaterMetric`. */
export enum IMemberWaterMetricsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  ValueAsc = "VALUE_ASC",
  ValueDesc = "VALUE_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  VolumeAsc = "VOLUME_ASC",
  VolumeDesc = "VOLUME_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberWorkout  extends INode {
   __typename?: "MemberWorkout";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  workoutBody: Scalars["Json"];
  configBody?: Maybe<Scalars["Json"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  workoutId?: Maybe<Scalars["Uuid"]>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads and enables pagination through a set of `WorkoutExerciseAttempt`. */
  workoutExerciseAttemptsByMemberWorkoutId: IWorkoutExerciseAttemptsConnection;
  version?: Maybe<Scalars["Int"]>;
  workoutName?: Maybe<Scalars["String"]>;
}

export interface IMemberWorkoutWorkoutExerciseAttemptsByMemberWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExerciseAttemptsOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseAttemptCondition>;
}

/**
 * A condition to be used against `MemberWorkout` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMemberWorkoutCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `workoutBody` field. */
  workoutBody?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `configBody` field. */
  configBody?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `workoutId` field. */
  workoutId?: Maybe<Scalars["Uuid"]>;
}

/** An input for mutations affecting `MemberWorkout` */
export interface IMemberWorkoutInput {
  id: Scalars["Uuid"];
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  workoutBody: Scalars["Json"];
  configBody?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
}

/** Represents an update to a `MemberWorkout`. Fields that are set will be updated. */
export interface IMemberWorkoutPatch {
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  workoutBody?: Maybe<Scalars["Json"]>;
  configBody?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `MemberWorkout` values. */
export interface IMemberWorkoutsConnection {
   __typename?: "MemberWorkoutsConnection";
  /** A list of `MemberWorkout` objects. */
  nodes: Array<Maybe<IMemberWorkout>>;
  /** A list of edges which contains the `MemberWorkout` and cursor to aid in pagination. */
  edges: IMemberWorkoutsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MemberWorkout` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MemberWorkout` edge in the connection. */
export interface IMemberWorkoutsEdge {
   __typename?: "MemberWorkoutsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MemberWorkout` at the end of the edge. */
  node?: Maybe<IMemberWorkout>;
}

/** Methods to use when ordering `MemberWorkout`. */
export enum IMemberWorkoutsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  WorkoutBodyAsc = "WORKOUT_BODY_ASC",
  WorkoutBodyDesc = "WORKOUT_BODY_DESC",
  ConfigBodyAsc = "CONFIG_BODY_ASC",
  ConfigBodyDesc = "CONFIG_BODY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  WorkoutIdAsc = "WORKOUT_ID_ASC",
  WorkoutIdDesc = "WORKOUT_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMemberWorkoutTemplateInput {
  /** ID of template to be saved */
  id: Scalars["ID"];
  /** Name of template */
  name: Scalars["String"];
  /** Workout graph */
  model: Scalars["String"];
  /** Difficulty (any text) */
  difficulty?: Maybe<Scalars["String"]>;
  /** Duration in minutes */
  duration?: Maybe<Scalars["Int"]>;
  /** Notes */
  notes?: Maybe<Scalars["String"]>;
}

export interface IMentorEvent  extends INode {
   __typename?: "MentorEvent";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  uuid: Scalars["Int"];
  type: IMentorEventType;
  body: Scalars["Json"];
  createdAt: Scalars["Datetime"];
}

/**
 * A condition to be used against `MentorEvent` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IMentorEventCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<IMentorEventType>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MentorEvent` */
export interface IMentorEventInput {
  id?: Maybe<Scalars["Int"]>;
  uuid: Scalars["Int"];
  type: IMentorEventType;
  body: Scalars["Json"];
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MentorEvent`. Fields that are set will be updated. */
export interface IMentorEventPatch {
  id?: Maybe<Scalars["Int"]>;
  uuid?: Maybe<Scalars["Int"]>;
  type?: Maybe<IMentorEventType>;
  body?: Maybe<Scalars["Json"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MentorEvent` values. */
export interface IMentorEventsConnection {
   __typename?: "MentorEventsConnection";
  /** A list of `MentorEvent` objects. */
  nodes: Array<Maybe<IMentorEvent>>;
  /** A list of edges which contains the `MentorEvent` and cursor to aid in pagination. */
  edges: IMentorEventsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MentorEvent` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MentorEvent` edge in the connection. */
export interface IMentorEventsEdge {
   __typename?: "MentorEventsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MentorEvent` at the end of the edge. */
  node?: Maybe<IMentorEvent>;
}

/** Methods to use when ordering `MentorEvent`. */
export enum IMentorEventsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  UuidAsc = "UUID_ASC",
  UuidDesc = "UUID_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  BodyAsc = "BODY_ASC",
  BodyDesc = "BODY_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IMentorEventType {
  NutritionUpdate = "NUTRITION_UPDATE",
  TrainingProgramUpdate = "TRAINING_PROGRAM_UPDATE",
  MemberCheckedIn = "MEMBER_CHECKED_IN",
  TrainingProgramAssign = "TRAINING_PROGRAM_ASSIGN",
  TrainingProgramUnassign = "TRAINING_PROGRAM_UNASSIGN",
}

export interface IMentoringReport  extends INode {
   __typename?: "MentoringReport";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  coachId: Scalars["Int"];
  memberId: Scalars["Int"];
  /** The first date of report (including this date) */
  startDate: Scalars["Date"];
  /** The last date of report (including this date) */
  endDate: Scalars["Date"];
  /** Unique token for member access to report on the member portal */
  token: Scalars["String"];
  /** A theme title coach chose for report */
  theme?: Maybe<Scalars["String"]>;
  /** Report have been seen by member */
  seen: Scalars["Boolean"];
  createdAt: Scalars["Datetime"];
  updatedAt: Scalars["Datetime"];
  /** Coach notes */
  introNotes?: Maybe<Scalars["String"]>;
  /** Reads a single `Coach` that is related to this `MentoringReport`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads a single `Member` that is related to this `MentoringReport`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads and enables pagination through a set of `MentoringReportMessage`. */
  mentoringReportMessagesByMentoringReportId: IMentoringReportMessagesConnection;
}

export interface IMentoringReportMentoringReportMessagesByMentoringReportIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
  condition?: Maybe<IMentoringReportMessageCondition>;
}

/**
 * A condition to be used against `MentoringReport` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IMentoringReportCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `token` field. */
  token?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `theme` field. */
  theme?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `seen` field. */
  seen?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `introNotes` field. */
  introNotes?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `MentoringReport` */
export interface IMentoringReportInput {
  id?: Maybe<Scalars["Uuid"]>;
  coachId: Scalars["Int"];
  memberId: Scalars["Int"];
  /** The first date of report (including this date) */
  startDate: Scalars["Date"];
  /** The last date of report (including this date) */
  endDate: Scalars["Date"];
  /** Unique token for member access to report on the member portal */
  token: Scalars["String"];
  /** A theme title coach chose for report */
  theme?: Maybe<Scalars["String"]>;
  /** Report have been seen by member */
  seen?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Coach notes */
  introNotes?: Maybe<Scalars["String"]>;
}

export interface IMentoringReportMessage  extends INode {
   __typename?: "MentoringReportMessage";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  mentoringReportId: Scalars["Uuid"];
  type: IMentoringReportMessageType;
  /** Coach notes */
  message?: Maybe<Scalars["String"]>;
  /** Whether show or hide this report part */
  isHidden: Scalars["Boolean"];
  createdAt: Scalars["Datetime"];
  updatedAt: Scalars["Datetime"];
  /** Reads a single `MentoringReport` that is related to this `MentoringReportMessage`. */
  mentoringReportByMentoringReportId?: Maybe<IMentoringReport>;
}

/**
 * A condition to be used against `MentoringReportMessage` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IMentoringReportMessageCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `mentoringReportId` field. */
  mentoringReportId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<IMentoringReportMessageType>;
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isHidden` field. */
  isHidden?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `MentoringReportMessage` */
export interface IMentoringReportMessageInput {
  id?: Maybe<Scalars["Uuid"]>;
  mentoringReportId: Scalars["Uuid"];
  type: IMentoringReportMessageType;
  /** Coach notes */
  message?: Maybe<Scalars["String"]>;
  /** Whether show or hide this report part */
  isHidden?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `MentoringReportMessage`. Fields that are set will be updated. */
export interface IMentoringReportMessagePatch {
  id?: Maybe<Scalars["Uuid"]>;
  mentoringReportId?: Maybe<Scalars["Uuid"]>;
  type?: Maybe<IMentoringReportMessageType>;
  /** Coach notes */
  message?: Maybe<Scalars["String"]>;
  /** Whether show or hide this report part */
  isHidden?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `MentoringReportMessage` values. */
export interface IMentoringReportMessagesConnection {
   __typename?: "MentoringReportMessagesConnection";
  /** A list of `MentoringReportMessage` objects. */
  nodes: Array<Maybe<IMentoringReportMessage>>;
  /** A list of edges which contains the `MentoringReportMessage` and cursor to aid in pagination. */
  edges: IMentoringReportMessagesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MentoringReportMessage` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MentoringReportMessage` edge in the connection. */
export interface IMentoringReportMessagesEdge {
   __typename?: "MentoringReportMessagesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MentoringReportMessage` at the end of the edge. */
  node?: Maybe<IMentoringReportMessage>;
}

/** Methods to use when ordering `MentoringReportMessage`. */
export enum IMentoringReportMessagesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MentoringReportIdAsc = "MENTORING_REPORT_ID_ASC",
  MentoringReportIdDesc = "MENTORING_REPORT_ID_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  MessageAsc = "MESSAGE_ASC",
  MessageDesc = "MESSAGE_DESC",
  IsHiddenAsc = "IS_HIDDEN_ASC",
  IsHiddenDesc = "IS_HIDDEN_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IMentoringReportMessageType {
  Nutrition = "NUTRITION",
  Training = "TRAINING",
  Measurements = "MEASUREMENTS",
  Feelings = "FEELINGS",
}

/** Represents an update to a `MentoringReport`. Fields that are set will be updated. */
export interface IMentoringReportPatch {
  id?: Maybe<Scalars["Uuid"]>;
  coachId?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  /** The first date of report (including this date) */
  startDate?: Maybe<Scalars["Date"]>;
  /** The last date of report (including this date) */
  endDate?: Maybe<Scalars["Date"]>;
  /** Unique token for member access to report on the member portal */
  token?: Maybe<Scalars["String"]>;
  /** A theme title coach chose for report */
  theme?: Maybe<Scalars["String"]>;
  /** Report have been seen by member */
  seen?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Coach notes */
  introNotes?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `MentoringReport` values. */
export interface IMentoringReportsConnection {
   __typename?: "MentoringReportsConnection";
  /** A list of `MentoringReport` objects. */
  nodes: Array<Maybe<IMentoringReport>>;
  /** A list of edges which contains the `MentoringReport` and cursor to aid in pagination. */
  edges: IMentoringReportsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MentoringReport` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MentoringReport` edge in the connection. */
export interface IMentoringReportsEdge {
   __typename?: "MentoringReportsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MentoringReport` at the end of the edge. */
  node?: Maybe<IMentoringReport>;
}

/** Methods to use when ordering `MentoringReport`. */
export enum IMentoringReportsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  StartDateAsc = "START_DATE_ASC",
  StartDateDesc = "START_DATE_DESC",
  EndDateAsc = "END_DATE_ASC",
  EndDateDesc = "END_DATE_DESC",
  TokenAsc = "TOKEN_ASC",
  TokenDesc = "TOKEN_DESC",
  ThemeAsc = "THEME_ASC",
  ThemeDesc = "THEME_DESC",
  SeenAsc = "SEEN_ASC",
  SeenDesc = "SEEN_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  IntroNotesAsc = "INTRO_NOTES_ASC",
  IntroNotesDesc = "INTRO_NOTES_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IMetricAverage {
   __typename?: "MetricAverage";
  name?: Maybe<IMetricKey>;
  avg?: Maybe<Scalars["Float"]>;
  delta?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `MetricAverage` values. */
export interface IMetricAveragesConnection {
   __typename?: "MetricAveragesConnection";
  /** A list of `MetricAverage` objects. */
  nodes: Array<Maybe<IMetricAverage>>;
  /** A list of edges which contains the `MetricAverage` and cursor to aid in pagination. */
  edges: IMetricAveragesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `MetricAverage` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `MetricAverage` edge in the connection. */
export interface IMetricAveragesEdge {
   __typename?: "MetricAveragesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `MetricAverage` at the end of the edge. */
  node?: Maybe<IMetricAverage>;
}

export interface IMetricByIntervalPayload {
   __typename?: "MetricByIntervalPayload";
  /** Total number of metric values */
  totalCount: Scalars["Int"];
  /** List of available metric values */
  nodes: IShortMetricValue[];
}

export enum IMetricKey {
  ProgressPicture = "PROGRESS_PICTURE",
  Nutrition = "NUTRITION",
  Training = "TRAINING",
  StressOptimization = "STRESS_OPTIMIZATION",
  Sleep = "SLEEP",
  BodyWeight = "BODY_WEIGHT",
  Bfp = "BFP",
  Smm = "SMM",
  SkinFolds = "SKIN_FOLDS",
  Circumference = "CIRCUMFERENCE",
  Motivation = "MOTIVATION",
  Gratitude = "GRATITUDE",
  Bfm = "BFM",
  Steps = "STEPS",
  SleepHours = "SLEEP_HOURS",
  BloodPressure = "BLOOD_PRESSURE",
  MenstrualDay = "MENSTRUAL_DAY",
  HeartRate = "HEART_RATE",
  HeartRateVar = "HEART_RATE_VAR",
  BodyTemp = "BODY_TEMP",
}

export interface IMetricsTimelineDay {
   __typename?: "MetricsTimelineDay";
  date: Scalars["NaiveDate"];
  metrics?: Maybe<IUserMetricDay>;
  progressPictures: IProgressPicturesConnection;
}

export interface IMetricsTimelinePayload {
   __typename?: "MetricsTimelinePayload";
  totalCount: Scalars["Int"];
  nodes: IMetricsTimelineDay[];
  hasNextPage: Scalars["Boolean"];
}

export interface IMoveWorkoutTemplateDirectoryInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of directory to move */
  dirId: Scalars["ID"];
  /** ID of destination dir or none if move to root */
  destinationDirId?: Maybe<Scalars["ID"]>;
}

export interface IMoveWorkoutTemplateDirectoryPayload {
   __typename?: "MoveWorkoutTemplateDirectoryPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated workout template directory */
  workoutTemplateDirectory: IWorkoutTemplateDirectory;
}

export interface IMoveWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of template to move */
  templateId: Scalars["ID"];
  /** ID of destination dir or none if move to root */
  destinationDirId?: Maybe<Scalars["ID"]>;
}

export interface IMoveWorkoutTemplatePayload {
   __typename?: "MoveWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated workout template directory */
  workoutTemplate: IWorkoutTemplate;
}

export interface IMutation {
   __typename?: "Mutation";
  /** FOOD PORTAL */
  submitBarcodeRequest: ISubmitBarcodeRequestPayload;
  acceptFood: Scalars["String"];
  upsertProfilePicture: IProfilePictureResponse;
  deleteProfilePicture?: Maybe<Scalars["String"]>;
  /** Creates a single `Coach`. */
  createCoach?: Maybe<ICreateCoachPayload>;
  /** Creates a single `Exercise`. */
  createExercise?: Maybe<ICreateExercisePayload>;
  /** Creates a single `ExerciseOverride`. */
  createExerciseOverride?: Maybe<ICreateExerciseOverridePayload>;
  /** Creates a single `FavouriteFood`. */
  createFavouriteFood?: Maybe<ICreateFavouriteFoodPayload>;
  /** Creates a single `Food`. */
  createFood?: Maybe<ICreateFoodPayload>;
  /** Creates a single `HistoryAction`. */
  createHistoryAction?: Maybe<ICreateHistoryActionPayload>;
  /** Creates a single `Location`. */
  createLocation?: Maybe<ICreateLocationPayload>;
  /** Creates a single `Manager`. */
  createManager?: Maybe<ICreateManagerPayload>;
  /** Creates a single `ManagerClubOrg`. */
  createManagerClubOrg?: Maybe<ICreateManagerClubOrgPayload>;
  /** Creates a single `MealItem`. */
  createMealItem?: Maybe<ICreateMealItemPayload>;
  /** Creates a single `Member`. */
  createMember?: Maybe<ICreateMemberPayload>;
  /** Creates a single `MemberCheckin`. */
  createMemberCheckin?: Maybe<ICreateMemberCheckinPayload>;
  /** Creates a single `MemberEvaluatedRecipe`. */
  createMemberEvaluatedRecipe?: Maybe<ICreateMemberEvaluatedRecipePayload>;
  /** Creates a single `MemberFavouriteFood`. */
  createMemberFavouriteFood?: Maybe<ICreateMemberFavouriteFoodPayload>;
  /** Creates a single `MemberMeal`. */
  createMemberMeal?: Maybe<ICreateMemberMealPayload>;
  /** Creates a single `MemberMetric`. */
  createMemberMetric?: Maybe<ICreateMemberMetricPayload>;
  /** Creates a single `MemberMyFood`. */
  createMemberMyFood?: Maybe<ICreateMemberMyFoodPayload>;
  /** Creates a single `MemberNutritionMetric`. */
  createMemberNutritionMetric?: Maybe<ICreateMemberNutritionMetricPayload>;
  /** Creates a single `MemberNutritionPlan`. */
  createMemberNutritionPlan?: Maybe<ICreateMemberNutritionPlanPayload>;
  /** Creates a single `MemberRecentFood`. */
  createMemberRecentFood?: Maybe<ICreateMemberRecentFoodPayload>;
  /** Creates a single `MemberRecipe`. */
  createMemberRecipe?: Maybe<ICreateMemberRecipePayload>;
  /** Creates a single `MemberReminder`. */
  createMemberReminder?: Maybe<ICreateMemberReminderPayload>;
  /** Creates a single `MemberStepsMetric`. */
  createMemberStepsMetric?: Maybe<ICreateMemberStepsMetricPayload>;
  /** Creates a single `MemberTag`. */
  createMemberTag?: Maybe<ICreateMemberTagPayload>;
  /** Creates a single `MemberTrainingProgram`. */
  createMemberTrainingProgram?: Maybe<ICreateMemberTrainingProgramPayload>;
  /** Creates a single `MemberWaterMetric`. */
  createMemberWaterMetric?: Maybe<ICreateMemberWaterMetricPayload>;
  /** Creates a single `MemberWorkout`. */
  createMemberWorkout?: Maybe<ICreateMemberWorkoutPayload>;
  /** Creates a single `MentorEvent`. */
  createMentorEvent?: Maybe<ICreateMentorEventPayload>;
  /** Creates a single `MentoringReport`. */
  createMentoringReport?: Maybe<ICreateMentoringReportPayload>;
  /** Creates a single `MentoringReportMessage`. */
  createMentoringReportMessage?: Maybe<ICreateMentoringReportMessagePayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<ICreateNotificationPayload>;
  /** Creates a single `NutritionDay`. */
  createNutritionDay?: Maybe<ICreateNutritionDayPayload>;
  /** Creates a single `NutritionDayMeal`. */
  createNutritionDayMeal?: Maybe<ICreateNutritionDayMealPayload>;
  /** Creates a single `NutritionPlanDay`. */
  createNutritionPlanDay?: Maybe<ICreateNutritionPlanDayPayload>;
  /** Creates a single `NutritionPlanSchedule`. */
  createNutritionPlanSchedule?: Maybe<ICreateNutritionPlanSchedulePayload>;
  /** Creates a single `NutritionProfile`. */
  createNutritionProfile?: Maybe<ICreateNutritionProfilePayload>;
  /** Creates a single `NutritionProfileMeal`. */
  createNutritionProfileMeal?: Maybe<ICreateNutritionProfileMealPayload>;
  /** Creates a single `ProgramWorkout`. */
  createProgramWorkout?: Maybe<ICreateProgramWorkoutPayload>;
  /** Creates a single `RecentFood`. */
  createRecentFood?: Maybe<ICreateRecentFoodPayload>;
  /** Creates a single `Setting`. */
  createSetting?: Maybe<ICreateSettingPayload>;
  /** Creates a single `Tag`. */
  createTag?: Maybe<ICreateTagPayload>;
  /** Creates a single `UserSetting`. */
  createUserSetting?: Maybe<ICreateUserSettingPayload>;
  /** Creates a single `Workout`. */
  createWorkout?: Maybe<ICreateWorkoutPayload>;
  /** Creates a single `WorkoutExercise`. */
  createWorkoutExercise?: Maybe<ICreateWorkoutExercisePayload>;
  /** Creates a single `WorkoutExerciseAttempt`. */
  createWorkoutExerciseAttempt?: Maybe<ICreateWorkoutExerciseAttemptPayload>;
  /** Creates a single `WorkoutNode`. */
  createWorkoutNode?: Maybe<ICreateWorkoutNodePayload>;
  /** Creates a single `Brand`. */
  createBrand?: Maybe<ICreateBrandPayload>;
  /** Creates a single `BrandBarcode`. */
  createBrandBarcode?: Maybe<ICreateBrandBarcodePayload>;
  /** Creates a single `Category`. */
  createCategory?: Maybe<ICreateCategoryPayload>;
  /** Creates a single `Composition`. */
  createComposition?: Maybe<ICreateCompositionPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<ICreateCountryPayload>;
  /** Creates a single `DataSource`. */
  createDataSource?: Maybe<ICreateDataSourcePayload>;
  /** Creates a single `FoodbankFood`. */
  createFoodbankFood?: Maybe<ICreateFoodbankFoodPayload>;
  /** Creates a single `FoodCategory`. */
  createFoodCategory?: Maybe<ICreateFoodCategoryPayload>;
  /** Creates a single `Gtin`. */
  createGtin?: Maybe<ICreateGtinPayload>;
  /** Creates a single `NutritionDictionary`. */
  createNutritionDictionary?: Maybe<ICreateNutritionDictionaryPayload>;
  /** Creates a single `FoodbankNutritionFact`. */
  createFoodbankNutritionFact?: Maybe<ICreateFoodbankNutritionFactPayload>;
  /** Creates a single `Serving`. */
  createServing?: Maybe<ICreateServingPayload>;
  /** Creates a single `Attendance`. */
  createAttendance?: Maybe<ICreateAttendancePayload>;
  /** Creates a single `AttendanceOverride`. */
  createAttendanceOverride?: Maybe<ICreateAttendanceOverridePayload>;
  /** Creates a single `Attendee`. */
  createAttendee?: Maybe<ICreateAttendeePayload>;
  /** Creates a single `AttendeeClub`. */
  createAttendeeClub?: Maybe<ICreateAttendeeClubPayload>;
  /** Creates a single `Booking`. */
  createBooking?: Maybe<ICreateBookingPayload>;
  /** Creates a single `Class`. */
  createClass?: Maybe<ICreateClassPayload>;
  /** Creates a single `ClassInstructor`. */
  createClassInstructor?: Maybe<ICreateClassInstructorPayload>;
  /** Creates a single `Club`. */
  createClub?: Maybe<ICreateClubPayload>;
  /** Creates a single `Instructor`. */
  createInstructor?: Maybe<ICreateInstructorPayload>;
  /** Creates a single `Session`. */
  createSession?: Maybe<ICreateSessionPayload>;
  /** Creates a single `SessionInstructor`. */
  createSessionInstructor?: Maybe<ICreateSessionInstructorPayload>;
  /** Creates a single `Timeslot`. */
  createTimeslot?: Maybe<ICreateTimeslotPayload>;
  /** Updates a single `Coach` using its globally unique id and a patch. */
  updateCoach?: Maybe<IUpdateCoachPayload>;
  /** Updates a single `Coach` using a unique key and a patch. */
  updateCoachById?: Maybe<IUpdateCoachPayload>;
  /** Updates a single `Exercise` using its globally unique id and a patch. */
  updateExercise?: Maybe<IUpdateExercisePayload>;
  /** Updates a single `Exercise` using a unique key and a patch. */
  updateExerciseById?: Maybe<IUpdateExercisePayload>;
  /** Updates a single `ExerciseOverride` using its globally unique id and a patch. */
  updateExerciseOverride?: Maybe<IUpdateExerciseOverridePayload>;
  /** Updates a single `ExerciseOverride` using a unique key and a patch. */
  updateExerciseOverrideByExerciseIdAndWorkspaceId?: Maybe<IUpdateExerciseOverridePayload>;
  /** Updates a single `ExerciseOverride` using a unique key and a patch. */
  updateExerciseOverrideById?: Maybe<IUpdateExerciseOverridePayload>;
  /** Updates a single `FavouriteFood` using its globally unique id and a patch. */
  updateFavouriteFood?: Maybe<IUpdateFavouriteFoodPayload>;
  /** Updates a single `FavouriteFood` using a unique key and a patch. */
  updateFavouriteFoodById?: Maybe<IUpdateFavouriteFoodPayload>;
  /** Updates a single `Food` using its globally unique id and a patch. */
  updateFood?: Maybe<IUpdateFoodPayload>;
  /** Updates a single `Food` using a unique key and a patch. */
  updateFoodById?: Maybe<IUpdateFoodPayload>;
  /** Updates a single `HistoryAction` using its globally unique id and a patch. */
  updateHistoryAction?: Maybe<IUpdateHistoryActionPayload>;
  /** Updates a single `HistoryAction` using a unique key and a patch. */
  updateHistoryActionById?: Maybe<IUpdateHistoryActionPayload>;
  /** Updates a single `Location` using its globally unique id and a patch. */
  updateLocation?: Maybe<IUpdateLocationPayload>;
  /** Updates a single `Location` using a unique key and a patch. */
  updateLocationById?: Maybe<IUpdateLocationPayload>;
  /** Updates a single `Manager` using its globally unique id and a patch. */
  updateManager?: Maybe<IUpdateManagerPayload>;
  /** Updates a single `Manager` using a unique key and a patch. */
  updateManagerById?: Maybe<IUpdateManagerPayload>;
  /** Updates a single `ManagerClubOrg` using its globally unique id and a patch. */
  updateManagerClubOrg?: Maybe<IUpdateManagerClubOrgPayload>;
  /** Updates a single `ManagerClubOrg` using a unique key and a patch. */
  updateManagerClubOrgById?: Maybe<IUpdateManagerClubOrgPayload>;
  /** Updates a single `MealItem` using its globally unique id and a patch. */
  updateMealItem?: Maybe<IUpdateMealItemPayload>;
  /** Updates a single `MealItem` using a unique key and a patch. */
  updateMealItemById?: Maybe<IUpdateMealItemPayload>;
  /** Updates a single `Member` using its globally unique id and a patch. */
  updateMember?: Maybe<IUpdateMemberPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMemberById?: Maybe<IUpdateMemberPayload>;
  /** Updates a single `MemberCheckin` using its globally unique id and a patch. */
  updateMemberCheckin?: Maybe<IUpdateMemberCheckinPayload>;
  /** Updates a single `MemberCheckin` using a unique key and a patch. */
  updateMemberCheckinById?: Maybe<IUpdateMemberCheckinPayload>;
  /** Updates a single `MemberEvaluatedRecipe` using its globally unique id and a patch. */
  updateMemberEvaluatedRecipe?: Maybe<IUpdateMemberEvaluatedRecipePayload>;
  /** Updates a single `MemberEvaluatedRecipe` using a unique key and a patch. */
  updateMemberEvaluatedRecipeById?: Maybe<IUpdateMemberEvaluatedRecipePayload>;
  /** Updates a single `MemberFavouriteFood` using its globally unique id and a patch. */
  updateMemberFavouriteFood?: Maybe<IUpdateMemberFavouriteFoodPayload>;
  /** Updates a single `MemberFavouriteFood` using a unique key and a patch. */
  updateMemberFavouriteFoodById?: Maybe<IUpdateMemberFavouriteFoodPayload>;
  /** Updates a single `MemberFavouriteFood` using a unique key and a patch. */
  updateMemberFavouriteFoodByMemberIdAndFoodId?: Maybe<IUpdateMemberFavouriteFoodPayload>;
  /** Updates a single `MemberFavouriteFood` using a unique key and a patch. */
  updateMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryId?: Maybe<IUpdateMemberFavouriteFoodPayload>;
  /** Updates a single `MemberFavouriteFood` using a unique key and a patch. */
  updateMemberFavouriteFoodByMemberIdAndMyFoodId?: Maybe<IUpdateMemberFavouriteFoodPayload>;
  /** Updates a single `MemberMeal` using its globally unique id and a patch. */
  updateMemberMeal?: Maybe<IUpdateMemberMealPayload>;
  /** Updates a single `MemberMeal` using a unique key and a patch. */
  updateMemberMealById?: Maybe<IUpdateMemberMealPayload>;
  /** Updates a single `MemberMetric` using its globally unique id and a patch. */
  updateMemberMetric?: Maybe<IUpdateMemberMetricPayload>;
  /** Updates a single `MemberMetric` using a unique key and a patch. */
  updateMemberMetricByMemberIdAndDateAndKey?: Maybe<IUpdateMemberMetricPayload>;
  /** Updates a single `MemberMyFood` using its globally unique id and a patch. */
  updateMemberMyFood?: Maybe<IUpdateMemberMyFoodPayload>;
  /** Updates a single `MemberMyFood` using a unique key and a patch. */
  updateMemberMyFoodById?: Maybe<IUpdateMemberMyFoodPayload>;
  /** Updates a single `MemberNutritionMetric` using its globally unique id and a patch. */
  updateMemberNutritionMetric?: Maybe<IUpdateMemberNutritionMetricPayload>;
  /** Updates a single `MemberNutritionMetric` using a unique key and a patch. */
  updateMemberNutritionMetricByMemberIdAndDate?: Maybe<IUpdateMemberNutritionMetricPayload>;
  /** Updates a single `MemberNutritionPlan` using its globally unique id and a patch. */
  updateMemberNutritionPlan?: Maybe<IUpdateMemberNutritionPlanPayload>;
  /** Updates a single `MemberNutritionPlan` using a unique key and a patch. */
  updateMemberNutritionPlanById?: Maybe<IUpdateMemberNutritionPlanPayload>;
  /** Updates a single `MemberRecentFood` using its globally unique id and a patch. */
  updateMemberRecentFood?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecentFood` using a unique key and a patch. */
  updateMemberRecentFoodById?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecentFood` using a unique key and a patch. */
  updateMemberRecentFoodByMemberIdAndFatSecretId?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecentFood` using a unique key and a patch. */
  updateMemberRecentFoodByMemberIdAndMacroEntryId?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecentFood` using a unique key and a patch. */
  updateMemberRecentFoodByMemberIdAndMyFoodId?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecentFood` using a unique key and a patch. */
  updateMemberRecentFoodByMemberIdAndFoodId?: Maybe<IUpdateMemberRecentFoodPayload>;
  /** Updates a single `MemberRecipe` using its globally unique id and a patch. */
  updateMemberRecipe?: Maybe<IUpdateMemberRecipePayload>;
  /** Updates a single `MemberRecipe` using a unique key and a patch. */
  updateMemberRecipeById?: Maybe<IUpdateMemberRecipePayload>;
  /** Updates a single `MemberReminder` using its globally unique id and a patch. */
  updateMemberReminder?: Maybe<IUpdateMemberReminderPayload>;
  /** Updates a single `MemberReminder` using a unique key and a patch. */
  updateMemberReminderById?: Maybe<IUpdateMemberReminderPayload>;
  /** Updates a single `MemberStepsMetric` using its globally unique id and a patch. */
  updateMemberStepsMetric?: Maybe<IUpdateMemberStepsMetricPayload>;
  /** Updates a single `MemberStepsMetric` using a unique key and a patch. */
  updateMemberStepsMetricByMemberIdAndDate?: Maybe<IUpdateMemberStepsMetricPayload>;
  /** Updates a single `MemberTrainingProgram` using its globally unique id and a patch. */
  updateMemberTrainingProgram?: Maybe<IUpdateMemberTrainingProgramPayload>;
  /** Updates a single `MemberTrainingProgram` using a unique key and a patch. */
  updateMemberTrainingProgramById?: Maybe<IUpdateMemberTrainingProgramPayload>;
  /** Updates a single `MemberWaterMetric` using its globally unique id and a patch. */
  updateMemberWaterMetric?: Maybe<IUpdateMemberWaterMetricPayload>;
  /** Updates a single `MemberWaterMetric` using a unique key and a patch. */
  updateMemberWaterMetricById?: Maybe<IUpdateMemberWaterMetricPayload>;
  /** Updates a single `MemberWaterMetric` using a unique key and a patch. */
  updateMemberWaterMetricByDateAndMemberId?: Maybe<IUpdateMemberWaterMetricPayload>;
  /** Updates a single `MemberWorkout` using its globally unique id and a patch. */
  updateMemberWorkout?: Maybe<IUpdateMemberWorkoutPayload>;
  /** Updates a single `MemberWorkout` using a unique key and a patch. */
  updateMemberWorkoutById?: Maybe<IUpdateMemberWorkoutPayload>;
  /** Updates a single `MentorEvent` using its globally unique id and a patch. */
  updateMentorEvent?: Maybe<IUpdateMentorEventPayload>;
  /** Updates a single `MentorEvent` using a unique key and a patch. */
  updateMentorEventById?: Maybe<IUpdateMentorEventPayload>;
  /** Updates a single `MentoringReport` using its globally unique id and a patch. */
  updateMentoringReport?: Maybe<IUpdateMentoringReportPayload>;
  /** Updates a single `MentoringReport` using a unique key and a patch. */
  updateMentoringReportById?: Maybe<IUpdateMentoringReportPayload>;
  /** Updates a single `MentoringReport` using a unique key and a patch. */
  updateMentoringReportByToken?: Maybe<IUpdateMentoringReportPayload>;
  /** Updates a single `MentoringReportMessage` using its globally unique id and a patch. */
  updateMentoringReportMessage?: Maybe<IUpdateMentoringReportMessagePayload>;
  /** Updates a single `MentoringReportMessage` using a unique key and a patch. */
  updateMentoringReportMessageById?: Maybe<IUpdateMentoringReportMessagePayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotification?: Maybe<IUpdateNotificationPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotificationById?: Maybe<IUpdateNotificationPayload>;
  /** Updates a single `NutritionDay` using its globally unique id and a patch. */
  updateNutritionDay?: Maybe<IUpdateNutritionDayPayload>;
  /** Updates a single `NutritionDay` using a unique key and a patch. */
  updateNutritionDayById?: Maybe<IUpdateNutritionDayPayload>;
  /** Updates a single `NutritionDayMeal` using its globally unique id and a patch. */
  updateNutritionDayMeal?: Maybe<IUpdateNutritionDayMealPayload>;
  /** Updates a single `NutritionDayMeal` using a unique key and a patch. */
  updateNutritionDayMealByNutritionDayIdAndMealId?: Maybe<IUpdateNutritionDayMealPayload>;
  /** Updates a single `NutritionPlan` using its globally unique id and a patch. */
  updateNutritionPlan?: Maybe<IUpdateNutritionPlanPayload>;
  /** Updates a single `NutritionPlan` using a unique key and a patch. */
  updateNutritionPlanById?: Maybe<IUpdateNutritionPlanPayload>;
  /** Updates a single `NutritionPlanDay` using its globally unique id and a patch. */
  updateNutritionPlanDay?: Maybe<IUpdateNutritionPlanDayPayload>;
  /** Updates a single `NutritionPlanDay` using a unique key and a patch. */
  updateNutritionPlanDayByNutritionPlanIdAndNutritionDayId?: Maybe<IUpdateNutritionPlanDayPayload>;
  /** Updates a single `NutritionPlanSchedule` using its globally unique id and a patch. */
  updateNutritionPlanSchedule?: Maybe<IUpdateNutritionPlanSchedulePayload>;
  /** Updates a single `NutritionPlanSchedule` using a unique key and a patch. */
  updateNutritionPlanScheduleByNutritionPlanIdAndOrderIndex?: Maybe<IUpdateNutritionPlanSchedulePayload>;
  /** Updates a single `NutritionProfile` using its globally unique id and a patch. */
  updateNutritionProfile?: Maybe<IUpdateNutritionProfilePayload>;
  /** Updates a single `NutritionProfile` using a unique key and a patch. */
  updateNutritionProfileById?: Maybe<IUpdateNutritionProfilePayload>;
  /** Updates a single `NutritionProfileMeal` using its globally unique id and a patch. */
  updateNutritionProfileMeal?: Maybe<IUpdateNutritionProfileMealPayload>;
  /** Updates a single `NutritionProfileMeal` using a unique key and a patch. */
  updateNutritionProfileMealById?: Maybe<IUpdateNutritionProfileMealPayload>;
  /** Updates a single `ProgramWorkout` using its globally unique id and a patch. */
  updateProgramWorkout?: Maybe<IUpdateProgramWorkoutPayload>;
  /** Updates a single `ProgramWorkout` using a unique key and a patch. */
  updateProgramWorkoutByProgramIdAndWorkoutId?: Maybe<IUpdateProgramWorkoutPayload>;
  /** Updates a single `RecentFood` using its globally unique id and a patch. */
  updateRecentFood?: Maybe<IUpdateRecentFoodPayload>;
  /** Updates a single `RecentFood` using a unique key and a patch. */
  updateRecentFoodById?: Maybe<IUpdateRecentFoodPayload>;
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSetting?: Maybe<IUpdateSettingPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSettingById?: Maybe<IUpdateSettingPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSettingByKey?: Maybe<IUpdateSettingPayload>;
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTag?: Maybe<IUpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagById?: Maybe<IUpdateTagPayload>;
  /** Updates a single `UserSetting` using its globally unique id and a patch. */
  updateUserSetting?: Maybe<IUpdateUserSettingPayload>;
  /** Updates a single `UserSetting` using a unique key and a patch. */
  updateUserSettingById?: Maybe<IUpdateUserSettingPayload>;
  /** Updates a single `WorkoutExercise` using its globally unique id and a patch. */
  updateWorkoutExercise?: Maybe<IUpdateWorkoutExercisePayload>;
  /** Updates a single `WorkoutExercise` using a unique key and a patch. */
  updateWorkoutExerciseByIdAndWorkoutIdAndExerciseId?: Maybe<IUpdateWorkoutExercisePayload>;
  /** Updates a single `WorkoutNode` using its globally unique id and a patch. */
  updateWorkoutNode?: Maybe<IUpdateWorkoutNodePayload>;
  /** Updates a single `WorkoutNode` using a unique key and a patch. */
  updateWorkoutNodeById?: Maybe<IUpdateWorkoutNodePayload>;
  /** Updates a single `WorkoutNodeEvent` using its globally unique id and a patch. */
  updateWorkoutNodeEvent?: Maybe<IUpdateWorkoutNodeEventPayload>;
  /** Updates a single `WorkoutNodeEvent` using a unique key and a patch. */
  updateWorkoutNodeEventById?: Maybe<IUpdateWorkoutNodeEventPayload>;
  /** Updates a single `Brand` using its globally unique id and a patch. */
  updateBrand?: Maybe<IUpdateBrandPayload>;
  /** Updates a single `Brand` using a unique key and a patch. */
  updateBrandById?: Maybe<IUpdateBrandPayload>;
  /** Updates a single `BrandBarcode` using its globally unique id and a patch. */
  updateBrandBarcode?: Maybe<IUpdateBrandBarcodePayload>;
  /** Updates a single `BrandBarcode` using a unique key and a patch. */
  updateBrandBarcodeByBrandIdAndGtinId?: Maybe<IUpdateBrandBarcodePayload>;
  /** Updates a single `Category` using its globally unique id and a patch. */
  updateCategory?: Maybe<IUpdateCategoryPayload>;
  /** Updates a single `Category` using a unique key and a patch. */
  updateCategoryById?: Maybe<IUpdateCategoryPayload>;
  /** Updates a single `Composition` using its globally unique id and a patch. */
  updateComposition?: Maybe<IUpdateCompositionPayload>;
  /** Updates a single `Composition` using a unique key and a patch. */
  updateCompositionByFoodId?: Maybe<IUpdateCompositionPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountry?: Maybe<IUpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountryById?: Maybe<IUpdateCountryPayload>;
  /** Updates a single `DataSource` using its globally unique id and a patch. */
  updateDataSource?: Maybe<IUpdateDataSourcePayload>;
  /** Updates a single `DataSource` using a unique key and a patch. */
  updateDataSourceById?: Maybe<IUpdateDataSourcePayload>;
  /** Updates a single `DataSource` using a unique key and a patch. */
  updateDataSourceBySourceName?: Maybe<IUpdateDataSourcePayload>;
  /** Updates a single `FoodbankFood` using its globally unique id and a patch. */
  updateFoodbankFood?: Maybe<IUpdateFoodbankFoodPayload>;
  /** Updates a single `FoodbankFood` using a unique key and a patch. */
  updateFoodbankFoodById?: Maybe<IUpdateFoodbankFoodPayload>;
  /** Updates a single `FoodCategory` using its globally unique id and a patch. */
  updateFoodCategory?: Maybe<IUpdateFoodCategoryPayload>;
  /** Updates a single `FoodCategory` using a unique key and a patch. */
  updateFoodCategoryByFoodIdAndCategoryId?: Maybe<IUpdateFoodCategoryPayload>;
  /** Updates a single `Gtin` using its globally unique id and a patch. */
  updateGtin?: Maybe<IUpdateGtinPayload>;
  /** Updates a single `Gtin` using a unique key and a patch. */
  updateGtinByFoodIdAndGtin?: Maybe<IUpdateGtinPayload>;
  /** Updates a single `NutritionDictionary` using its globally unique id and a patch. */
  updateNutritionDictionary?: Maybe<IUpdateNutritionDictionaryPayload>;
  /** Updates a single `NutritionDictionary` using a unique key and a patch. */
  updateNutritionDictionaryById?: Maybe<IUpdateNutritionDictionaryPayload>;
  /** Updates a single `FoodbankNutritionFact` using its globally unique id and a patch. */
  updateFoodbankNutritionFact?: Maybe<IUpdateFoodbankNutritionFactPayload>;
  /** Updates a single `FoodbankNutritionFact` using a unique key and a patch. */
  updateFoodbankNutritionFactByFoodId?: Maybe<IUpdateFoodbankNutritionFactPayload>;
  /** Updates a single `Serving` using its globally unique id and a patch. */
  updateServing?: Maybe<IUpdateServingPayload>;
  /** Updates a single `Serving` using a unique key and a patch. */
  updateServingById?: Maybe<IUpdateServingPayload>;
  /** Updates a single `Attendance` using its globally unique id and a patch. */
  updateAttendance?: Maybe<IUpdateAttendancePayload>;
  /** Updates a single `Attendance` using a unique key and a patch. */
  updateAttendanceBySessionIdAndPersonId?: Maybe<IUpdateAttendancePayload>;
  /** Updates a single `Attendance` using a unique key and a patch. */
  updateAttendanceById?: Maybe<IUpdateAttendancePayload>;
  /** Updates a single `AttendanceOverride` using its globally unique id and a patch. */
  updateAttendanceOverride?: Maybe<IUpdateAttendanceOverridePayload>;
  /** Updates a single `AttendanceOverride` using a unique key and a patch. */
  updateAttendanceOverrideById?: Maybe<IUpdateAttendanceOverridePayload>;
  /** Updates a single `Attendee` using its globally unique id and a patch. */
  updateAttendee?: Maybe<IUpdateAttendeePayload>;
  /** Updates a single `Attendee` using a unique key and a patch. */
  updateAttendeeById?: Maybe<IUpdateAttendeePayload>;
  /** Updates a single `AttendeeClub` using its globally unique id and a patch. */
  updateAttendeeClub?: Maybe<IUpdateAttendeeClubPayload>;
  /** Updates a single `AttendeeClub` using a unique key and a patch. */
  updateAttendeeClubByAttendeeIdAndClubId?: Maybe<IUpdateAttendeeClubPayload>;
  /** Updates a single `Booking` using its globally unique id and a patch. */
  updateBooking?: Maybe<IUpdateBookingPayload>;
  /** Updates a single `Booking` using a unique key and a patch. */
  updateBookingById?: Maybe<IUpdateBookingPayload>;
  /** Updates a single `Class` using its globally unique id and a patch. */
  updateClass?: Maybe<IUpdateClassPayload>;
  /** Updates a single `Class` using a unique key and a patch. */
  updateClassById?: Maybe<IUpdateClassPayload>;
  /** Updates a single `ClassInstructor` using its globally unique id and a patch. */
  updateClassInstructor?: Maybe<IUpdateClassInstructorPayload>;
  /** Updates a single `ClassInstructor` using a unique key and a patch. */
  updateClassInstructorByClassIdAndInstructorId?: Maybe<IUpdateClassInstructorPayload>;
  /** Updates a single `Club` using its globally unique id and a patch. */
  updateClub?: Maybe<IUpdateClubPayload>;
  /** Updates a single `Club` using a unique key and a patch. */
  updateClubById?: Maybe<IUpdateClubPayload>;
  /** Updates a single `Club` using a unique key and a patch. */
  updateClubByKsClubId?: Maybe<IUpdateClubPayload>;
  /** Updates a single `Instructor` using its globally unique id and a patch. */
  updateInstructor?: Maybe<IUpdateInstructorPayload>;
  /** Updates a single `Instructor` using a unique key and a patch. */
  updateInstructorById?: Maybe<IUpdateInstructorPayload>;
  /** Updates a single `ReservationRequest` using its globally unique id and a patch. */
  updateReservationRequest?: Maybe<IUpdateReservationRequestPayload>;
  /** Updates a single `ReservationRequest` using a unique key and a patch. */
  updateReservationRequestById?: Maybe<IUpdateReservationRequestPayload>;
  /** Updates a single `Session` using its globally unique id and a patch. */
  updateSession?: Maybe<IUpdateSessionPayload>;
  /** Updates a single `Session` using a unique key and a patch. */
  updateSessionById?: Maybe<IUpdateSessionPayload>;
  /** Updates a single `SessionInstructor` using its globally unique id and a patch. */
  updateSessionInstructor?: Maybe<IUpdateSessionInstructorPayload>;
  /** Updates a single `SessionInstructor` using a unique key and a patch. */
  updateSessionInstructorBySessionIdAndInstructorId?: Maybe<IUpdateSessionInstructorPayload>;
  /** Updates a single `Timeslot` using its globally unique id and a patch. */
  updateTimeslot?: Maybe<IUpdateTimeslotPayload>;
  /** Updates a single `Timeslot` using a unique key and a patch. */
  updateTimeslotById?: Maybe<IUpdateTimeslotPayload>;
  /** Deletes a single `Coach` using its globally unique id. */
  deleteCoach?: Maybe<IDeleteCoachPayload>;
  /** Deletes a single `Coach` using a unique key. */
  deleteCoachById?: Maybe<IDeleteCoachPayload>;
  /** Deletes a single `Exercise` using its globally unique id. */
  deleteExercise?: Maybe<IDeleteExercisePayload>;
  /** Deletes a single `Exercise` using a unique key. */
  deleteExerciseById?: Maybe<IDeleteExercisePayload>;
  /** Deletes a single `ExerciseOverride` using its globally unique id. */
  deleteExerciseOverride?: Maybe<IDeleteExerciseOverridePayload>;
  /** Deletes a single `ExerciseOverride` using a unique key. */
  deleteExerciseOverrideByExerciseIdAndWorkspaceId?: Maybe<IDeleteExerciseOverridePayload>;
  /** Deletes a single `ExerciseOverride` using a unique key. */
  deleteExerciseOverrideById?: Maybe<IDeleteExerciseOverridePayload>;
  /** Deletes a single `FavouriteFood` using its globally unique id. */
  deleteFavouriteFood?: Maybe<IDeleteFavouriteFoodPayload>;
  /** Deletes a single `FavouriteFood` using a unique key. */
  deleteFavouriteFoodById?: Maybe<IDeleteFavouriteFoodPayload>;
  /** Deletes a single `Food` using its globally unique id. */
  deleteFood?: Maybe<IDeleteFoodPayload>;
  /** Deletes a single `Food` using a unique key. */
  deleteFoodById?: Maybe<IDeleteFoodPayload>;
  /** Deletes a single `HistoryAction` using its globally unique id. */
  deleteHistoryAction?: Maybe<IDeleteHistoryActionPayload>;
  /** Deletes a single `HistoryAction` using a unique key. */
  deleteHistoryActionById?: Maybe<IDeleteHistoryActionPayload>;
  /** Deletes a single `Location` using its globally unique id. */
  deleteLocation?: Maybe<IDeleteLocationPayload>;
  /** Deletes a single `Location` using a unique key. */
  deleteLocationById?: Maybe<IDeleteLocationPayload>;
  /** Deletes a single `Manager` using its globally unique id. */
  deleteManager?: Maybe<IDeleteManagerPayload>;
  /** Deletes a single `Manager` using a unique key. */
  deleteManagerById?: Maybe<IDeleteManagerPayload>;
  /** Deletes a single `ManagerClubOrg` using its globally unique id. */
  deleteManagerClubOrg?: Maybe<IDeleteManagerClubOrgPayload>;
  /** Deletes a single `ManagerClubOrg` using a unique key. */
  deleteManagerClubOrgById?: Maybe<IDeleteManagerClubOrgPayload>;
  /** Deletes a single `MealItem` using its globally unique id. */
  deleteMealItem?: Maybe<IDeleteMealItemPayload>;
  /** Deletes a single `MealItem` using a unique key. */
  deleteMealItemById?: Maybe<IDeleteMealItemPayload>;
  /** Deletes a single `Member` using its globally unique id. */
  deleteMember?: Maybe<IDeleteMemberPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMemberById?: Maybe<IDeleteMemberPayload>;
  /** Deletes a single `MemberCheckin` using its globally unique id. */
  deleteMemberCheckin?: Maybe<IDeleteMemberCheckinPayload>;
  /** Deletes a single `MemberCheckin` using a unique key. */
  deleteMemberCheckinById?: Maybe<IDeleteMemberCheckinPayload>;
  /** Deletes a single `MemberEvaluatedRecipe` using its globally unique id. */
  deleteMemberEvaluatedRecipe?: Maybe<IDeleteMemberEvaluatedRecipePayload>;
  /** Deletes a single `MemberEvaluatedRecipe` using a unique key. */
  deleteMemberEvaluatedRecipeById?: Maybe<IDeleteMemberEvaluatedRecipePayload>;
  /** Deletes a single `MemberFavouriteFood` using its globally unique id. */
  deleteMemberFavouriteFood?: Maybe<IDeleteMemberFavouriteFoodPayload>;
  /** Deletes a single `MemberFavouriteFood` using a unique key. */
  deleteMemberFavouriteFoodById?: Maybe<IDeleteMemberFavouriteFoodPayload>;
  /** Deletes a single `MemberFavouriteFood` using a unique key. */
  deleteMemberFavouriteFoodByMemberIdAndFoodId?: Maybe<IDeleteMemberFavouriteFoodPayload>;
  /** Deletes a single `MemberFavouriteFood` using a unique key. */
  deleteMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryId?: Maybe<IDeleteMemberFavouriteFoodPayload>;
  /** Deletes a single `MemberFavouriteFood` using a unique key. */
  deleteMemberFavouriteFoodByMemberIdAndMyFoodId?: Maybe<IDeleteMemberFavouriteFoodPayload>;
  /** Deletes a single `MemberMeal` using its globally unique id. */
  deleteMemberMeal?: Maybe<IDeleteMemberMealPayload>;
  /** Deletes a single `MemberMeal` using a unique key. */
  deleteMemberMealById?: Maybe<IDeleteMemberMealPayload>;
  /** Deletes a single `MemberMetric` using its globally unique id. */
  deleteMemberMetric?: Maybe<IDeleteMemberMetricPayload>;
  /** Deletes a single `MemberMetric` using a unique key. */
  deleteMemberMetricByMemberIdAndDateAndKey?: Maybe<IDeleteMemberMetricPayload>;
  /** Deletes a single `MemberMyFood` using its globally unique id. */
  deleteMemberMyFood?: Maybe<IDeleteMemberMyFoodPayload>;
  /** Deletes a single `MemberMyFood` using a unique key. */
  deleteMemberMyFoodById?: Maybe<IDeleteMemberMyFoodPayload>;
  /** Deletes a single `MemberNutritionMetric` using its globally unique id. */
  deleteMemberNutritionMetric?: Maybe<IDeleteMemberNutritionMetricPayload>;
  /** Deletes a single `MemberNutritionMetric` using a unique key. */
  deleteMemberNutritionMetricByMemberIdAndDate?: Maybe<IDeleteMemberNutritionMetricPayload>;
  /** Deletes a single `MemberNutritionPlan` using its globally unique id. */
  deleteMemberNutritionPlan?: Maybe<IDeleteMemberNutritionPlanPayload>;
  /** Deletes a single `MemberNutritionPlan` using a unique key. */
  deleteMemberNutritionPlanById?: Maybe<IDeleteMemberNutritionPlanPayload>;
  /** Deletes a single `MemberRecentFood` using its globally unique id. */
  deleteMemberRecentFood?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecentFood` using a unique key. */
  deleteMemberRecentFoodById?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecentFood` using a unique key. */
  deleteMemberRecentFoodByMemberIdAndFatSecretId?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecentFood` using a unique key. */
  deleteMemberRecentFoodByMemberIdAndMacroEntryId?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecentFood` using a unique key. */
  deleteMemberRecentFoodByMemberIdAndMyFoodId?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecentFood` using a unique key. */
  deleteMemberRecentFoodByMemberIdAndFoodId?: Maybe<IDeleteMemberRecentFoodPayload>;
  /** Deletes a single `MemberRecipe` using its globally unique id. */
  deleteMemberRecipe?: Maybe<IDeleteMemberRecipePayload>;
  /** Deletes a single `MemberRecipe` using a unique key. */
  deleteMemberRecipeById?: Maybe<IDeleteMemberRecipePayload>;
  /** Deletes a single `MemberReminder` using its globally unique id. */
  deleteMemberReminder?: Maybe<IDeleteMemberReminderPayload>;
  /** Deletes a single `MemberReminder` using a unique key. */
  deleteMemberReminderById?: Maybe<IDeleteMemberReminderPayload>;
  /** Deletes a single `MemberStepsMetric` using its globally unique id. */
  deleteMemberStepsMetric?: Maybe<IDeleteMemberStepsMetricPayload>;
  /** Deletes a single `MemberStepsMetric` using a unique key. */
  deleteMemberStepsMetricByMemberIdAndDate?: Maybe<IDeleteMemberStepsMetricPayload>;
  /** Deletes a single `MemberTrainingProgram` using its globally unique id. */
  deleteMemberTrainingProgram?: Maybe<IDeleteMemberTrainingProgramPayload>;
  /** Deletes a single `MemberTrainingProgram` using a unique key. */
  deleteMemberTrainingProgramById?: Maybe<IDeleteMemberTrainingProgramPayload>;
  /** Deletes a single `MemberWaterMetric` using its globally unique id. */
  deleteMemberWaterMetric?: Maybe<IDeleteMemberWaterMetricPayload>;
  /** Deletes a single `MemberWaterMetric` using a unique key. */
  deleteMemberWaterMetricById?: Maybe<IDeleteMemberWaterMetricPayload>;
  /** Deletes a single `MemberWaterMetric` using a unique key. */
  deleteMemberWaterMetricByDateAndMemberId?: Maybe<IDeleteMemberWaterMetricPayload>;
  /** Deletes a single `MemberWorkout` using its globally unique id. */
  deleteMemberWorkout?: Maybe<IDeleteMemberWorkoutPayload>;
  /** Deletes a single `MemberWorkout` using a unique key. */
  deleteMemberWorkoutById?: Maybe<IDeleteMemberWorkoutPayload>;
  /** Deletes a single `MentorEvent` using its globally unique id. */
  deleteMentorEvent?: Maybe<IDeleteMentorEventPayload>;
  /** Deletes a single `MentorEvent` using a unique key. */
  deleteMentorEventById?: Maybe<IDeleteMentorEventPayload>;
  /** Deletes a single `MentoringReport` using its globally unique id. */
  deleteMentoringReport?: Maybe<IDeleteMentoringReportPayload>;
  /** Deletes a single `MentoringReport` using a unique key. */
  deleteMentoringReportById?: Maybe<IDeleteMentoringReportPayload>;
  /** Deletes a single `MentoringReport` using a unique key. */
  deleteMentoringReportByToken?: Maybe<IDeleteMentoringReportPayload>;
  /** Deletes a single `MentoringReportMessage` using its globally unique id. */
  deleteMentoringReportMessage?: Maybe<IDeleteMentoringReportMessagePayload>;
  /** Deletes a single `MentoringReportMessage` using a unique key. */
  deleteMentoringReportMessageById?: Maybe<IDeleteMentoringReportMessagePayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotification?: Maybe<IDeleteNotificationPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotificationById?: Maybe<IDeleteNotificationPayload>;
  /** Deletes a single `NutritionDay` using its globally unique id. */
  deleteNutritionDay?: Maybe<IDeleteNutritionDayPayload>;
  /** Deletes a single `NutritionDay` using a unique key. */
  deleteNutritionDayById?: Maybe<IDeleteNutritionDayPayload>;
  /** Deletes a single `NutritionDayMeal` using its globally unique id. */
  deleteNutritionDayMeal?: Maybe<IDeleteNutritionDayMealPayload>;
  /** Deletes a single `NutritionDayMeal` using a unique key. */
  deleteNutritionDayMealByNutritionDayIdAndMealId?: Maybe<IDeleteNutritionDayMealPayload>;
  /** Deletes a single `NutritionPlan` using its globally unique id. */
  deleteNutritionPlan?: Maybe<IDeleteNutritionPlanPayload>;
  /** Deletes a single `NutritionPlan` using a unique key. */
  deleteNutritionPlanById?: Maybe<IDeleteNutritionPlanPayload>;
  /** Deletes a single `NutritionPlanDay` using its globally unique id. */
  deleteNutritionPlanDay?: Maybe<IDeleteNutritionPlanDayPayload>;
  /** Deletes a single `NutritionPlanDay` using a unique key. */
  deleteNutritionPlanDayByNutritionPlanIdAndNutritionDayId?: Maybe<IDeleteNutritionPlanDayPayload>;
  /** Deletes a single `NutritionPlanSchedule` using its globally unique id. */
  deleteNutritionPlanSchedule?: Maybe<IDeleteNutritionPlanSchedulePayload>;
  /** Deletes a single `NutritionPlanSchedule` using a unique key. */
  deleteNutritionPlanScheduleByNutritionPlanIdAndOrderIndex?: Maybe<IDeleteNutritionPlanSchedulePayload>;
  /** Deletes a single `NutritionProfile` using its globally unique id. */
  deleteNutritionProfile?: Maybe<IDeleteNutritionProfilePayload>;
  /** Deletes a single `NutritionProfile` using a unique key. */
  deleteNutritionProfileById?: Maybe<IDeleteNutritionProfilePayload>;
  /** Deletes a single `NutritionProfileMeal` using its globally unique id. */
  deleteNutritionProfileMeal?: Maybe<IDeleteNutritionProfileMealPayload>;
  /** Deletes a single `NutritionProfileMeal` using a unique key. */
  deleteNutritionProfileMealById?: Maybe<IDeleteNutritionProfileMealPayload>;
  /** Deletes a single `ProgramWorkout` using its globally unique id. */
  deleteProgramWorkout?: Maybe<IDeleteProgramWorkoutPayload>;
  /** Deletes a single `ProgramWorkout` using a unique key. */
  deleteProgramWorkoutByProgramIdAndWorkoutId?: Maybe<IDeleteProgramWorkoutPayload>;
  /** Deletes a single `RecentFood` using its globally unique id. */
  deleteRecentFood?: Maybe<IDeleteRecentFoodPayload>;
  /** Deletes a single `RecentFood` using a unique key. */
  deleteRecentFoodById?: Maybe<IDeleteRecentFoodPayload>;
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSetting?: Maybe<IDeleteSettingPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSettingById?: Maybe<IDeleteSettingPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSettingByKey?: Maybe<IDeleteSettingPayload>;
  /** Deletes a single `Tag` using its globally unique id. */
  deleteTag?: Maybe<IDeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTagById?: Maybe<IDeleteTagPayload>;
  /** Deletes a single `UserSetting` using its globally unique id. */
  deleteUserSetting?: Maybe<IDeleteUserSettingPayload>;
  /** Deletes a single `UserSetting` using a unique key. */
  deleteUserSettingById?: Maybe<IDeleteUserSettingPayload>;
  /** Deletes a single `Workout` using its globally unique id. */
  deleteWorkout?: Maybe<IDeleteWorkoutPayload>;
  /** Deletes a single `Workout` using a unique key. */
  deleteWorkoutById?: Maybe<IDeleteWorkoutPayload>;
  /** Deletes a single `WorkoutExercise` using its globally unique id. */
  deleteWorkoutExercise?: Maybe<IDeleteWorkoutExercisePayload>;
  /** Deletes a single `WorkoutExercise` using a unique key. */
  deleteWorkoutExerciseByIdAndWorkoutIdAndExerciseId?: Maybe<IDeleteWorkoutExercisePayload>;
  /** Deletes a single `WorkoutNode` using its globally unique id. */
  deleteWorkoutNode?: Maybe<IDeleteWorkoutNodePayload>;
  /** Deletes a single `WorkoutNode` using a unique key. */
  deleteWorkoutNodeById?: Maybe<IDeleteWorkoutNodePayload>;
  /** Deletes a single `WorkoutNodeEvent` using its globally unique id. */
  deleteWorkoutNodeEvent?: Maybe<IDeleteWorkoutNodeEventPayload>;
  /** Deletes a single `WorkoutNodeEvent` using a unique key. */
  deleteWorkoutNodeEventById?: Maybe<IDeleteWorkoutNodeEventPayload>;
  /** Deletes a single `Brand` using its globally unique id. */
  deleteBrand?: Maybe<IDeleteBrandPayload>;
  /** Deletes a single `Brand` using a unique key. */
  deleteBrandById?: Maybe<IDeleteBrandPayload>;
  /** Deletes a single `BrandBarcode` using its globally unique id. */
  deleteBrandBarcode?: Maybe<IDeleteBrandBarcodePayload>;
  /** Deletes a single `BrandBarcode` using a unique key. */
  deleteBrandBarcodeByBrandIdAndGtinId?: Maybe<IDeleteBrandBarcodePayload>;
  /** Deletes a single `Category` using its globally unique id. */
  deleteCategory?: Maybe<IDeleteCategoryPayload>;
  /** Deletes a single `Category` using a unique key. */
  deleteCategoryById?: Maybe<IDeleteCategoryPayload>;
  /** Deletes a single `Composition` using its globally unique id. */
  deleteComposition?: Maybe<IDeleteCompositionPayload>;
  /** Deletes a single `Composition` using a unique key. */
  deleteCompositionByFoodId?: Maybe<IDeleteCompositionPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountry?: Maybe<IDeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountryById?: Maybe<IDeleteCountryPayload>;
  /** Deletes a single `DataSource` using its globally unique id. */
  deleteDataSource?: Maybe<IDeleteDataSourcePayload>;
  /** Deletes a single `DataSource` using a unique key. */
  deleteDataSourceById?: Maybe<IDeleteDataSourcePayload>;
  /** Deletes a single `DataSource` using a unique key. */
  deleteDataSourceBySourceName?: Maybe<IDeleteDataSourcePayload>;
  /** Deletes a single `FoodbankFood` using its globally unique id. */
  deleteFoodbankFood?: Maybe<IDeleteFoodbankFoodPayload>;
  /** Deletes a single `FoodbankFood` using a unique key. */
  deleteFoodbankFoodById?: Maybe<IDeleteFoodbankFoodPayload>;
  /** Deletes a single `FoodCategory` using its globally unique id. */
  deleteFoodCategory?: Maybe<IDeleteFoodCategoryPayload>;
  /** Deletes a single `FoodCategory` using a unique key. */
  deleteFoodCategoryByFoodIdAndCategoryId?: Maybe<IDeleteFoodCategoryPayload>;
  /** Deletes a single `Gtin` using its globally unique id. */
  deleteGtin?: Maybe<IDeleteGtinPayload>;
  /** Deletes a single `Gtin` using a unique key. */
  deleteGtinByFoodIdAndGtin?: Maybe<IDeleteGtinPayload>;
  /** Deletes a single `NutritionDictionary` using its globally unique id. */
  deleteNutritionDictionary?: Maybe<IDeleteNutritionDictionaryPayload>;
  /** Deletes a single `NutritionDictionary` using a unique key. */
  deleteNutritionDictionaryById?: Maybe<IDeleteNutritionDictionaryPayload>;
  /** Deletes a single `FoodbankNutritionFact` using its globally unique id. */
  deleteFoodbankNutritionFact?: Maybe<IDeleteFoodbankNutritionFactPayload>;
  /** Deletes a single `FoodbankNutritionFact` using a unique key. */
  deleteFoodbankNutritionFactByFoodId?: Maybe<IDeleteFoodbankNutritionFactPayload>;
  /** Deletes a single `Serving` using its globally unique id. */
  deleteServing?: Maybe<IDeleteServingPayload>;
  /** Deletes a single `Serving` using a unique key. */
  deleteServingById?: Maybe<IDeleteServingPayload>;
  /** Deletes a single `Attendance` using its globally unique id. */
  deleteAttendance?: Maybe<IDeleteAttendancePayload>;
  /** Deletes a single `Attendance` using a unique key. */
  deleteAttendanceBySessionIdAndPersonId?: Maybe<IDeleteAttendancePayload>;
  /** Deletes a single `Attendance` using a unique key. */
  deleteAttendanceById?: Maybe<IDeleteAttendancePayload>;
  /** Deletes a single `AttendanceOverride` using its globally unique id. */
  deleteAttendanceOverride?: Maybe<IDeleteAttendanceOverridePayload>;
  /** Deletes a single `AttendanceOverride` using a unique key. */
  deleteAttendanceOverrideById?: Maybe<IDeleteAttendanceOverridePayload>;
  /** Deletes a single `Attendee` using its globally unique id. */
  deleteAttendee?: Maybe<IDeleteAttendeePayload>;
  /** Deletes a single `Attendee` using a unique key. */
  deleteAttendeeById?: Maybe<IDeleteAttendeePayload>;
  /** Deletes a single `AttendeeClub` using its globally unique id. */
  deleteAttendeeClub?: Maybe<IDeleteAttendeeClubPayload>;
  /** Deletes a single `AttendeeClub` using a unique key. */
  deleteAttendeeClubByAttendeeIdAndClubId?: Maybe<IDeleteAttendeeClubPayload>;
  /** Deletes a single `Booking` using its globally unique id. */
  deleteBooking?: Maybe<IDeleteBookingPayload>;
  /** Deletes a single `Booking` using a unique key. */
  deleteBookingById?: Maybe<IDeleteBookingPayload>;
  /** Deletes a single `Class` using its globally unique id. */
  deleteClass?: Maybe<IDeleteClassPayload>;
  /** Deletes a single `Class` using a unique key. */
  deleteClassById?: Maybe<IDeleteClassPayload>;
  /** Deletes a single `ClassInstructor` using its globally unique id. */
  deleteClassInstructor?: Maybe<IDeleteClassInstructorPayload>;
  /** Deletes a single `ClassInstructor` using a unique key. */
  deleteClassInstructorByClassIdAndInstructorId?: Maybe<IDeleteClassInstructorPayload>;
  /** Deletes a single `Club` using its globally unique id. */
  deleteClub?: Maybe<IDeleteClubPayload>;
  /** Deletes a single `Club` using a unique key. */
  deleteClubById?: Maybe<IDeleteClubPayload>;
  /** Deletes a single `Club` using a unique key. */
  deleteClubByKsClubId?: Maybe<IDeleteClubPayload>;
  /** Deletes a single `Instructor` using its globally unique id. */
  deleteInstructor?: Maybe<IDeleteInstructorPayload>;
  /** Deletes a single `Instructor` using a unique key. */
  deleteInstructorById?: Maybe<IDeleteInstructorPayload>;
  /** Deletes a single `Session` using its globally unique id. */
  deleteSession?: Maybe<IDeleteSessionPayload>;
  /** Deletes a single `Session` using a unique key. */
  deleteSessionById?: Maybe<IDeleteSessionPayload>;
  /** Deletes a single `SessionInstructor` using its globally unique id. */
  deleteSessionInstructor?: Maybe<IDeleteSessionInstructorPayload>;
  /** Deletes a single `SessionInstructor` using a unique key. */
  deleteSessionInstructorBySessionIdAndInstructorId?: Maybe<IDeleteSessionInstructorPayload>;
  /** Deletes a single `Timeslot` using its globally unique id. */
  deleteTimeslot?: Maybe<IDeleteTimeslotPayload>;
  /** Deletes a single `Timeslot` using a unique key. */
  deleteTimeslotById?: Maybe<IDeleteTimeslotPayload>;
  acceptInvite?: Maybe<IAcceptInvitePayload>;
  activateCoach?: Maybe<IActivateCoachPayload>;
  activateMember?: Maybe<IActivateMemberPayload>;
  archiveCoach?: Maybe<IArchiveCoachPayload>;
  archiveMember?: Maybe<IArchiveMemberPayload>;
  archiveWorkout?: Maybe<IArchiveWorkoutPayload>;
  /** Reads and enables pagination through a set of `UserFeature`. */
  assignFeatures?: Maybe<IAssignFeaturesPayload>;
  /** Reads and enables pagination through a set of `Tag`. */
  assignTags?: Maybe<IAssignTagsPayload>;
  authenticate?: Maybe<IAuthenticatePayload>;
  authenticateProduct?: Maybe<IAuthenticateProductPayload>;
  changeMembersCoach?: Maybe<IChangeMembersCoachPayload>;
  changeUserCoach?: Maybe<IChangeUserCoachPayload>;
  checkinMember?: Maybe<ICheckinMemberPayload>;
  createEmptyNutritionDay?: Maybe<ICreateEmptyNutritionDayPayload>;
  createFeature?: Maybe<ICreateFeaturePayload>;
  createNewExercise?: Maybe<ICreateNewExercisePayload>;
  createNutritionPlan?: Maybe<ICreateNutritionPlanPayload>;
  createWorkoutInProgramByIdV2?: Maybe<ICreateWorkoutInProgramByIdV2Payload>;
  deleteFeatures?: Maybe<IDeleteFeaturesPayload>;
  deleteFullNutritionDay?: Maybe<IDeleteFullNutritionDayPayload>;
  deleteInsightsById?: Maybe<IDeleteInsightsByIdPayload>;
  deleteMemberMetrics?: Maybe<IDeleteMemberMetricsPayload>;
  deleteMembers?: Maybe<IDeleteMembersPayload>;
  deleteMyRecipe?: Maybe<IDeleteMyRecipePayload>;
  deleteTagFromMember?: Maybe<IDeleteTagFromMemberPayload>;
  deleteUsersFeatures?: Maybe<IDeleteUsersFeaturesPayload>;
  duplicateMeal?: Maybe<IDuplicateMealPayload>;
  duplicateNutritionDay?: Maybe<IDuplicateNutritionDayPayload>;
  duplicateNutritionPlan?: Maybe<IDuplicateNutritionPlanPayload>;
  overrideExercise?: Maybe<IOverrideExercisePayload>;
  randomString?: Maybe<IRandomStringPayload>;
  /** Reads and enables pagination through a set of `MemberReminder`. */
  readReminders?: Maybe<IReadRemindersPayload>;
  requestPasswordReset?: Maybe<IRequestPasswordResetPayload>;
  requestPasswordsReset?: Maybe<IRequestPasswordsResetPayload>;
  resetPassword?: Maybe<IResetPasswordPayload>;
  saveFavouriteFood?: Maybe<ISaveFavouriteFoodPayload>;
  saveMentoringReport?: Maybe<ISaveMentoringReportPayload>;
  saveMentoringReportMessage?: Maybe<ISaveMentoringReportMessagePayload>;
  saveMyMeal?: Maybe<ISaveMyMealPayload>;
  saveMyMealV2?: Maybe<ISaveMyMealV2Payload>;
  saveMyRecipe?: Maybe<ISaveMyRecipePayload>;
  saveNutritionDay?: Maybe<ISaveNutritionDayPayload>;
  saveNutritionDayV2?: Maybe<ISaveNutritionDayV2Payload>;
  saveNutritionPlan?: Maybe<ISaveNutritionPlanPayload>;
  /** Reads and enables pagination through a set of `RecentFood`. */
  saveRecentFoodItems?: Maybe<ISaveRecentFoodItemsPayload>;
  sendPushNotification?: Maybe<ISendPushNotificationPayload>;
  signupCoach?: Maybe<ISignupCoachPayload>;
  suspendMember?: Maybe<ISuspendMemberPayload>;
  unarchiveWorkout?: Maybe<IUnarchiveWorkoutPayload>;
  updateMemberInfo?: Maybe<IUpdateMemberInfoPayload>;
  updateMemberProfile?: Maybe<IUpdateMemberProfilePayload>;
  upsertDeviceMeta?: Maybe<IUpsertDeviceMetaPayload>;
  upsertFood?: Maybe<IUpsertFoodPayload>;
  upsertMemberMetric?: Maybe<IUpsertMemberMetricPayload>;
  upsertMemberMetricV2?: Maybe<IUpsertMemberMetricV2Payload>;
  upsertMemberNutritionMetric?: Maybe<IUpsertMemberNutritionMetricPayload>;
  upsertMemberRecentFood?: Maybe<IUpsertMemberRecentFoodPayload>;
  upsertMemberRecentFoodV2?: Maybe<IUpsertMemberRecentFoodV2Payload>;
  upsertMemberWaterMetric?: Maybe<IUpsertMemberWaterMetricPayload>;
  upsertMemberWorkout?: Maybe<IUpsertMemberWorkoutPayload>;
  upsertMemberWorkoutV2?: Maybe<IUpsertMemberWorkoutV2Payload>;
  upsertUserSetting?: Maybe<IUpsertUserSettingPayload>;
  /** Reads and enables pagination through a set of `WorkoutExercise`. */
  upsertWorkoutExercises?: Maybe<IUpsertWorkoutExercisesPayload>;
  /** Reads and enables pagination through a set of `Booking`. */
  bookAttendeesIntoTimeslots?: Maybe<IBookAttendeesIntoTimeslotsPayload>;
  /** Reads and enables pagination through a set of `Attendee`. */
  createAttendeesByUserIds?: Maybe<ICreateAttendeesByUserIdsPayload>;
  /** Reads and enables pagination through a set of `Instructor`. */
  createInstructors?: Maybe<ICreateInstructorsPayload>;
  /** Reads and enables pagination through a set of `MemberReservation`. */
  createReservationRequest?: Maybe<ICreateReservationRequestPayload>;
  createSessionByTimeslotId?: Maybe<ICreateSessionByTimeslotIdPayload>;
  deleteReservationRequestById?: Maybe<IDeleteReservationRequestByIdPayload>;
  populateSessionAttendance?: Maybe<IPopulateSessionAttendancePayload>;
  /** Reads and enables pagination through a set of `ReservationRequest`. */
  processReservations?: Maybe<IProcessReservationsPayload>;
  saveWorkoutTemplate: ISaveWorkoutTemplatePayload;
  saveMemberWorkoutTemplate: ISaveMemberWorkoutTemplatePayload;
  cloneWorkoutTemplate: ICloneWorkoutTemplatePayload;
  deleteWorkoutTemplate: IDeleteWorkoutTemplatePayload;
  shareWorkoutTemplate: IShareWorkoutTemplatePayload;
  updateWorkoutTemplateSharing: IUpdateWorkoutTemplateSharingPayload;
  assignWorkoutTemplates: IAssignWorkoutTemplatesPayload;
  deleteWorkoutTemplateAssignments: IDeleteWorkoutTemplateAssignmentsPayload;
  deleteWorkoutTemplateSharingById: IDeleteWorkoutTemplateSharingPayload;
  saveWorkoutSession: ISaveWorkoutSessionPayload;
  deleteWorkoutSession: IDeleteWorkoutSessionPayload;
  saveTrainingPlan: ISaveTrainingPlanPayload;
  deleteTrainingPlan: IDeleteTrainingPlanPayload;
  shareTrainingPlan: IShareTrainingPlanPayload;
  updateTrainingPlanSharing: IUpdateTrainingPlanSharingPayload;
  assignTrainingPlan: IAssignWorkoutTemplatesPayload;
  deleteTrainingPlanAssignments: IDeleteTrainingPlanAssignmentsPayload;
  cloneTrainingPlan: ICloneTrainingPlanPayload;
  deleteTrainingPlanSharingById: IDeleteTrainingPlanSharingPayload;
  createWorkoutTemplateDirectory: ICreateWorkoutTemplateDirectoryPayload;
  updateWorkoutTemplateDirectory: IUpdateWorkoutTemplateDirectoryPayload;
  deleteWorkoutTemplateDirectory: IDeleteWorkoutTemplateDirectoryPayload;
  moveWorkoutTemplateDirectory: IMoveWorkoutTemplateDirectoryPayload;
  moveWorkoutTemplate: IMoveWorkoutTemplatePayload;
  convertTrainingProgram: IConvertTrainingProgramPayload;
  createTrainingProgram: ICreateTrainingProgramPayload;
  duplicateProgramById: IDuplicateProgramByIdPayload;
  updateTrainingProgramById: IUpdateTrainingProgramByIdPayload;
  deleteTrainingProgramById: IDeleteTrainingProgramByIdPayload;
  createWorkoutInProgramById: ICreateWorkoutByProgramIdPayload;
  duplicateWorkout: IDuplicateWorkoutPayload;
  updateWorkoutById: IUpdateWorkoutByIdPayload;
  createWorkoutNodeEvent: ICreateWorkoutNodeEventPayload;
  /** MEMBER */
  registerMember: IRegisterMemberPayload;
  inviteMemberByCoach: IInviteMemberByCoachPayload;
  deleteCoachMembers: IDeleteCoachMembersPayload;
  transferMembers: ITransferMembersPayload;
  /** COACH */
  registerNewCoach: IRegisterNewCoachPayload;
  /** DEVICE */
  addDeviceMeta: IAddDeviceMetaPayload;
  removeDeviceMeta: IRemoveDeviceMetaPayload;
  /** PROGRESS PICTURES */
  addProgressPicture: IAddProgressPicturePayload;
  updateProgressPicture: IUpdateProgressPicturePayload;
  deleteProgressPicture: IDeleteProgressPicturePayload;
  /** STEPS */
  updateSteps: IUpdateStepsPayload;
  deleteMetricById: IDeleteMetricByIdPayload;
  saveBodyMetrics: ISaveBodyMeasurementPayload;
  rejectBarcodeRequest: IRejectBarcodeRequestPayload;
  /** FOOD JOURNAL APP */
  createJournalDayTarget: ICreateJournalDayTargetsPayload;
  saveJournalMeal: ISaveJournalMealPayload;
  saveJournalWaterVolume: ISaveJournalWaterVolumePayload;
  addMealPhoto: IAddMealPhotoPayload;
  deleteMealPhoto: IDeleteMealPhotoPayload;
  assignJournalTargets: IAssignJournalTargetsPayload;
  deleteJournalTarget: IDeleteJournalTargetPayload;
}

export interface IMutationSubmitBarcodeRequestArgs {
  input: ISubmitBarcodeRequestInput;
}

export interface IMutationAcceptFoodArgs {
  requestId?: Maybe<Scalars["String"]>;
  food: IKeystoneFoodlakeFoodInput;
}

export interface IMutationUpsertProfilePictureArgs {
  fullSizePicture: Scalars["Upload"];
  thumbnailPicture: Scalars["Upload"];
}

export interface IMutationCreateCoachArgs {
  input: ICreateCoachInput;
}

export interface IMutationCreateExerciseArgs {
  input: ICreateExerciseInput;
}

export interface IMutationCreateExerciseOverrideArgs {
  input: ICreateExerciseOverrideInput;
}

export interface IMutationCreateFavouriteFoodArgs {
  input: ICreateFavouriteFoodInput;
}

export interface IMutationCreateFoodArgs {
  input: ICreateFoodInput;
}

export interface IMutationCreateHistoryActionArgs {
  input: ICreateHistoryActionInput;
}

export interface IMutationCreateLocationArgs {
  input: ICreateLocationInput;
}

export interface IMutationCreateManagerArgs {
  input: ICreateManagerInput;
}

export interface IMutationCreateManagerClubOrgArgs {
  input: ICreateManagerClubOrgInput;
}

export interface IMutationCreateMealItemArgs {
  input: ICreateMealItemInput;
}

export interface IMutationCreateMemberArgs {
  input: ICreateMemberInput;
}

export interface IMutationCreateMemberCheckinArgs {
  input: ICreateMemberCheckinInput;
}

export interface IMutationCreateMemberEvaluatedRecipeArgs {
  input: ICreateMemberEvaluatedRecipeInput;
}

export interface IMutationCreateMemberFavouriteFoodArgs {
  input: ICreateMemberFavouriteFoodInput;
}

export interface IMutationCreateMemberMealArgs {
  input: ICreateMemberMealInput;
}

export interface IMutationCreateMemberMetricArgs {
  input: ICreateMemberMetricInput;
}

export interface IMutationCreateMemberMyFoodArgs {
  input: ICreateMemberMyFoodInput;
}

export interface IMutationCreateMemberNutritionMetricArgs {
  input: ICreateMemberNutritionMetricInput;
}

export interface IMutationCreateMemberNutritionPlanArgs {
  input: ICreateMemberNutritionPlanInput;
}

export interface IMutationCreateMemberRecentFoodArgs {
  input: ICreateMemberRecentFoodInput;
}

export interface IMutationCreateMemberRecipeArgs {
  input: ICreateMemberRecipeInput;
}

export interface IMutationCreateMemberReminderArgs {
  input: ICreateMemberReminderInput;
}

export interface IMutationCreateMemberStepsMetricArgs {
  input: ICreateMemberStepsMetricInput;
}

export interface IMutationCreateMemberTagArgs {
  input: ICreateMemberTagInput;
}

export interface IMutationCreateMemberTrainingProgramArgs {
  input: ICreateMemberTrainingProgramInput;
}

export interface IMutationCreateMemberWaterMetricArgs {
  input: ICreateMemberWaterMetricInput;
}

export interface IMutationCreateMemberWorkoutArgs {
  input: ICreateMemberWorkoutInput;
}

export interface IMutationCreateMentorEventArgs {
  input: ICreateMentorEventInput;
}

export interface IMutationCreateMentoringReportArgs {
  input: ICreateMentoringReportInput;
}

export interface IMutationCreateMentoringReportMessageArgs {
  input: ICreateMentoringReportMessageInput;
}

export interface IMutationCreateNotificationArgs {
  input: ICreateNotificationInput;
}

export interface IMutationCreateNutritionDayArgs {
  input: ICreateNutritionDayInput;
}

export interface IMutationCreateNutritionDayMealArgs {
  input: ICreateNutritionDayMealInput;
}

export interface IMutationCreateNutritionPlanDayArgs {
  input: ICreateNutritionPlanDayInput;
}

export interface IMutationCreateNutritionPlanScheduleArgs {
  input: ICreateNutritionPlanScheduleInput;
}

export interface IMutationCreateNutritionProfileArgs {
  input: ICreateNutritionProfileInput;
}

export interface IMutationCreateNutritionProfileMealArgs {
  input: ICreateNutritionProfileMealInput;
}

export interface IMutationCreateProgramWorkoutArgs {
  input: ICreateProgramWorkoutInput;
}

export interface IMutationCreateRecentFoodArgs {
  input: ICreateRecentFoodInput;
}

export interface IMutationCreateSettingArgs {
  input: ICreateSettingInput;
}

export interface IMutationCreateTagArgs {
  input: ICreateTagInput;
}

export interface IMutationCreateUserSettingArgs {
  input: ICreateUserSettingInput;
}

export interface IMutationCreateWorkoutArgs {
  input: ICreateWorkoutInput;
}

export interface IMutationCreateWorkoutExerciseArgs {
  input: ICreateWorkoutExerciseInput;
}

export interface IMutationCreateWorkoutExerciseAttemptArgs {
  input: ICreateWorkoutExerciseAttemptInput;
}

export interface IMutationCreateWorkoutNodeArgs {
  input: ICreateWorkoutNodeInput;
}

export interface IMutationCreateBrandArgs {
  input: ICreateBrandInput;
}

export interface IMutationCreateBrandBarcodeArgs {
  input: ICreateBrandBarcodeInput;
}

export interface IMutationCreateCategoryArgs {
  input: ICreateCategoryInput;
}

export interface IMutationCreateCompositionArgs {
  input: ICreateCompositionInput;
}

export interface IMutationCreateCountryArgs {
  input: ICreateCountryInput;
}

export interface IMutationCreateDataSourceArgs {
  input: ICreateDataSourceInput;
}

export interface IMutationCreateFoodbankFoodArgs {
  input: ICreateFoodbankFoodInput;
}

export interface IMutationCreateFoodCategoryArgs {
  input: ICreateFoodCategoryInput;
}

export interface IMutationCreateGtinArgs {
  input: ICreateGtinInput;
}

export interface IMutationCreateNutritionDictionaryArgs {
  input: ICreateNutritionDictionaryInput;
}

export interface IMutationCreateFoodbankNutritionFactArgs {
  input: ICreateFoodbankNutritionFactInput;
}

export interface IMutationCreateServingArgs {
  input: ICreateServingInput;
}

export interface IMutationCreateAttendanceArgs {
  input: ICreateAttendanceInput;
}

export interface IMutationCreateAttendanceOverrideArgs {
  input: ICreateAttendanceOverrideInput;
}

export interface IMutationCreateAttendeeArgs {
  input: ICreateAttendeeInput;
}

export interface IMutationCreateAttendeeClubArgs {
  input: ICreateAttendeeClubInput;
}

export interface IMutationCreateBookingArgs {
  input: ICreateBookingInput;
}

export interface IMutationCreateClassArgs {
  input: ICreateClassInput;
}

export interface IMutationCreateClassInstructorArgs {
  input: ICreateClassInstructorInput;
}

export interface IMutationCreateClubArgs {
  input: ICreateClubInput;
}

export interface IMutationCreateInstructorArgs {
  input: ICreateInstructorInput;
}

export interface IMutationCreateSessionArgs {
  input: ICreateSessionInput;
}

export interface IMutationCreateSessionInstructorArgs {
  input: ICreateSessionInstructorInput;
}

export interface IMutationCreateTimeslotArgs {
  input: ICreateTimeslotInput;
}

export interface IMutationUpdateCoachArgs {
  input: IUpdateCoachInput;
}

export interface IMutationUpdateCoachByIdArgs {
  input: IUpdateCoachByIdInput;
}

export interface IMutationUpdateExerciseArgs {
  input: IUpdateExerciseInput;
}

export interface IMutationUpdateExerciseByIdArgs {
  input: IUpdateExerciseByIdInput;
}

export interface IMutationUpdateExerciseOverrideArgs {
  input: IUpdateExerciseOverrideInput;
}

export interface IMutationUpdateExerciseOverrideByExerciseIdAndWorkspaceIdArgs {
  input: IUpdateExerciseOverrideByExerciseIdAndWorkspaceIdInput;
}

export interface IMutationUpdateExerciseOverrideByIdArgs {
  input: IUpdateExerciseOverrideByIdInput;
}

export interface IMutationUpdateFavouriteFoodArgs {
  input: IUpdateFavouriteFoodInput;
}

export interface IMutationUpdateFavouriteFoodByIdArgs {
  input: IUpdateFavouriteFoodByIdInput;
}

export interface IMutationUpdateFoodArgs {
  input: IUpdateFoodInput;
}

export interface IMutationUpdateFoodByIdArgs {
  input: IUpdateFoodByIdInput;
}

export interface IMutationUpdateHistoryActionArgs {
  input: IUpdateHistoryActionInput;
}

export interface IMutationUpdateHistoryActionByIdArgs {
  input: IUpdateHistoryActionByIdInput;
}

export interface IMutationUpdateLocationArgs {
  input: IUpdateLocationInput;
}

export interface IMutationUpdateLocationByIdArgs {
  input: IUpdateLocationByIdInput;
}

export interface IMutationUpdateManagerArgs {
  input: IUpdateManagerInput;
}

export interface IMutationUpdateManagerByIdArgs {
  input: IUpdateManagerByIdInput;
}

export interface IMutationUpdateManagerClubOrgArgs {
  input: IUpdateManagerClubOrgInput;
}

export interface IMutationUpdateManagerClubOrgByIdArgs {
  input: IUpdateManagerClubOrgByIdInput;
}

export interface IMutationUpdateMealItemArgs {
  input: IUpdateMealItemInput;
}

export interface IMutationUpdateMealItemByIdArgs {
  input: IUpdateMealItemByIdInput;
}

export interface IMutationUpdateMemberArgs {
  input: IUpdateMemberInput;
}

export interface IMutationUpdateMemberByIdArgs {
  input: IUpdateMemberByIdInput;
}

export interface IMutationUpdateMemberCheckinArgs {
  input: IUpdateMemberCheckinInput;
}

export interface IMutationUpdateMemberCheckinByIdArgs {
  input: IUpdateMemberCheckinByIdInput;
}

export interface IMutationUpdateMemberEvaluatedRecipeArgs {
  input: IUpdateMemberEvaluatedRecipeInput;
}

export interface IMutationUpdateMemberEvaluatedRecipeByIdArgs {
  input: IUpdateMemberEvaluatedRecipeByIdInput;
}

export interface IMutationUpdateMemberFavouriteFoodArgs {
  input: IUpdateMemberFavouriteFoodInput;
}

export interface IMutationUpdateMemberFavouriteFoodByIdArgs {
  input: IUpdateMemberFavouriteFoodByIdInput;
}

export interface IMutationUpdateMemberFavouriteFoodByMemberIdAndFoodIdArgs {
  input: IUpdateMemberFavouriteFoodByMemberIdAndFoodIdInput;
}

export interface IMutationUpdateMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdArgs {
  input: IUpdateMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdInput;
}

export interface IMutationUpdateMemberFavouriteFoodByMemberIdAndMyFoodIdArgs {
  input: IUpdateMemberFavouriteFoodByMemberIdAndMyFoodIdInput;
}

export interface IMutationUpdateMemberMealArgs {
  input: IUpdateMemberMealInput;
}

export interface IMutationUpdateMemberMealByIdArgs {
  input: IUpdateMemberMealByIdInput;
}

export interface IMutationUpdateMemberMetricArgs {
  input: IUpdateMemberMetricInput;
}

export interface IMutationUpdateMemberMetricByMemberIdAndDateAndKeyArgs {
  input: IUpdateMemberMetricByMemberIdAndDateAndKeyInput;
}

export interface IMutationUpdateMemberMyFoodArgs {
  input: IUpdateMemberMyFoodInput;
}

export interface IMutationUpdateMemberMyFoodByIdArgs {
  input: IUpdateMemberMyFoodByIdInput;
}

export interface IMutationUpdateMemberNutritionMetricArgs {
  input: IUpdateMemberNutritionMetricInput;
}

export interface IMutationUpdateMemberNutritionMetricByMemberIdAndDateArgs {
  input: IUpdateMemberNutritionMetricByMemberIdAndDateInput;
}

export interface IMutationUpdateMemberNutritionPlanArgs {
  input: IUpdateMemberNutritionPlanInput;
}

export interface IMutationUpdateMemberNutritionPlanByIdArgs {
  input: IUpdateMemberNutritionPlanByIdInput;
}

export interface IMutationUpdateMemberRecentFoodArgs {
  input: IUpdateMemberRecentFoodInput;
}

export interface IMutationUpdateMemberRecentFoodByIdArgs {
  input: IUpdateMemberRecentFoodByIdInput;
}

export interface IMutationUpdateMemberRecentFoodByMemberIdAndFatSecretIdArgs {
  input: IUpdateMemberRecentFoodByMemberIdAndFatSecretIdInput;
}

export interface IMutationUpdateMemberRecentFoodByMemberIdAndMacroEntryIdArgs {
  input: IUpdateMemberRecentFoodByMemberIdAndMacroEntryIdInput;
}

export interface IMutationUpdateMemberRecentFoodByMemberIdAndMyFoodIdArgs {
  input: IUpdateMemberRecentFoodByMemberIdAndMyFoodIdInput;
}

export interface IMutationUpdateMemberRecentFoodByMemberIdAndFoodIdArgs {
  input: IUpdateMemberRecentFoodByMemberIdAndFoodIdInput;
}

export interface IMutationUpdateMemberRecipeArgs {
  input: IUpdateMemberRecipeInput;
}

export interface IMutationUpdateMemberRecipeByIdArgs {
  input: IUpdateMemberRecipeByIdInput;
}

export interface IMutationUpdateMemberReminderArgs {
  input: IUpdateMemberReminderInput;
}

export interface IMutationUpdateMemberReminderByIdArgs {
  input: IUpdateMemberReminderByIdInput;
}

export interface IMutationUpdateMemberStepsMetricArgs {
  input: IUpdateMemberStepsMetricInput;
}

export interface IMutationUpdateMemberStepsMetricByMemberIdAndDateArgs {
  input: IUpdateMemberStepsMetricByMemberIdAndDateInput;
}

export interface IMutationUpdateMemberTrainingProgramArgs {
  input: IUpdateMemberTrainingProgramInput;
}

export interface IMutationUpdateMemberTrainingProgramByIdArgs {
  input: IUpdateMemberTrainingProgramByIdInput;
}

export interface IMutationUpdateMemberWaterMetricArgs {
  input: IUpdateMemberWaterMetricInput;
}

export interface IMutationUpdateMemberWaterMetricByIdArgs {
  input: IUpdateMemberWaterMetricByIdInput;
}

export interface IMutationUpdateMemberWaterMetricByDateAndMemberIdArgs {
  input: IUpdateMemberWaterMetricByDateAndMemberIdInput;
}

export interface IMutationUpdateMemberWorkoutArgs {
  input: IUpdateMemberWorkoutInput;
}

export interface IMutationUpdateMemberWorkoutByIdArgs {
  input: IUpdateMemberWorkoutByIdInput;
}

export interface IMutationUpdateMentorEventArgs {
  input: IUpdateMentorEventInput;
}

export interface IMutationUpdateMentorEventByIdArgs {
  input: IUpdateMentorEventByIdInput;
}

export interface IMutationUpdateMentoringReportArgs {
  input: IUpdateMentoringReportInput;
}

export interface IMutationUpdateMentoringReportByIdArgs {
  input: IUpdateMentoringReportByIdInput;
}

export interface IMutationUpdateMentoringReportByTokenArgs {
  input: IUpdateMentoringReportByTokenInput;
}

export interface IMutationUpdateMentoringReportMessageArgs {
  input: IUpdateMentoringReportMessageInput;
}

export interface IMutationUpdateMentoringReportMessageByIdArgs {
  input: IUpdateMentoringReportMessageByIdInput;
}

export interface IMutationUpdateNotificationArgs {
  input: IUpdateNotificationInput;
}

export interface IMutationUpdateNotificationByIdArgs {
  input: IUpdateNotificationByIdInput;
}

export interface IMutationUpdateNutritionDayArgs {
  input: IUpdateNutritionDayInput;
}

export interface IMutationUpdateNutritionDayByIdArgs {
  input: IUpdateNutritionDayByIdInput;
}

export interface IMutationUpdateNutritionDayMealArgs {
  input: IUpdateNutritionDayMealInput;
}

export interface IMutationUpdateNutritionDayMealByNutritionDayIdAndMealIdArgs {
  input: IUpdateNutritionDayMealByNutritionDayIdAndMealIdInput;
}

export interface IMutationUpdateNutritionPlanArgs {
  input: IUpdateNutritionPlanInput;
}

export interface IMutationUpdateNutritionPlanByIdArgs {
  input: IUpdateNutritionPlanByIdInput;
}

export interface IMutationUpdateNutritionPlanDayArgs {
  input: IUpdateNutritionPlanDayInput;
}

export interface IMutationUpdateNutritionPlanDayByNutritionPlanIdAndNutritionDayIdArgs {
  input: IUpdateNutritionPlanDayByNutritionPlanIdAndNutritionDayIdInput;
}

export interface IMutationUpdateNutritionPlanScheduleArgs {
  input: IUpdateNutritionPlanScheduleInput;
}

export interface IMutationUpdateNutritionPlanScheduleByNutritionPlanIdAndOrderIndexArgs {
  input: IUpdateNutritionPlanScheduleByNutritionPlanIdAndOrderIndexInput;
}

export interface IMutationUpdateNutritionProfileArgs {
  input: IUpdateNutritionProfileInput;
}

export interface IMutationUpdateNutritionProfileByIdArgs {
  input: IUpdateNutritionProfileByIdInput;
}

export interface IMutationUpdateNutritionProfileMealArgs {
  input: IUpdateNutritionProfileMealInput;
}

export interface IMutationUpdateNutritionProfileMealByIdArgs {
  input: IUpdateNutritionProfileMealByIdInput;
}

export interface IMutationUpdateProgramWorkoutArgs {
  input: IUpdateProgramWorkoutInput;
}

export interface IMutationUpdateProgramWorkoutByProgramIdAndWorkoutIdArgs {
  input: IUpdateProgramWorkoutByProgramIdAndWorkoutIdInput;
}

export interface IMutationUpdateRecentFoodArgs {
  input: IUpdateRecentFoodInput;
}

export interface IMutationUpdateRecentFoodByIdArgs {
  input: IUpdateRecentFoodByIdInput;
}

export interface IMutationUpdateSettingArgs {
  input: IUpdateSettingInput;
}

export interface IMutationUpdateSettingByIdArgs {
  input: IUpdateSettingByIdInput;
}

export interface IMutationUpdateSettingByKeyArgs {
  input: IUpdateSettingByKeyInput;
}

export interface IMutationUpdateTagArgs {
  input: IUpdateTagInput;
}

export interface IMutationUpdateTagByIdArgs {
  input: IUpdateTagByIdInput;
}

export interface IMutationUpdateUserSettingArgs {
  input: IUpdateUserSettingInput;
}

export interface IMutationUpdateUserSettingByIdArgs {
  input: IUpdateUserSettingByIdInput;
}

export interface IMutationUpdateWorkoutExerciseArgs {
  input: IUpdateWorkoutExerciseInput;
}

export interface IMutationUpdateWorkoutExerciseByIdAndWorkoutIdAndExerciseIdArgs {
  input: IUpdateWorkoutExerciseByIdAndWorkoutIdAndExerciseIdInput;
}

export interface IMutationUpdateWorkoutNodeArgs {
  input: IUpdateWorkoutNodeInput;
}

export interface IMutationUpdateWorkoutNodeByIdArgs {
  input: IUpdateWorkoutNodeByIdInput;
}

export interface IMutationUpdateWorkoutNodeEventArgs {
  input: IUpdateWorkoutNodeEventInput;
}

export interface IMutationUpdateWorkoutNodeEventByIdArgs {
  input: IUpdateWorkoutNodeEventByIdInput;
}

export interface IMutationUpdateBrandArgs {
  input: IUpdateBrandInput;
}

export interface IMutationUpdateBrandByIdArgs {
  input: IUpdateBrandByIdInput;
}

export interface IMutationUpdateBrandBarcodeArgs {
  input: IUpdateBrandBarcodeInput;
}

export interface IMutationUpdateBrandBarcodeByBrandIdAndGtinIdArgs {
  input: IUpdateBrandBarcodeByBrandIdAndGtinIdInput;
}

export interface IMutationUpdateCategoryArgs {
  input: IUpdateCategoryInput;
}

export interface IMutationUpdateCategoryByIdArgs {
  input: IUpdateCategoryByIdInput;
}

export interface IMutationUpdateCompositionArgs {
  input: IUpdateCompositionInput;
}

export interface IMutationUpdateCompositionByFoodIdArgs {
  input: IUpdateCompositionByFoodIdInput;
}

export interface IMutationUpdateCountryArgs {
  input: IUpdateCountryInput;
}

export interface IMutationUpdateCountryByIdArgs {
  input: IUpdateCountryByIdInput;
}

export interface IMutationUpdateDataSourceArgs {
  input: IUpdateDataSourceInput;
}

export interface IMutationUpdateDataSourceByIdArgs {
  input: IUpdateDataSourceByIdInput;
}

export interface IMutationUpdateDataSourceBySourceNameArgs {
  input: IUpdateDataSourceBySourceNameInput;
}

export interface IMutationUpdateFoodbankFoodArgs {
  input: IUpdateFoodbankFoodInput;
}

export interface IMutationUpdateFoodbankFoodByIdArgs {
  input: IUpdateFoodbankFoodByIdInput;
}

export interface IMutationUpdateFoodCategoryArgs {
  input: IUpdateFoodCategoryInput;
}

export interface IMutationUpdateFoodCategoryByFoodIdAndCategoryIdArgs {
  input: IUpdateFoodCategoryByFoodIdAndCategoryIdInput;
}

export interface IMutationUpdateGtinArgs {
  input: IUpdateGtinInput;
}

export interface IMutationUpdateGtinByFoodIdAndGtinArgs {
  input: IUpdateGtinByFoodIdAndGtinInput;
}

export interface IMutationUpdateNutritionDictionaryArgs {
  input: IUpdateNutritionDictionaryInput;
}

export interface IMutationUpdateNutritionDictionaryByIdArgs {
  input: IUpdateNutritionDictionaryByIdInput;
}

export interface IMutationUpdateFoodbankNutritionFactArgs {
  input: IUpdateFoodbankNutritionFactInput;
}

export interface IMutationUpdateFoodbankNutritionFactByFoodIdArgs {
  input: IUpdateFoodbankNutritionFactByFoodIdInput;
}

export interface IMutationUpdateServingArgs {
  input: IUpdateServingInput;
}

export interface IMutationUpdateServingByIdArgs {
  input: IUpdateServingByIdInput;
}

export interface IMutationUpdateAttendanceArgs {
  input: IUpdateAttendanceInput;
}

export interface IMutationUpdateAttendanceBySessionIdAndPersonIdArgs {
  input: IUpdateAttendanceBySessionIdAndPersonIdInput;
}

export interface IMutationUpdateAttendanceByIdArgs {
  input: IUpdateAttendanceByIdInput;
}

export interface IMutationUpdateAttendanceOverrideArgs {
  input: IUpdateAttendanceOverrideInput;
}

export interface IMutationUpdateAttendanceOverrideByIdArgs {
  input: IUpdateAttendanceOverrideByIdInput;
}

export interface IMutationUpdateAttendeeArgs {
  input: IUpdateAttendeeInput;
}

export interface IMutationUpdateAttendeeByIdArgs {
  input: IUpdateAttendeeByIdInput;
}

export interface IMutationUpdateAttendeeClubArgs {
  input: IUpdateAttendeeClubInput;
}

export interface IMutationUpdateAttendeeClubByAttendeeIdAndClubIdArgs {
  input: IUpdateAttendeeClubByAttendeeIdAndClubIdInput;
}

export interface IMutationUpdateBookingArgs {
  input: IUpdateBookingInput;
}

export interface IMutationUpdateBookingByIdArgs {
  input: IUpdateBookingByIdInput;
}

export interface IMutationUpdateClassArgs {
  input: IUpdateClassInput;
}

export interface IMutationUpdateClassByIdArgs {
  input: IUpdateClassByIdInput;
}

export interface IMutationUpdateClassInstructorArgs {
  input: IUpdateClassInstructorInput;
}

export interface IMutationUpdateClassInstructorByClassIdAndInstructorIdArgs {
  input: IUpdateClassInstructorByClassIdAndInstructorIdInput;
}

export interface IMutationUpdateClubArgs {
  input: IUpdateClubInput;
}

export interface IMutationUpdateClubByIdArgs {
  input: IUpdateClubByIdInput;
}

export interface IMutationUpdateClubByKsClubIdArgs {
  input: IUpdateClubByKsClubIdInput;
}

export interface IMutationUpdateInstructorArgs {
  input: IUpdateInstructorInput;
}

export interface IMutationUpdateInstructorByIdArgs {
  input: IUpdateInstructorByIdInput;
}

export interface IMutationUpdateReservationRequestArgs {
  input: IUpdateReservationRequestInput;
}

export interface IMutationUpdateReservationRequestByIdArgs {
  input: IUpdateReservationRequestByIdInput;
}

export interface IMutationUpdateSessionArgs {
  input: IUpdateSessionInput;
}

export interface IMutationUpdateSessionByIdArgs {
  input: IUpdateSessionByIdInput;
}

export interface IMutationUpdateSessionInstructorArgs {
  input: IUpdateSessionInstructorInput;
}

export interface IMutationUpdateSessionInstructorBySessionIdAndInstructorIdArgs {
  input: IUpdateSessionInstructorBySessionIdAndInstructorIdInput;
}

export interface IMutationUpdateTimeslotArgs {
  input: IUpdateTimeslotInput;
}

export interface IMutationUpdateTimeslotByIdArgs {
  input: IUpdateTimeslotByIdInput;
}

export interface IMutationDeleteCoachArgs {
  input: IDeleteCoachInput;
}

export interface IMutationDeleteCoachByIdArgs {
  input: IDeleteCoachByIdInput;
}

export interface IMutationDeleteExerciseArgs {
  input: IDeleteExerciseInput;
}

export interface IMutationDeleteExerciseByIdArgs {
  input: IDeleteExerciseByIdInput;
}

export interface IMutationDeleteExerciseOverrideArgs {
  input: IDeleteExerciseOverrideInput;
}

export interface IMutationDeleteExerciseOverrideByExerciseIdAndWorkspaceIdArgs {
  input: IDeleteExerciseOverrideByExerciseIdAndWorkspaceIdInput;
}

export interface IMutationDeleteExerciseOverrideByIdArgs {
  input: IDeleteExerciseOverrideByIdInput;
}

export interface IMutationDeleteFavouriteFoodArgs {
  input: IDeleteFavouriteFoodInput;
}

export interface IMutationDeleteFavouriteFoodByIdArgs {
  input: IDeleteFavouriteFoodByIdInput;
}

export interface IMutationDeleteFoodArgs {
  input: IDeleteFoodInput;
}

export interface IMutationDeleteFoodByIdArgs {
  input: IDeleteFoodByIdInput;
}

export interface IMutationDeleteHistoryActionArgs {
  input: IDeleteHistoryActionInput;
}

export interface IMutationDeleteHistoryActionByIdArgs {
  input: IDeleteHistoryActionByIdInput;
}

export interface IMutationDeleteLocationArgs {
  input: IDeleteLocationInput;
}

export interface IMutationDeleteLocationByIdArgs {
  input: IDeleteLocationByIdInput;
}

export interface IMutationDeleteManagerArgs {
  input: IDeleteManagerInput;
}

export interface IMutationDeleteManagerByIdArgs {
  input: IDeleteManagerByIdInput;
}

export interface IMutationDeleteManagerClubOrgArgs {
  input: IDeleteManagerClubOrgInput;
}

export interface IMutationDeleteManagerClubOrgByIdArgs {
  input: IDeleteManagerClubOrgByIdInput;
}

export interface IMutationDeleteMealItemArgs {
  input: IDeleteMealItemInput;
}

export interface IMutationDeleteMealItemByIdArgs {
  input: IDeleteMealItemByIdInput;
}

export interface IMutationDeleteMemberArgs {
  input: IDeleteMemberInput;
}

export interface IMutationDeleteMemberByIdArgs {
  input: IDeleteMemberByIdInput;
}

export interface IMutationDeleteMemberCheckinArgs {
  input: IDeleteMemberCheckinInput;
}

export interface IMutationDeleteMemberCheckinByIdArgs {
  input: IDeleteMemberCheckinByIdInput;
}

export interface IMutationDeleteMemberEvaluatedRecipeArgs {
  input: IDeleteMemberEvaluatedRecipeInput;
}

export interface IMutationDeleteMemberEvaluatedRecipeByIdArgs {
  input: IDeleteMemberEvaluatedRecipeByIdInput;
}

export interface IMutationDeleteMemberFavouriteFoodArgs {
  input: IDeleteMemberFavouriteFoodInput;
}

export interface IMutationDeleteMemberFavouriteFoodByIdArgs {
  input: IDeleteMemberFavouriteFoodByIdInput;
}

export interface IMutationDeleteMemberFavouriteFoodByMemberIdAndFoodIdArgs {
  input: IDeleteMemberFavouriteFoodByMemberIdAndFoodIdInput;
}

export interface IMutationDeleteMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdArgs {
  input: IDeleteMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdInput;
}

export interface IMutationDeleteMemberFavouriteFoodByMemberIdAndMyFoodIdArgs {
  input: IDeleteMemberFavouriteFoodByMemberIdAndMyFoodIdInput;
}

export interface IMutationDeleteMemberMealArgs {
  input: IDeleteMemberMealInput;
}

export interface IMutationDeleteMemberMealByIdArgs {
  input: IDeleteMemberMealByIdInput;
}

export interface IMutationDeleteMemberMetricArgs {
  input: IDeleteMemberMetricInput;
}

export interface IMutationDeleteMemberMetricByMemberIdAndDateAndKeyArgs {
  input: IDeleteMemberMetricByMemberIdAndDateAndKeyInput;
}

export interface IMutationDeleteMemberMyFoodArgs {
  input: IDeleteMemberMyFoodInput;
}

export interface IMutationDeleteMemberMyFoodByIdArgs {
  input: IDeleteMemberMyFoodByIdInput;
}

export interface IMutationDeleteMemberNutritionMetricArgs {
  input: IDeleteMemberNutritionMetricInput;
}

export interface IMutationDeleteMemberNutritionMetricByMemberIdAndDateArgs {
  input: IDeleteMemberNutritionMetricByMemberIdAndDateInput;
}

export interface IMutationDeleteMemberNutritionPlanArgs {
  input: IDeleteMemberNutritionPlanInput;
}

export interface IMutationDeleteMemberNutritionPlanByIdArgs {
  input: IDeleteMemberNutritionPlanByIdInput;
}

export interface IMutationDeleteMemberRecentFoodArgs {
  input: IDeleteMemberRecentFoodInput;
}

export interface IMutationDeleteMemberRecentFoodByIdArgs {
  input: IDeleteMemberRecentFoodByIdInput;
}

export interface IMutationDeleteMemberRecentFoodByMemberIdAndFatSecretIdArgs {
  input: IDeleteMemberRecentFoodByMemberIdAndFatSecretIdInput;
}

export interface IMutationDeleteMemberRecentFoodByMemberIdAndMacroEntryIdArgs {
  input: IDeleteMemberRecentFoodByMemberIdAndMacroEntryIdInput;
}

export interface IMutationDeleteMemberRecentFoodByMemberIdAndMyFoodIdArgs {
  input: IDeleteMemberRecentFoodByMemberIdAndMyFoodIdInput;
}

export interface IMutationDeleteMemberRecentFoodByMemberIdAndFoodIdArgs {
  input: IDeleteMemberRecentFoodByMemberIdAndFoodIdInput;
}

export interface IMutationDeleteMemberRecipeArgs {
  input: IDeleteMemberRecipeInput;
}

export interface IMutationDeleteMemberRecipeByIdArgs {
  input: IDeleteMemberRecipeByIdInput;
}

export interface IMutationDeleteMemberReminderArgs {
  input: IDeleteMemberReminderInput;
}

export interface IMutationDeleteMemberReminderByIdArgs {
  input: IDeleteMemberReminderByIdInput;
}

export interface IMutationDeleteMemberStepsMetricArgs {
  input: IDeleteMemberStepsMetricInput;
}

export interface IMutationDeleteMemberStepsMetricByMemberIdAndDateArgs {
  input: IDeleteMemberStepsMetricByMemberIdAndDateInput;
}

export interface IMutationDeleteMemberTrainingProgramArgs {
  input: IDeleteMemberTrainingProgramInput;
}

export interface IMutationDeleteMemberTrainingProgramByIdArgs {
  input: IDeleteMemberTrainingProgramByIdInput;
}

export interface IMutationDeleteMemberWaterMetricArgs {
  input: IDeleteMemberWaterMetricInput;
}

export interface IMutationDeleteMemberWaterMetricByIdArgs {
  input: IDeleteMemberWaterMetricByIdInput;
}

export interface IMutationDeleteMemberWaterMetricByDateAndMemberIdArgs {
  input: IDeleteMemberWaterMetricByDateAndMemberIdInput;
}

export interface IMutationDeleteMemberWorkoutArgs {
  input: IDeleteMemberWorkoutInput;
}

export interface IMutationDeleteMemberWorkoutByIdArgs {
  input: IDeleteMemberWorkoutByIdInput;
}

export interface IMutationDeleteMentorEventArgs {
  input: IDeleteMentorEventInput;
}

export interface IMutationDeleteMentorEventByIdArgs {
  input: IDeleteMentorEventByIdInput;
}

export interface IMutationDeleteMentoringReportArgs {
  input: IDeleteMentoringReportInput;
}

export interface IMutationDeleteMentoringReportByIdArgs {
  input: IDeleteMentoringReportByIdInput;
}

export interface IMutationDeleteMentoringReportByTokenArgs {
  input: IDeleteMentoringReportByTokenInput;
}

export interface IMutationDeleteMentoringReportMessageArgs {
  input: IDeleteMentoringReportMessageInput;
}

export interface IMutationDeleteMentoringReportMessageByIdArgs {
  input: IDeleteMentoringReportMessageByIdInput;
}

export interface IMutationDeleteNotificationArgs {
  input: IDeleteNotificationInput;
}

export interface IMutationDeleteNotificationByIdArgs {
  input: IDeleteNotificationByIdInput;
}

export interface IMutationDeleteNutritionDayArgs {
  input: IDeleteNutritionDayInput;
}

export interface IMutationDeleteNutritionDayByIdArgs {
  input: IDeleteNutritionDayByIdInput;
}

export interface IMutationDeleteNutritionDayMealArgs {
  input: IDeleteNutritionDayMealInput;
}

export interface IMutationDeleteNutritionDayMealByNutritionDayIdAndMealIdArgs {
  input: IDeleteNutritionDayMealByNutritionDayIdAndMealIdInput;
}

export interface IMutationDeleteNutritionPlanArgs {
  input: IDeleteNutritionPlanInput;
}

export interface IMutationDeleteNutritionPlanByIdArgs {
  input: IDeleteNutritionPlanByIdInput;
}

export interface IMutationDeleteNutritionPlanDayArgs {
  input: IDeleteNutritionPlanDayInput;
}

export interface IMutationDeleteNutritionPlanDayByNutritionPlanIdAndNutritionDayIdArgs {
  input: IDeleteNutritionPlanDayByNutritionPlanIdAndNutritionDayIdInput;
}

export interface IMutationDeleteNutritionPlanScheduleArgs {
  input: IDeleteNutritionPlanScheduleInput;
}

export interface IMutationDeleteNutritionPlanScheduleByNutritionPlanIdAndOrderIndexArgs {
  input: IDeleteNutritionPlanScheduleByNutritionPlanIdAndOrderIndexInput;
}

export interface IMutationDeleteNutritionProfileArgs {
  input: IDeleteNutritionProfileInput;
}

export interface IMutationDeleteNutritionProfileByIdArgs {
  input: IDeleteNutritionProfileByIdInput;
}

export interface IMutationDeleteNutritionProfileMealArgs {
  input: IDeleteNutritionProfileMealInput;
}

export interface IMutationDeleteNutritionProfileMealByIdArgs {
  input: IDeleteNutritionProfileMealByIdInput;
}

export interface IMutationDeleteProgramWorkoutArgs {
  input: IDeleteProgramWorkoutInput;
}

export interface IMutationDeleteProgramWorkoutByProgramIdAndWorkoutIdArgs {
  input: IDeleteProgramWorkoutByProgramIdAndWorkoutIdInput;
}

export interface IMutationDeleteRecentFoodArgs {
  input: IDeleteRecentFoodInput;
}

export interface IMutationDeleteRecentFoodByIdArgs {
  input: IDeleteRecentFoodByIdInput;
}

export interface IMutationDeleteSettingArgs {
  input: IDeleteSettingInput;
}

export interface IMutationDeleteSettingByIdArgs {
  input: IDeleteSettingByIdInput;
}

export interface IMutationDeleteSettingByKeyArgs {
  input: IDeleteSettingByKeyInput;
}

export interface IMutationDeleteTagArgs {
  input: IDeleteTagInput;
}

export interface IMutationDeleteTagByIdArgs {
  input: IDeleteTagByIdInput;
}

export interface IMutationDeleteUserSettingArgs {
  input: IDeleteUserSettingInput;
}

export interface IMutationDeleteUserSettingByIdArgs {
  input: IDeleteUserSettingByIdInput;
}

export interface IMutationDeleteWorkoutArgs {
  input: IDeleteWorkoutInput;
}

export interface IMutationDeleteWorkoutByIdArgs {
  input: IDeleteWorkoutByIdInput;
}

export interface IMutationDeleteWorkoutExerciseArgs {
  input: IDeleteWorkoutExerciseInput;
}

export interface IMutationDeleteWorkoutExerciseByIdAndWorkoutIdAndExerciseIdArgs {
  input: IDeleteWorkoutExerciseByIdAndWorkoutIdAndExerciseIdInput;
}

export interface IMutationDeleteWorkoutNodeArgs {
  input: IDeleteWorkoutNodeInput;
}

export interface IMutationDeleteWorkoutNodeByIdArgs {
  input: IDeleteWorkoutNodeByIdInput;
}

export interface IMutationDeleteWorkoutNodeEventArgs {
  input: IDeleteWorkoutNodeEventInput;
}

export interface IMutationDeleteWorkoutNodeEventByIdArgs {
  input: IDeleteWorkoutNodeEventByIdInput;
}

export interface IMutationDeleteBrandArgs {
  input: IDeleteBrandInput;
}

export interface IMutationDeleteBrandByIdArgs {
  input: IDeleteBrandByIdInput;
}

export interface IMutationDeleteBrandBarcodeArgs {
  input: IDeleteBrandBarcodeInput;
}

export interface IMutationDeleteBrandBarcodeByBrandIdAndGtinIdArgs {
  input: IDeleteBrandBarcodeByBrandIdAndGtinIdInput;
}

export interface IMutationDeleteCategoryArgs {
  input: IDeleteCategoryInput;
}

export interface IMutationDeleteCategoryByIdArgs {
  input: IDeleteCategoryByIdInput;
}

export interface IMutationDeleteCompositionArgs {
  input: IDeleteCompositionInput;
}

export interface IMutationDeleteCompositionByFoodIdArgs {
  input: IDeleteCompositionByFoodIdInput;
}

export interface IMutationDeleteCountryArgs {
  input: IDeleteCountryInput;
}

export interface IMutationDeleteCountryByIdArgs {
  input: IDeleteCountryByIdInput;
}

export interface IMutationDeleteDataSourceArgs {
  input: IDeleteDataSourceInput;
}

export interface IMutationDeleteDataSourceByIdArgs {
  input: IDeleteDataSourceByIdInput;
}

export interface IMutationDeleteDataSourceBySourceNameArgs {
  input: IDeleteDataSourceBySourceNameInput;
}

export interface IMutationDeleteFoodbankFoodArgs {
  input: IDeleteFoodbankFoodInput;
}

export interface IMutationDeleteFoodbankFoodByIdArgs {
  input: IDeleteFoodbankFoodByIdInput;
}

export interface IMutationDeleteFoodCategoryArgs {
  input: IDeleteFoodCategoryInput;
}

export interface IMutationDeleteFoodCategoryByFoodIdAndCategoryIdArgs {
  input: IDeleteFoodCategoryByFoodIdAndCategoryIdInput;
}

export interface IMutationDeleteGtinArgs {
  input: IDeleteGtinInput;
}

export interface IMutationDeleteGtinByFoodIdAndGtinArgs {
  input: IDeleteGtinByFoodIdAndGtinInput;
}

export interface IMutationDeleteNutritionDictionaryArgs {
  input: IDeleteNutritionDictionaryInput;
}

export interface IMutationDeleteNutritionDictionaryByIdArgs {
  input: IDeleteNutritionDictionaryByIdInput;
}

export interface IMutationDeleteFoodbankNutritionFactArgs {
  input: IDeleteFoodbankNutritionFactInput;
}

export interface IMutationDeleteFoodbankNutritionFactByFoodIdArgs {
  input: IDeleteFoodbankNutritionFactByFoodIdInput;
}

export interface IMutationDeleteServingArgs {
  input: IDeleteServingInput;
}

export interface IMutationDeleteServingByIdArgs {
  input: IDeleteServingByIdInput;
}

export interface IMutationDeleteAttendanceArgs {
  input: IDeleteAttendanceInput;
}

export interface IMutationDeleteAttendanceBySessionIdAndPersonIdArgs {
  input: IDeleteAttendanceBySessionIdAndPersonIdInput;
}

export interface IMutationDeleteAttendanceByIdArgs {
  input: IDeleteAttendanceByIdInput;
}

export interface IMutationDeleteAttendanceOverrideArgs {
  input: IDeleteAttendanceOverrideInput;
}

export interface IMutationDeleteAttendanceOverrideByIdArgs {
  input: IDeleteAttendanceOverrideByIdInput;
}

export interface IMutationDeleteAttendeeArgs {
  input: IDeleteAttendeeInput;
}

export interface IMutationDeleteAttendeeByIdArgs {
  input: IDeleteAttendeeByIdInput;
}

export interface IMutationDeleteAttendeeClubArgs {
  input: IDeleteAttendeeClubInput;
}

export interface IMutationDeleteAttendeeClubByAttendeeIdAndClubIdArgs {
  input: IDeleteAttendeeClubByAttendeeIdAndClubIdInput;
}

export interface IMutationDeleteBookingArgs {
  input: IDeleteBookingInput;
}

export interface IMutationDeleteBookingByIdArgs {
  input: IDeleteBookingByIdInput;
}

export interface IMutationDeleteClassArgs {
  input: IDeleteClassInput;
}

export interface IMutationDeleteClassByIdArgs {
  input: IDeleteClassByIdInput;
}

export interface IMutationDeleteClassInstructorArgs {
  input: IDeleteClassInstructorInput;
}

export interface IMutationDeleteClassInstructorByClassIdAndInstructorIdArgs {
  input: IDeleteClassInstructorByClassIdAndInstructorIdInput;
}

export interface IMutationDeleteClubArgs {
  input: IDeleteClubInput;
}

export interface IMutationDeleteClubByIdArgs {
  input: IDeleteClubByIdInput;
}

export interface IMutationDeleteClubByKsClubIdArgs {
  input: IDeleteClubByKsClubIdInput;
}

export interface IMutationDeleteInstructorArgs {
  input: IDeleteInstructorInput;
}

export interface IMutationDeleteInstructorByIdArgs {
  input: IDeleteInstructorByIdInput;
}

export interface IMutationDeleteSessionArgs {
  input: IDeleteSessionInput;
}

export interface IMutationDeleteSessionByIdArgs {
  input: IDeleteSessionByIdInput;
}

export interface IMutationDeleteSessionInstructorArgs {
  input: IDeleteSessionInstructorInput;
}

export interface IMutationDeleteSessionInstructorBySessionIdAndInstructorIdArgs {
  input: IDeleteSessionInstructorBySessionIdAndInstructorIdInput;
}

export interface IMutationDeleteTimeslotArgs {
  input: IDeleteTimeslotInput;
}

export interface IMutationDeleteTimeslotByIdArgs {
  input: IDeleteTimeslotByIdInput;
}

export interface IMutationAcceptInviteArgs {
  input: IAcceptInviteInput;
}

export interface IMutationActivateCoachArgs {
  input: IActivateCoachInput;
}

export interface IMutationActivateMemberArgs {
  input: IActivateMemberInput;
}

export interface IMutationArchiveCoachArgs {
  input: IArchiveCoachInput;
}

export interface IMutationArchiveMemberArgs {
  input: IArchiveMemberInput;
}

export interface IMutationArchiveWorkoutArgs {
  input: IArchiveWorkoutInput;
}

export interface IMutationAssignFeaturesArgs {
  input: IAssignFeaturesInput;
}

export interface IMutationAssignTagsArgs {
  input: IAssignTagsInput;
}

export interface IMutationAuthenticateArgs {
  input: IAuthenticateInput;
}

export interface IMutationAuthenticateProductArgs {
  input: IAuthenticateProductInput;
}

export interface IMutationChangeMembersCoachArgs {
  input: IChangeMembersCoachInput;
}

export interface IMutationChangeUserCoachArgs {
  input: IChangeUserCoachInput;
}

export interface IMutationCheckinMemberArgs {
  input: ICheckinMemberInput;
}

export interface IMutationCreateEmptyNutritionDayArgs {
  input: ICreateEmptyNutritionDayInput;
}

export interface IMutationCreateFeatureArgs {
  input: ICreateFeatureInput;
}

export interface IMutationCreateNewExerciseArgs {
  input: ICreateNewExerciseInput;
}

export interface IMutationCreateNutritionPlanArgs {
  input: ICreateNutritionPlanInput;
}

export interface IMutationCreateWorkoutInProgramByIdV2Args {
  input: ICreateWorkoutInProgramByIdV2Input;
}

export interface IMutationDeleteFeaturesArgs {
  input: IDeleteFeaturesInput;
}

export interface IMutationDeleteFullNutritionDayArgs {
  input: IDeleteFullNutritionDayInput;
}

export interface IMutationDeleteInsightsByIdArgs {
  input: IDeleteInsightsByIdInput;
}

export interface IMutationDeleteMemberMetricsArgs {
  input: IDeleteMemberMetricsInput;
}

export interface IMutationDeleteMembersArgs {
  input: IDeleteMembersInput;
}

export interface IMutationDeleteMyRecipeArgs {
  input: IDeleteMyRecipeInput;
}

export interface IMutationDeleteTagFromMemberArgs {
  input: IDeleteTagFromMemberInput;
}

export interface IMutationDeleteUsersFeaturesArgs {
  input: IDeleteUsersFeaturesInput;
}

export interface IMutationDuplicateMealArgs {
  input: IDuplicateMealInput;
}

export interface IMutationDuplicateNutritionDayArgs {
  input: IDuplicateNutritionDayInput;
}

export interface IMutationDuplicateNutritionPlanArgs {
  input: IDuplicateNutritionPlanInput;
}

export interface IMutationOverrideExerciseArgs {
  input: IOverrideExerciseInput;
}

export interface IMutationRandomStringArgs {
  input: IRandomStringInput;
}

export interface IMutationReadRemindersArgs {
  input: IReadRemindersInput;
}

export interface IMutationRequestPasswordResetArgs {
  input: IRequestPasswordResetInput;
}

export interface IMutationRequestPasswordsResetArgs {
  input: IRequestPasswordsResetInput;
}

export interface IMutationResetPasswordArgs {
  input: IResetPasswordInput;
}

export interface IMutationSaveFavouriteFoodArgs {
  input: ISaveFavouriteFoodInput;
}

export interface IMutationSaveMentoringReportArgs {
  input: ISaveMentoringReportInput;
}

export interface IMutationSaveMentoringReportMessageArgs {
  input: ISaveMentoringReportMessageInput;
}

export interface IMutationSaveMyMealArgs {
  input: ISaveMyMealInput;
}

export interface IMutationSaveMyMealV2Args {
  input: ISaveMyMealV2Input;
}

export interface IMutationSaveMyRecipeArgs {
  input: ISaveMyRecipeInput;
}

export interface IMutationSaveNutritionDayArgs {
  input: ISaveNutritionDayInput;
}

export interface IMutationSaveNutritionDayV2Args {
  input: ISaveNutritionDayV2Input;
}

export interface IMutationSaveNutritionPlanArgs {
  input: ISaveNutritionPlanInput;
}

export interface IMutationSaveRecentFoodItemsArgs {
  input: ISaveRecentFoodItemsInput;
}

export interface IMutationSendPushNotificationArgs {
  input: ISendPushNotificationInput;
}

export interface IMutationSignupCoachArgs {
  input: ISignupCoachInput;
}

export interface IMutationSuspendMemberArgs {
  input: ISuspendMemberInput;
}

export interface IMutationUnarchiveWorkoutArgs {
  input: IUnarchiveWorkoutInput;
}

export interface IMutationUpdateMemberInfoArgs {
  input: IUpdateMemberInfoInput;
}

export interface IMutationUpdateMemberProfileArgs {
  input: IUpdateMemberProfileInput;
}

export interface IMutationUpsertDeviceMetaArgs {
  input: IUpsertDeviceMetaInput;
}

export interface IMutationUpsertFoodArgs {
  input: IUpsertFoodInput;
}

export interface IMutationUpsertMemberMetricArgs {
  input: IUpsertMemberMetricInput;
}

export interface IMutationUpsertMemberMetricV2Args {
  input: IUpsertMemberMetricV2Input;
}

export interface IMutationUpsertMemberNutritionMetricArgs {
  input: IUpsertMemberNutritionMetricInput;
}

export interface IMutationUpsertMemberRecentFoodArgs {
  input: IUpsertMemberRecentFoodInput;
}

export interface IMutationUpsertMemberRecentFoodV2Args {
  input: IUpsertMemberRecentFoodV2Input;
}

export interface IMutationUpsertMemberWaterMetricArgs {
  input: IUpsertMemberWaterMetricInput;
}

export interface IMutationUpsertMemberWorkoutArgs {
  input: IUpsertMemberWorkoutInput;
}

export interface IMutationUpsertMemberWorkoutV2Args {
  input: IUpsertMemberWorkoutV2Input;
}

export interface IMutationUpsertUserSettingArgs {
  input: IUpsertUserSettingInput;
}

export interface IMutationUpsertWorkoutExercisesArgs {
  input: IUpsertWorkoutExercisesInput;
}

export interface IMutationBookAttendeesIntoTimeslotsArgs {
  input: IBookAttendeesIntoTimeslotsInput;
}

export interface IMutationCreateAttendeesByUserIdsArgs {
  input: ICreateAttendeesByUserIdsInput;
}

export interface IMutationCreateInstructorsArgs {
  input: ICreateInstructorsInput;
}

export interface IMutationCreateReservationRequestArgs {
  input: ICreateReservationRequestInput;
}

export interface IMutationCreateSessionByTimeslotIdArgs {
  input: ICreateSessionByTimeslotIdInput;
}

export interface IMutationDeleteReservationRequestByIdArgs {
  input: IDeleteReservationRequestByIdInput;
}

export interface IMutationPopulateSessionAttendanceArgs {
  input: IPopulateSessionAttendanceInput;
}

export interface IMutationProcessReservationsArgs {
  input: IProcessReservationsInput;
}

export interface IMutationSaveWorkoutTemplateArgs {
  input: ISaveWorkoutTemplateInput;
}

export interface IMutationSaveMemberWorkoutTemplateArgs {
  input: ISaveMemberWorkoutTemplateInput;
}

export interface IMutationCloneWorkoutTemplateArgs {
  input: ICloneWorkoutTemplateInput;
}

export interface IMutationDeleteWorkoutTemplateArgs {
  input: IDeleteWorkoutTemplateInput;
}

export interface IMutationShareWorkoutTemplateArgs {
  input: IShareWorkoutTemplateInput;
}

export interface IMutationUpdateWorkoutTemplateSharingArgs {
  input: IUpdateWorkoutTemplateSharingInput;
}

export interface IMutationAssignWorkoutTemplatesArgs {
  input: IAssignWorkoutTemplatesInput;
}

export interface IMutationDeleteWorkoutTemplateAssignmentsArgs {
  input: IDeleteWorkoutTemplateAssignmentsInput;
}

export interface IMutationDeleteWorkoutTemplateSharingByIdArgs {
  input: IDeleteWorkoutTemplateSharingInput;
}

export interface IMutationSaveWorkoutSessionArgs {
  input: ISaveWorkoutSessionInput;
}

export interface IMutationDeleteWorkoutSessionArgs {
  input: IDeleteWorkoutSessionInput;
}

export interface IMutationSaveTrainingPlanArgs {
  input: ISaveTrainingPlanInput;
}

export interface IMutationDeleteTrainingPlanArgs {
  input: IDeleteTrainingPlanInput;
}

export interface IMutationShareTrainingPlanArgs {
  input: IShareTrainingPlanInput;
}

export interface IMutationUpdateTrainingPlanSharingArgs {
  input: IUpdateTrainingPlanSharingInput;
}

export interface IMutationAssignTrainingPlanArgs {
  input: IAssignTrainingPlanInput;
}

export interface IMutationDeleteTrainingPlanAssignmentsArgs {
  input: IDeleteTrainingPlanAssignmentsInput;
}

export interface IMutationCloneTrainingPlanArgs {
  input: ICloneTrainingPlanInput;
}

export interface IMutationDeleteTrainingPlanSharingByIdArgs {
  input: IDeleteTrainingPlanSharingInput;
}

export interface IMutationCreateWorkoutTemplateDirectoryArgs {
  input: ICreateWorkoutTemplateDirectoryInput;
}

export interface IMutationUpdateWorkoutTemplateDirectoryArgs {
  input: IUpdateWorkoutTemplateDirectoryInput;
}

export interface IMutationDeleteWorkoutTemplateDirectoryArgs {
  input: IDeleteWorkoutTemplateDirectoryInput;
}

export interface IMutationMoveWorkoutTemplateDirectoryArgs {
  input: IMoveWorkoutTemplateDirectoryInput;
}

export interface IMutationMoveWorkoutTemplateArgs {
  input: IMoveWorkoutTemplateInput;
}

export interface IMutationConvertTrainingProgramArgs {
  input: IConvertTrainingProgramInput;
}

export interface IMutationCreateTrainingProgramArgs {
  input: ICreateTrainingProgramInput;
}

export interface IMutationDuplicateProgramByIdArgs {
  input: IDuplicateProgramByIdInput;
}

export interface IMutationUpdateTrainingProgramByIdArgs {
  input: IUpdateTrainingProgramByIdInput;
}

export interface IMutationDeleteTrainingProgramByIdArgs {
  input: IDeleteTrainingProgramByIdInput;
}

export interface IMutationCreateWorkoutInProgramByIdArgs {
  input: ICreateWorkoutByProgramIdInput;
}

export interface IMutationDuplicateWorkoutArgs {
  input: IDuplicateWorkoutInput;
}

export interface IMutationUpdateWorkoutByIdArgs {
  input: IUpdateWorkoutByIdInput;
}

export interface IMutationCreateWorkoutNodeEventArgs {
  input: ICreateWorkoutNodeEventInput;
}

export interface IMutationRegisterMemberArgs {
  input: IRegisterMemberInput;
}

export interface IMutationInviteMemberByCoachArgs {
  input: IInviteMemberByCoachInput;
}

export interface IMutationDeleteCoachMembersArgs {
  input: IDeleteCoachMembersInput;
}

export interface IMutationTransferMembersArgs {
  input: ITransferMembersInput;
}

export interface IMutationRegisterNewCoachArgs {
  input: IRegisterNewCoachInput;
}

export interface IMutationAddDeviceMetaArgs {
  input: IAddDeviceMetaInput;
}

export interface IMutationRemoveDeviceMetaArgs {
  input: IRemoveDeviceMetaInput;
}

export interface IMutationAddProgressPictureArgs {
  input: IAddProgressPictureInput;
}

export interface IMutationUpdateProgressPictureArgs {
  input: IUpdateProgressPictureInput;
}

export interface IMutationDeleteProgressPictureArgs {
  input: IDeleteProgressPictureInput;
}

export interface IMutationUpdateStepsArgs {
  input: IUpdateStepsInput;
}

export interface IMutationDeleteMetricByIdArgs {
  input: IDeleteMetricByIdInput;
}

export interface IMutationSaveBodyMetricsArgs {
  input: ISaveBodyMeasurementInput;
}

export interface IMutationRejectBarcodeRequestArgs {
  input: IRejectBarcodeRequestInput;
}

export interface IMutationCreateJournalDayTargetArgs {
  input: ICreateJournalDayTargetsInput;
}

export interface IMutationSaveJournalMealArgs {
  input: ISaveJournalMealInput;
}

export interface IMutationSaveJournalWaterVolumeArgs {
  input: ISaveJournalWaterVolumeInput;
}

export interface IMutationAddMealPhotoArgs {
  input: IAddMealPhotoInput;
}

export interface IMutationDeleteMealPhotoArgs {
  input: IDeleteMealPhotoInput;
}

export interface IMutationAssignJournalTargetsArgs {
  input: IAssignJournalTargetsInput;
}

export interface IMutationDeleteJournalTargetArgs {
  input: IDeleteJournalTargetInput;
}

/** An object with a globally unique `ID`. */
export interface INode {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
}

export interface INotification  extends INode {
   __typename?: "Notification";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  userId?: Maybe<Scalars["Int"]>;
  description: Scalars["String"];
  text?: Maybe<Scalars["String"]>;
  isProcessed: Scalars["Boolean"];
  createdAt: Scalars["Datetime"];
  ksUserId?: Maybe<Scalars["String"]>;
}

/**
 * A condition to be used against `Notification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INotificationCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `text` field. */
  text?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isProcessed` field. */
  isProcessed?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Notification` */
export interface INotificationInput {
  id?: Maybe<Scalars["Uuid"]>;
  userId?: Maybe<Scalars["Int"]>;
  description: Scalars["String"];
  text?: Maybe<Scalars["String"]>;
  isProcessed?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export interface INotificationPatch {
  id?: Maybe<Scalars["Uuid"]>;
  userId?: Maybe<Scalars["Int"]>;
  description?: Maybe<Scalars["String"]>;
  text?: Maybe<Scalars["String"]>;
  isProcessed?: Maybe<Scalars["Boolean"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Notification` values. */
export interface INotificationsConnection {
   __typename?: "NotificationsConnection";
  /** A list of `Notification` objects. */
  nodes: Array<Maybe<INotification>>;
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: INotificationsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Notification` edge in the connection. */
export interface INotificationsEdge {
   __typename?: "NotificationsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Notification` at the end of the edge. */
  node?: Maybe<INotification>;
}

/** Methods to use when ordering `Notification`. */
export enum INotificationsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  DescriptionAsc = "DESCRIPTION_ASC",
  DescriptionDesc = "DESCRIPTION_DESC",
  TextAsc = "TEXT_ASC",
  TextDesc = "TEXT_DESC",
  IsProcessedAsc = "IS_PROCESSED_ASC",
  IsProcessedDesc = "IS_PROCESSED_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface INutritionDay  extends INode {
   __typename?: "NutritionDay";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  memberId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads and enables pagination through a set of `NutritionPlanDay`. */
  nutritionPlanDaysByNutritionDayId: INutritionPlanDaysConnection;
  /** Reads and enables pagination through a set of `NutritionDayMeal`. */
  nutritionDayMealsByNutritionDayId: INutritionDayMealsConnection;
  /** Reads and enables pagination through a set of `NutritionPlanSchedule`. */
  nutritionPlanSchedulesByNutritionDayId: INutritionPlanSchedulesConnection;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  meals: IMemberMealsConnection;
  nutritionFacts?: Maybe<INutritionFact>;
}

export interface INutritionDayNutritionPlanDaysByNutritionDayIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
  condition?: Maybe<INutritionPlanDayCondition>;
}

export interface INutritionDayNutritionDayMealsByNutritionDayIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
  condition?: Maybe<INutritionDayMealCondition>;
}

export interface INutritionDayNutritionPlanSchedulesByNutritionDayIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
  condition?: Maybe<INutritionPlanScheduleCondition>;
}

export interface INutritionDayMealsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

/**
 * A condition to be used against `NutritionDay` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionDayCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `NutritionDay` */
export interface INutritionDayInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  memberId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface INutritionDayMeal  extends INode {
   __typename?: "NutritionDayMeal";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  nutritionDayId: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `NutritionDay` that is related to this `NutritionDayMeal`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `MemberMeal` that is related to this `NutritionDayMeal`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
}

/**
 * A condition to be used against `NutritionDayMeal` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionDayMealCondition {
  /** Checks for equality with the object’s `nutritionDayId` field. */
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `NutritionDayMeal` */
export interface INutritionDayMealInput {
  nutritionDayId: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `NutritionDayMeal`. Fields that are set will be updated. */
export interface INutritionDayMealPatch {
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  mealId?: Maybe<Scalars["Uuid"]>;
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `NutritionDayMeal` values. */
export interface INutritionDayMealsConnection {
   __typename?: "NutritionDayMealsConnection";
  /** A list of `NutritionDayMeal` objects. */
  nodes: Array<Maybe<INutritionDayMeal>>;
  /** A list of edges which contains the `NutritionDayMeal` and cursor to aid in pagination. */
  edges: INutritionDayMealsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionDayMeal` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionDayMeal` edge in the connection. */
export interface INutritionDayMealsEdge {
   __typename?: "NutritionDayMealsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionDayMeal` at the end of the edge. */
  node?: Maybe<INutritionDayMeal>;
}

/** Methods to use when ordering `NutritionDayMeal`. */
export enum INutritionDayMealsOrderBy {
  Natural = "NATURAL",
  NutritionDayIdAsc = "NUTRITION_DAY_ID_ASC",
  NutritionDayIdDesc = "NUTRITION_DAY_ID_DESC",
  MealIdAsc = "MEAL_ID_ASC",
  MealIdDesc = "MEAL_ID_DESC",
  SortOrderAsc = "SORT_ORDER_ASC",
  SortOrderDesc = "SORT_ORDER_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `NutritionDay`. Fields that are set will be updated. */
export interface INutritionDayPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  memberId?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `NutritionDay` values. */
export interface INutritionDaysConnection {
   __typename?: "NutritionDaysConnection";
  /** A list of `NutritionDay` objects. */
  nodes: Array<Maybe<INutritionDay>>;
  /** A list of edges which contains the `NutritionDay` and cursor to aid in pagination. */
  edges: INutritionDaysEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionDay` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionDay` edge in the connection. */
export interface INutritionDaysEdge {
   __typename?: "NutritionDaysEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionDay` at the end of the edge. */
  node?: Maybe<INutritionDay>;
}

/** Methods to use when ordering `NutritionDay`. */
export enum INutritionDaysOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  AuthorIdAsc = "AUTHOR_ID_ASC",
  AuthorIdDesc = "AUTHOR_ID_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A connection to a list of `NutritionDictionary` values. */
export interface INutritionDictionariesConnection {
   __typename?: "NutritionDictionariesConnection";
  /** A list of `NutritionDictionary` objects. */
  nodes: Array<Maybe<INutritionDictionary>>;
  /** A list of edges which contains the `NutritionDictionary` and cursor to aid in pagination. */
  edges: INutritionDictionariesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionDictionary` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionDictionary` edge in the connection. */
export interface INutritionDictionariesEdge {
   __typename?: "NutritionDictionariesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionDictionary` at the end of the edge. */
  node?: Maybe<INutritionDictionary>;
}

/** Methods to use when ordering `NutritionDictionary`. */
export enum INutritionDictionariesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  ParentNutritionIdAsc = "PARENT_NUTRITION_ID_ASC",
  ParentNutritionIdDesc = "PARENT_NUTRITION_ID_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A list of all possible food nutrition */
export interface INutritionDictionary  extends INode {
   __typename?: "NutritionDictionary";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  /** Reference to nutrition which includes the given one as a part of total sum */
  parentNutritionId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
  /** Reads a single `NutritionDictionary` that is related to this `NutritionDictionary`. */
  nutritionDictionaryByParentNutritionId?: Maybe<INutritionDictionary>;
  /** Reads and enables pagination through a set of `NutritionDictionary`. */
  nutritionDictionariesByParentNutritionId: INutritionDictionariesConnection;
}

/** A list of all possible food nutrition */
export interface INutritionDictionaryNutritionDictionariesByParentNutritionIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDictionariesOrderBy[]>;
  condition?: Maybe<INutritionDictionaryCondition>;
}

/**
 * A condition to be used against `NutritionDictionary` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionDictionaryCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `parentNutritionId` field. */
  parentNutritionId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `NutritionDictionary` */
export interface INutritionDictionaryInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
  /** Reference to nutrition which includes the given one as a part of total sum */
  parentNutritionId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `NutritionDictionary`. Fields that are set will be updated. */
export interface INutritionDictionaryPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  /** Reference to nutrition which includes the given one as a part of total sum */
  parentNutritionId?: Maybe<Scalars["Int"]>;
  comment?: Maybe<Scalars["String"]>;
}

export interface INutritionFact {
   __typename?: "NutritionFact";
  calories?: Maybe<Scalars["BigFloat"]>;
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
  fibre?: Maybe<Scalars["BigFloat"]>;
  alcohol?: Maybe<Scalars["BigFloat"]>;
}

export interface INutritionInfo {
   __typename?: "NutritionInfo";
  cals?: Maybe<Scalars["Float"]>;
  protein?: Maybe<Scalars["Float"]>;
  fat?: Maybe<Scalars["Float"]>;
  carbs?: Maybe<Scalars["Float"]>;
  fibre?: Maybe<Scalars["Float"]>;
}

export interface INutritionPlan  extends INode {
   __typename?: "NutritionPlan";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  duration?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `NutritionPlanDay`. */
  nutritionPlanDaysByNutritionPlanId: INutritionPlanDaysConnection;
  /** Reads and enables pagination through a set of `NutritionPlanSchedule`. */
  nutritionPlanSchedulesByNutritionPlanId: INutritionPlanSchedulesConnection;
  /** Reads and enables pagination through a set of `MemberNutritionPlan`. */
  memberNutritionPlansByNutritionPlanId: IMemberNutritionPlansConnection;
  author?: Maybe<ICoach>;
  nutritionFacts?: Maybe<INutritionFact>;
  nutritionFactsFast?: Maybe<INutritionFact>;
}

export interface INutritionPlanNutritionPlanDaysByNutritionPlanIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
  condition?: Maybe<INutritionPlanDayCondition>;
}

export interface INutritionPlanNutritionPlanSchedulesByNutritionPlanIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
  condition?: Maybe<INutritionPlanScheduleCondition>;
}

export interface INutritionPlanMemberNutritionPlansByNutritionPlanIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
  condition?: Maybe<IMemberNutritionPlanCondition>;
}

/**
 * A condition to be used against `NutritionPlan` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionPlanCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface INutritionPlanDay  extends INode {
   __typename?: "NutritionPlanDay";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  nutritionPlanId: Scalars["Uuid"];
  nutritionDayId: Scalars["Uuid"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  isArchived: Scalars["Boolean"];
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanDay`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanDay`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
}

/**
 * A condition to be used against `NutritionPlanDay` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionPlanDayCondition {
  /** Checks for equality with the object’s `nutritionPlanId` field. */
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `nutritionDayId` field. */
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `isArchived` field. */
  isArchived?: Maybe<Scalars["Boolean"]>;
}

/** An input for mutations affecting `NutritionPlanDay` */
export interface INutritionPlanDayInput {
  nutritionPlanId: Scalars["Uuid"];
  nutritionDayId: Scalars["Uuid"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
}

/** Represents an update to a `NutritionPlanDay`. Fields that are set will be updated. */
export interface INutritionPlanDayPatch {
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
}

/** A connection to a list of `NutritionPlanDay` values. */
export interface INutritionPlanDaysConnection {
   __typename?: "NutritionPlanDaysConnection";
  /** A list of `NutritionPlanDay` objects. */
  nodes: Array<Maybe<INutritionPlanDay>>;
  /** A list of edges which contains the `NutritionPlanDay` and cursor to aid in pagination. */
  edges: INutritionPlanDaysEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionPlanDay` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionPlanDay` edge in the connection. */
export interface INutritionPlanDaysEdge {
   __typename?: "NutritionPlanDaysEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionPlanDay` at the end of the edge. */
  node?: Maybe<INutritionPlanDay>;
}

/** Methods to use when ordering `NutritionPlanDay`. */
export enum INutritionPlanDaysOrderBy {
  Natural = "NATURAL",
  NutritionPlanIdAsc = "NUTRITION_PLAN_ID_ASC",
  NutritionPlanIdDesc = "NUTRITION_PLAN_ID_DESC",
  NutritionDayIdAsc = "NUTRITION_DAY_ID_ASC",
  NutritionDayIdDesc = "NUTRITION_DAY_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  IsArchivedAsc = "IS_ARCHIVED_ASC",
  IsArchivedDesc = "IS_ARCHIVED_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** An input for mutations affecting `NutritionPlan` */
export interface INutritionPlanInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  duration?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `NutritionPlan`. Fields that are set will be updated. */
export interface INutritionPlanPatch {
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  authorId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  duration?: Maybe<Scalars["Int"]>;
  ksUserId?: Maybe<Scalars["String"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface INutritionPlanSchedule  extends INode {
   __typename?: "NutritionPlanSchedule";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  dayType: IPlanDayType;
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  nutritionPlanId: Scalars["Uuid"];
  orderIndex: Scalars["Int"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanSchedule`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanSchedule`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
}

/**
 * A condition to be used against `NutritionPlanSchedule` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionPlanScheduleCondition {
  /** Checks for equality with the object’s `dayType` field. */
  dayType?: Maybe<IPlanDayType>;
  /** Checks for equality with the object’s `nutritionDayId` field. */
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `nutritionPlanId` field. */
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `orderIndex` field. */
  orderIndex?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `NutritionPlanSchedule` */
export interface INutritionPlanScheduleInput {
  dayType: IPlanDayType;
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  nutritionPlanId: Scalars["Uuid"];
  orderIndex: Scalars["Int"];
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `NutritionPlanSchedule`. Fields that are set will be updated. */
export interface INutritionPlanSchedulePatch {
  dayType?: Maybe<IPlanDayType>;
  nutritionDayId?: Maybe<Scalars["Uuid"]>;
  nutritionPlanId?: Maybe<Scalars["Uuid"]>;
  orderIndex?: Maybe<Scalars["Int"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `NutritionPlanSchedule` values. */
export interface INutritionPlanSchedulesConnection {
   __typename?: "NutritionPlanSchedulesConnection";
  /** A list of `NutritionPlanSchedule` objects. */
  nodes: Array<Maybe<INutritionPlanSchedule>>;
  /** A list of edges which contains the `NutritionPlanSchedule` and cursor to aid in pagination. */
  edges: INutritionPlanSchedulesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionPlanSchedule` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionPlanSchedule` edge in the connection. */
export interface INutritionPlanSchedulesEdge {
   __typename?: "NutritionPlanSchedulesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionPlanSchedule` at the end of the edge. */
  node?: Maybe<INutritionPlanSchedule>;
}

/** Methods to use when ordering `NutritionPlanSchedule`. */
export enum INutritionPlanSchedulesOrderBy {
  Natural = "NATURAL",
  DayTypeAsc = "DAY_TYPE_ASC",
  DayTypeDesc = "DAY_TYPE_DESC",
  NutritionDayIdAsc = "NUTRITION_DAY_ID_ASC",
  NutritionDayIdDesc = "NUTRITION_DAY_ID_DESC",
  NutritionPlanIdAsc = "NUTRITION_PLAN_ID_ASC",
  NutritionPlanIdDesc = "NUTRITION_PLAN_ID_DESC",
  OrderIndexAsc = "ORDER_INDEX_ASC",
  OrderIndexDesc = "ORDER_INDEX_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** A connection to a list of `NutritionPlan` values. */
export interface INutritionPlansConnection {
   __typename?: "NutritionPlansConnection";
  /** A list of `NutritionPlan` objects. */
  nodes: Array<Maybe<INutritionPlan>>;
  /** A list of edges which contains the `NutritionPlan` and cursor to aid in pagination. */
  edges: INutritionPlansEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionPlan` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionPlan` edge in the connection. */
export interface INutritionPlansEdge {
   __typename?: "NutritionPlansEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionPlan` at the end of the edge. */
  node?: Maybe<INutritionPlan>;
}

/** Methods to use when ordering `NutritionPlan`. */
export enum INutritionPlansOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  AuthorIdAsc = "AUTHOR_ID_ASC",
  AuthorIdDesc = "AUTHOR_ID_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  DurationAsc = "DURATION_ASC",
  DurationDesc = "DURATION_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface INutritionProfile  extends INode {
   __typename?: "NutritionProfile";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  memberId: Scalars["Int"];
  label?: Maybe<Scalars["String"]>;
  macros?: Maybe<IMacro>;
  days?: Maybe<Array<Maybe<Scalars["String"]>>>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  startDate?: Maybe<Scalars["Date"]>;
  /** Reads a single `Member` that is related to this `NutritionProfile`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads and enables pagination through a set of `NutritionProfileMeal`. */
  nutritionProfileMealsByNutritionProfileId: INutritionProfileMealsConnection;
}

export interface INutritionProfileNutritionProfileMealsByNutritionProfileIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionProfileMealsOrderBy[]>;
  condition?: Maybe<INutritionProfileMealCondition>;
}

/**
 * A condition to be used against `NutritionProfile` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionProfileCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `macros` field. */
  macros?: Maybe<IMacroInput>;
  /** Checks for equality with the object’s `days` field. */
  days?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars["Date"]>;
}

/** An input for mutations affecting `NutritionProfile` */
export interface INutritionProfileInput {
  id?: Maybe<Scalars["Int"]>;
  memberId: Scalars["Int"];
  label?: Maybe<Scalars["String"]>;
  macros?: Maybe<IMacroInput>;
  days?: Maybe<Array<Maybe<Scalars["String"]>>>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  startDate?: Maybe<Scalars["Date"]>;
}

export interface INutritionProfileMeal  extends INode {
   __typename?: "NutritionProfileMeal";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  nutritionProfileId?: Maybe<Scalars["Int"]>;
  macros?: Maybe<IMacro>;
  order?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `NutritionProfile` that is related to this `NutritionProfileMeal`. */
  nutritionProfileByNutritionProfileId?: Maybe<INutritionProfile>;
}

/**
 * A condition to be used against `NutritionProfileMeal` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionProfileMealCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `nutritionProfileId` field. */
  nutritionProfileId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `macros` field. */
  macros?: Maybe<IMacroInput>;
  /** Checks for equality with the object’s `order` field. */
  order?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `NutritionProfileMeal` */
export interface INutritionProfileMealInput {
  id?: Maybe<Scalars["Uuid"]>;
  nutritionProfileId?: Maybe<Scalars["Int"]>;
  macros?: Maybe<IMacroInput>;
  order?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `NutritionProfileMeal`. Fields that are set will be updated. */
export interface INutritionProfileMealPatch {
  id?: Maybe<Scalars["Uuid"]>;
  nutritionProfileId?: Maybe<Scalars["Int"]>;
  macros?: Maybe<IMacroInput>;
  order?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `NutritionProfileMeal` values. */
export interface INutritionProfileMealsConnection {
   __typename?: "NutritionProfileMealsConnection";
  /** A list of `NutritionProfileMeal` objects. */
  nodes: Array<Maybe<INutritionProfileMeal>>;
  /** A list of edges which contains the `NutritionProfileMeal` and cursor to aid in pagination. */
  edges: INutritionProfileMealsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionProfileMeal` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionProfileMeal` edge in the connection. */
export interface INutritionProfileMealsEdge {
   __typename?: "NutritionProfileMealsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionProfileMeal` at the end of the edge. */
  node?: Maybe<INutritionProfileMeal>;
}

/** Methods to use when ordering `NutritionProfileMeal`. */
export enum INutritionProfileMealsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NutritionProfileIdAsc = "NUTRITION_PROFILE_ID_ASC",
  NutritionProfileIdDesc = "NUTRITION_PROFILE_ID_DESC",
  MacrosAsc = "MACROS_ASC",
  MacrosDesc = "MACROS_DESC",
  OrderAsc = "ORDER_ASC",
  OrderDesc = "ORDER_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** Represents an update to a `NutritionProfile`. Fields that are set will be updated. */
export interface INutritionProfilePatch {
  id?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  label?: Maybe<Scalars["String"]>;
  macros?: Maybe<IMacroInput>;
  days?: Maybe<Array<Maybe<Scalars["String"]>>>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  startDate?: Maybe<Scalars["Date"]>;
}

/** A connection to a list of `NutritionProfile` values. */
export interface INutritionProfilesConnection {
   __typename?: "NutritionProfilesConnection";
  /** A list of `NutritionProfile` objects. */
  nodes: Array<Maybe<INutritionProfile>>;
  /** A list of edges which contains the `NutritionProfile` and cursor to aid in pagination. */
  edges: INutritionProfilesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionProfile` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionProfile` edge in the connection. */
export interface INutritionProfilesEdge {
   __typename?: "NutritionProfilesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionProfile` at the end of the edge. */
  node?: Maybe<INutritionProfile>;
}

/** Methods to use when ordering `NutritionProfile`. */
export enum INutritionProfilesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  LabelAsc = "LABEL_ASC",
  LabelDesc = "LABEL_DESC",
  MacrosAsc = "MACROS_ASC",
  MacrosDesc = "MACROS_DESC",
  DaysAsc = "DAYS_ASC",
  DaysDesc = "DAYS_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  StartDateAsc = "START_DATE_ASC",
  StartDateDesc = "START_DATE_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface INutritionStreakInfo {
   __typename?: "NutritionStreakInfo";
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  streak?: Maybe<Scalars["Int"]>;
}

/** A connection to a list of `NutritionSummary` values. */
export interface INutritionSummariesConnection {
   __typename?: "NutritionSummariesConnection";
  /** A list of `NutritionSummary` objects. */
  nodes: Array<Maybe<INutritionSummary>>;
  /** A list of edges which contains the `NutritionSummary` and cursor to aid in pagination. */
  edges: INutritionSummariesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `NutritionSummary` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `NutritionSummary` edge in the connection. */
export interface INutritionSummariesEdge {
   __typename?: "NutritionSummariesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `NutritionSummary` at the end of the edge. */
  node?: Maybe<INutritionSummary>;
}

/** Methods to use when ordering `NutritionSummary`. */
export enum INutritionSummariesOrderBy {
  Natural = "NATURAL",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  SummaryAsc = "SUMMARY_ASC",
  SummaryDesc = "SUMMARY_DESC",
}

export interface INutritionSummary {
   __typename?: "NutritionSummary";
  createdAt?: Maybe<Scalars["Datetime"]>;
  memberId?: Maybe<Scalars["Int"]>;
  summary?: Maybe<Scalars["String"]>;
}

/**
 * A condition to be used against `NutritionSummary` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface INutritionSummaryCondition {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars["String"]>;
}

export interface IOldCoach {
   __typename?: "OldCoach";
  id: Scalars["Int"];
  firstName: Scalars["String"];
  lastName: Scalars["String"];
  fullName: Scalars["String"];
}

export interface IOldTrainingProgram {
   __typename?: "OldTrainingProgram";
  id: Scalars["ID"];
  name: Scalars["String"];
  notes?: Maybe<Scalars["String"]>;
  duration?: Maybe<Scalars["Int"]>;
  cycles?: Maybe<Scalars["Json"]>;
}

export interface IOldWorkout {
   __typename?: "OldWorkout";
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  duration?: Maybe<Scalars["String"]>;
  body: Scalars["Json"];
  isArchived: Scalars["Boolean"];
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
}

export interface IOldWorkoutNodeEvent {
   __typename?: "OldWorkoutNodeEvent";
  id: Scalars["Uuid"];
  payload: Scalars["Json"];
}

export interface IOrganisation {
   __typename?: "Organisation";
  id: Scalars["Uuid"];
  name: Scalars["String"];
  contactEmail?: Maybe<Scalars["String"]>;
  status: IOrgStatus;
  countryId: Scalars["Int"];
  comment?: Maybe<Scalars["String"]>;
  memberGroupId?: Maybe<Scalars["Uuid"]>;
  coachGroupId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `Organisation` values. */
export interface IOrganisationsConnection {
   __typename?: "OrganisationsConnection";
  /** A list of `Organisation` objects. */
  nodes: Array<Maybe<IOrganisation>>;
  /** A list of edges which contains the `Organisation` and cursor to aid in pagination. */
  edges: IOrganisationsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
}

/** A `Organisation` edge in the connection. */
export interface IOrganisationsEdge {
   __typename?: "OrganisationsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Organisation` at the end of the edge. */
  node?: Maybe<IOrganisation>;
}

export enum IOrgStatus {
  Active = "ACTIVE",
  NeedAttention = "NEED_ATTENTION",
  Disabled = "DISABLED",
}

/** A connection to a list of `OrgSummary` values. */
export interface IOrgSummariesConnection {
   __typename?: "OrgSummariesConnection";
  /** A list of `OrgSummary` objects. */
  nodes: Array<Maybe<IOrgSummary>>;
  /** A list of edges which contains the `OrgSummary` and cursor to aid in pagination. */
  edges: IOrgSummariesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `OrgSummary` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `OrgSummary` edge in the connection. */
export interface IOrgSummariesEdge {
   __typename?: "OrgSummariesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `OrgSummary` at the end of the edge. */
  node?: Maybe<IOrgSummary>;
}

/** Methods to use when ordering `OrgSummary`. */
export enum IOrgSummariesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  UserCountAsc = "USER_COUNT_ASC",
  UserCountDesc = "USER_COUNT_DESC",
  CoachCountAsc = "COACH_COUNT_ASC",
  CoachCountDesc = "COACH_COUNT_DESC",
  MemberCountAsc = "MEMBER_COUNT_ASC",
  MemberCountDesc = "MEMBER_COUNT_DESC",
}

export interface IOrgSummary {
   __typename?: "OrgSummary";
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  userCount?: Maybe<Scalars["BigInt"]>;
  coachCount?: Maybe<Scalars["BigInt"]>;
  memberCount?: Maybe<Scalars["BigInt"]>;
}

/**
 * A condition to be used against `OrgSummary` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IOrgSummaryCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `userCount` field. */
  userCount?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `coachCount` field. */
  coachCount?: Maybe<Scalars["BigInt"]>;
  /** Checks for equality with the object’s `memberCount` field. */
  memberCount?: Maybe<Scalars["BigInt"]>;
}

/** All input for the `overrideExercise` mutation. */
export interface IOverrideExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  exerciseId: Scalars["Uuid"];
  name: Scalars["String"];
  description: Scalars["String"];
  meta: Scalars["Json"];
  type: Scalars["String"];
  targetMuscle: Scalars["String"];
  knownAs: Scalars["String"];
  equipment: Scalars["String"];
  alternatives: Scalars["Json"];
  family: Scalars["String"];
  instructions: Scalars["String"];
  media: Array<Maybe<Scalars["String"]>>;
}

/** The output of our `overrideExercise` mutation. */
export interface IOverrideExercisePayload {
   __typename?: "OverrideExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  exerciseOverride?: Maybe<IExerciseOverride>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Exercise` that is related to this `ExerciseOverride`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `ExerciseOverride`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `ExerciseOverride`. May be used by Relay 1. */
  exerciseOverrideEdge?: Maybe<IExerciseOverridesEdge>;
}

/** The output of our `overrideExercise` mutation. */
export interface IOverrideExercisePayloadExerciseOverrideEdgeArgs {
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
}

/** Information about pagination in a connection. */
export interface IPageInfo {
   __typename?: "PageInfo";
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["Cursor"]>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["Cursor"]>;
}

export enum IPersonStatus {
  Active = "ACTIVE",
  PendingInvite = "PENDING_INVITE",
  Suspended = "SUSPENDED",
  Invited = "INVITED",
  Archived = "ARCHIVED",
  Deleted = "DELETED",
}

export enum IPlanDayType {
  Day = "DAY",
  Rest = "REST",
}

/** An input for mutations affecting `PlanSequenceItem` */
export interface IPlanSequenceItemInput {
  dayType?: Maybe<IPlanDayType>;
  dayId?: Maybe<Scalars["Uuid"]>;
  orderIndex?: Maybe<Scalars["Int"]>;
}

/** All input for the `populateSessionAttendance` mutation. */
export interface IPopulateSessionAttendanceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  personIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  sessionId?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  timestamp?: Maybe<Scalars["Datetime"]>;
  attended?: Maybe<Scalars["Boolean"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  cancelled?: Maybe<Scalars["Boolean"]>;
}

/** The output of our `populateSessionAttendance` mutation. */
export interface IPopulateSessionAttendancePayload {
   __typename?: "PopulateSessionAttendancePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  session?: Maybe<ISession>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<ISessionsEdge>;
}

/** The output of our `populateSessionAttendance` mutation. */
export interface IPopulateSessionAttendancePayloadSessionEdgeArgs {
  orderBy?: Maybe<ISessionsOrderBy[]>;
}

/** All input for the `processReservations` mutation. */
export interface IProcessReservationsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
}

/** The output of our `processReservations` mutation. */
export interface IProcessReservationsPayload {
   __typename?: "ProcessReservationsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  reservationRequests?: Maybe<Array<Maybe<IReservationRequest>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByPrevTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `ReservationRequest`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `ReservationRequest`. May be used by Relay 1. */
  reservationRequestEdge?: Maybe<IReservationRequestsEdge>;
}

/** The output of our `processReservations` mutation. */
export interface IProcessReservationsPayloadReservationRequestEdgeArgs {
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
}

export interface IProfilePictureResponse {
   __typename?: "ProfilePictureResponse";
  profilePictureDirectory: Scalars["String"];
}

export interface IProgramWorkout  extends INode {
   __typename?: "ProgramWorkout";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  programId: Scalars["Int"];
  workoutId: Scalars["Uuid"];
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `TrainingProgram` that is related to this `ProgramWorkout`. */
  trainingProgramByProgramId?: Maybe<ITrainingProgram>;
  /** Reads a single `Workout` that is related to this `ProgramWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
}

/**
 * A condition to be used against `ProgramWorkout` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IProgramWorkoutCondition {
  /** Checks for equality with the object’s `programId` field. */
  programId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `workoutId` field. */
  workoutId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `ProgramWorkout` */
export interface IProgramWorkoutInput {
  programId: Scalars["Int"];
  workoutId: Scalars["Uuid"];
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `ProgramWorkout`. Fields that are set will be updated. */
export interface IProgramWorkoutPatch {
  programId?: Maybe<Scalars["Int"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `ProgramWorkout` values. */
export interface IProgramWorkoutsConnection {
   __typename?: "ProgramWorkoutsConnection";
  /** A list of `ProgramWorkout` objects. */
  nodes: Array<Maybe<IProgramWorkout>>;
  /** A list of edges which contains the `ProgramWorkout` and cursor to aid in pagination. */
  edges: IProgramWorkoutsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ProgramWorkout` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ProgramWorkout` edge in the connection. */
export interface IProgramWorkoutsEdge {
   __typename?: "ProgramWorkoutsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ProgramWorkout` at the end of the edge. */
  node?: Maybe<IProgramWorkout>;
}

/** Methods to use when ordering `ProgramWorkout`. */
export enum IProgramWorkoutsOrderBy {
  Natural = "NATURAL",
  ProgramIdAsc = "PROGRAM_ID_ASC",
  ProgramIdDesc = "PROGRAM_ID_DESC",
  WorkoutIdAsc = "WORKOUT_ID_ASC",
  WorkoutIdDesc = "WORKOUT_ID_DESC",
  SortOrderAsc = "SORT_ORDER_ASC",
  SortOrderDesc = "SORT_ORDER_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IProgressPicture {
   __typename?: "ProgressPicture";
  id: Scalars["ID"];
  localPath?: Maybe<Scalars["String"]>;
  userId: Scalars["ID"];
  isPrivate: Scalars["Boolean"];
  comment?: Maybe<Scalars["String"]>;
  originalUrl: Scalars["String"];
  previewUrl: Scalars["String"];
}

export interface IProgressPicturesConnection {
   __typename?: "ProgressPicturesConnection";
  /** List of available pictures */
  nodes: IProgressPicture[];
  /** Total number of pictures */
  totalCount: Scalars["Int"];
}

export interface IQuery {
   __typename?: "Query";
  keystoneFoodSearch?: Maybe<IKeystoneFoodSearchResult>;
  dummyFoodbank?: Maybe<Scalars["String"]>;
  dummy?: Maybe<Scalars["String"]>;
  /**
 * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
 **/
  query: IQuery;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars["ID"];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<INode>;
  /** Reads and enables pagination through a set of `ClubSummary`. */
  allClubSummaries?: Maybe<IClubSummariesConnection>;
  /** Reads and enables pagination through a set of `Coach`. */
  allCoaches?: Maybe<ICoachesConnection>;
  /** Reads and enables pagination through a set of `Exercise`. */
  allExercises?: Maybe<IExercisesConnection>;
  /** Reads and enables pagination through a set of `ExerciseOverride`. */
  allExerciseOverrides?: Maybe<IExerciseOverridesConnection>;
  /** Reads and enables pagination through a set of `FavouriteFood`. */
  allFavouriteFoods?: Maybe<IFavouriteFoodsConnection>;
  /** Reads and enables pagination through a set of `Food`. */
  allFoods?: Maybe<IFoodsConnection>;
  /** Reads and enables pagination through a set of `HistoryAction`. */
  allHistoryActions?: Maybe<IHistoryActionsConnection>;
  /** Reads and enables pagination through a set of `Location`. */
  allLocations?: Maybe<ILocationsConnection>;
  /** Reads and enables pagination through a set of `Manager`. */
  allManagers?: Maybe<IManagersConnection>;
  /** Reads and enables pagination through a set of `ManagerClubOrg`. */
  allManagerClubOrgs?: Maybe<IManagerClubOrgsConnection>;
  /** Reads and enables pagination through a set of `MealItem`. */
  allMealItems?: Maybe<IMealItemsConnection>;
  /** Reads and enables pagination through a set of `Member`. */
  allMembers?: Maybe<IMembersConnection>;
  /** Reads and enables pagination through a set of `MemberCheckin`. */
  allMemberCheckins?: Maybe<IMemberCheckinsConnection>;
  /** Reads and enables pagination through a set of `MemberEvaluatedRecipe`. */
  allMemberEvaluatedRecipes?: Maybe<IMemberEvaluatedRecipesConnection>;
  /** Reads and enables pagination through a set of `MemberFavouriteFood`. */
  allMemberFavouriteFoods?: Maybe<IMemberFavouriteFoodsConnection>;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  allMemberMeals?: Maybe<IMemberMealsConnection>;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  allMemberMetrics?: Maybe<IMemberMetricsConnection>;
  /** Reads and enables pagination through a set of `MemberMyFood`. */
  allMemberMyFoods?: Maybe<IMemberMyFoodsConnection>;
  /** Reads and enables pagination through a set of `MemberNutritionMetric`. */
  allMemberNutritionMetrics?: Maybe<IMemberNutritionMetricsConnection>;
  /** Reads and enables pagination through a set of `MemberNutritionPlan`. */
  allMemberNutritionPlans?: Maybe<IMemberNutritionPlansConnection>;
  /** Reads and enables pagination through a set of `MemberRecentFood`. */
  allMemberRecentFoods?: Maybe<IMemberRecentFoodsConnection>;
  /** Reads and enables pagination through a set of `MemberRecipe`. */
  allMemberRecipes?: Maybe<IMemberRecipesConnection>;
  /** Reads and enables pagination through a set of `MemberReminder`. */
  allMemberReminders?: Maybe<IMemberRemindersConnection>;
  /** Reads and enables pagination through a set of `MemberStepsMetric`. */
  allMemberStepsMetrics?: Maybe<IMemberStepsMetricsConnection>;
  /** Reads and enables pagination through a set of `MemberTag`. */
  allMemberTags?: Maybe<IMemberTagsConnection>;
  /** Reads and enables pagination through a set of `MemberTrainingProgram`. */
  allMemberTrainingPrograms?: Maybe<IMemberTrainingProgramsConnection>;
  /** Reads and enables pagination through a set of `MemberWaterMetric`. */
  allMemberWaterMetrics?: Maybe<IMemberWaterMetricsConnection>;
  /** Reads and enables pagination through a set of `MemberWorkout`. */
  allMemberWorkouts?: Maybe<IMemberWorkoutsConnection>;
  /** Reads and enables pagination through a set of `MentorEvent`. */
  allMentorEvents?: Maybe<IMentorEventsConnection>;
  /** Reads and enables pagination through a set of `MentoringReport`. */
  allMentoringReports?: Maybe<IMentoringReportsConnection>;
  /** Reads and enables pagination through a set of `MentoringReportMessage`. */
  allMentoringReportMessages?: Maybe<IMentoringReportMessagesConnection>;
  /** Reads and enables pagination through a set of `Notification`. */
  allNotifications?: Maybe<INotificationsConnection>;
  /** Reads and enables pagination through a set of `NutritionDay`. */
  allNutritionDays?: Maybe<INutritionDaysConnection>;
  /** Reads and enables pagination through a set of `NutritionDayMeal`. */
  allNutritionDayMeals?: Maybe<INutritionDayMealsConnection>;
  /** Reads and enables pagination through a set of `NutritionPlan`. */
  allNutritionPlans?: Maybe<INutritionPlansConnection>;
  /** Reads and enables pagination through a set of `NutritionPlanDay`. */
  allNutritionPlanDays?: Maybe<INutritionPlanDaysConnection>;
  /** Reads and enables pagination through a set of `NutritionPlanSchedule`. */
  allNutritionPlanSchedules?: Maybe<INutritionPlanSchedulesConnection>;
  /** Reads and enables pagination through a set of `NutritionProfile`. */
  allNutritionProfiles?: Maybe<INutritionProfilesConnection>;
  /** Reads and enables pagination through a set of `NutritionProfileMeal`. */
  allNutritionProfileMeals?: Maybe<INutritionProfileMealsConnection>;
  /** Reads and enables pagination through a set of `NutritionSummary`. */
  allNutritionSummaries?: Maybe<INutritionSummariesConnection>;
  /** Reads and enables pagination through a set of `OrgSummary`. */
  allOrgSummaries?: Maybe<IOrgSummariesConnection>;
  /** Reads and enables pagination through a set of `ProgramWorkout`. */
  allProgramWorkouts?: Maybe<IProgramWorkoutsConnection>;
  /** Reads and enables pagination through a set of `RecentFood`. */
  allRecentFoods?: Maybe<IRecentFoodsConnection>;
  /** Reads and enables pagination through a set of `Setting`. */
  allSettings?: Maybe<ISettingsConnection>;
  /** Reads and enables pagination through a set of `Tag`. */
  allTags?: Maybe<ITagsConnection>;
  /** Reads and enables pagination through a set of `TopLift`. */
  allTopLifts?: Maybe<ITopLiftsConnection>;
  /** Reads and enables pagination through a set of `TrainingProgram`. */
  allTrainingPrograms?: Maybe<ITrainingProgramsConnection>;
  /** Reads and enables pagination through a set of `UserSetting`. */
  allUserSettings?: Maybe<IUserSettingsConnection>;
  /** Reads and enables pagination through a set of `WeeklyCaloricIntake`. */
  allWeeklyCaloricIntakes?: Maybe<IWeeklyCaloricIntakesConnection>;
  /** Reads and enables pagination through a set of `Workout`. */
  allWorkouts?: Maybe<IWorkoutsConnection>;
  /** Reads and enables pagination through a set of `WorkoutExercise`. */
  allWorkoutExercises?: Maybe<IWorkoutExercisesConnection>;
  /** Reads and enables pagination through a set of `WorkoutExerciseAttempt`. */
  allWorkoutExerciseAttempts?: Maybe<IWorkoutExerciseAttemptsConnection>;
  /** Reads and enables pagination through a set of `WorkoutNode`. */
  allWorkoutNodes?: Maybe<IWorkoutNodesConnection>;
  /** Reads and enables pagination through a set of `WorkoutNodeEvent`. */
  allWorkoutNodeEvents?: Maybe<IWorkoutNodeEventsConnection>;
  /** Reads and enables pagination through a set of `Brand`. */
  allBrands?: Maybe<IBrandsConnection>;
  /** Reads and enables pagination through a set of `BrandBarcode`. */
  allBrandBarcodes?: Maybe<IBrandBarcodesConnection>;
  /** Reads and enables pagination through a set of `Category`. */
  allCategories?: Maybe<ICategoriesConnection>;
  /** Reads and enables pagination through a set of `Composition`. */
  allCompositions?: Maybe<ICompositionsConnection>;
  /** Reads and enables pagination through a set of `Country`. */
  allCountries?: Maybe<ICountriesConnection>;
  /** Reads and enables pagination through a set of `DataSource`. */
  allDataSources?: Maybe<IDataSourcesConnection>;
  /** Reads and enables pagination through a set of `FoodbankFood`. */
  allFoodbankFoods?: Maybe<IFoodbankFoodsConnection>;
  /** Reads and enables pagination through a set of `FoodCategory`. */
  allFoodCategories?: Maybe<IFoodCategoriesConnection>;
  /** Reads and enables pagination through a set of `Gtin`. */
  allGtins?: Maybe<IGtinsConnection>;
  /** Reads and enables pagination through a set of `NutritionDictionary`. */
  allNutritionDictionaries?: Maybe<INutritionDictionariesConnection>;
  /** Reads and enables pagination through a set of `FoodbankNutritionFact`. */
  allFoodbankNutritionFacts?: Maybe<IFoodbankNutritionFactsConnection>;
  /** Reads and enables pagination through a set of `Serving`. */
  allServings?: Maybe<IServingsConnection>;
  /** Reads and enables pagination through a set of `Attendance`. */
  allAttendances?: Maybe<IAttendancesConnection>;
  /** Reads and enables pagination through a set of `AttendanceHasOverrideFlagView`. */
  allAttendanceHasOverrideFlagViews?: Maybe<IAttendanceHasOverrideFlagViewsConnection>;
  /** Reads and enables pagination through a set of `AttendanceOverride`. */
  allAttendanceOverrides?: Maybe<IAttendanceOverridesConnection>;
  /** Reads and enables pagination through a set of `AttendanceStatsByDateView`. */
  allAttendanceStatsByDateViews?: Maybe<IAttendanceStatsByDateViewsConnection>;
  /** Reads and enables pagination through a set of `AttendanceStatsByPersonView`. */
  allAttendanceStatsByPersonViews?: Maybe<IAttendanceStatsByPersonViewsConnection>;
  /** Reads and enables pagination through a set of `Attendee`. */
  allAttendees?: Maybe<IAttendeesConnection>;
  /** Reads and enables pagination through a set of `AttendeeClub`. */
  allAttendeeClubs?: Maybe<IAttendeeClubsConnection>;
  /** Reads and enables pagination through a set of `Booking`. */
  allBookings?: Maybe<IBookingsConnection>;
  /** Reads and enables pagination through a set of `Class`. */
  allClasses?: Maybe<IClassesConnection>;
  /** Reads and enables pagination through a set of `ClassInstructor`. */
  allClassInstructors?: Maybe<IClassInstructorsConnection>;
  /** Reads and enables pagination through a set of `Club`. */
  allClubs?: Maybe<IClubsConnection>;
  /** Reads and enables pagination through a set of `DailyAttendanceView`. */
  allDailyAttendanceViews?: Maybe<IDailyAttendanceViewsConnection>;
  /** Reads and enables pagination through a set of `Instructor`. */
  allInstructors?: Maybe<IInstructorsConnection>;
  /** Reads and enables pagination through a set of `ReservationRequest`. */
  allReservationRequests?: Maybe<IReservationRequestsConnection>;
  /** Reads and enables pagination through a set of `Session`. */
  allSessions?: Maybe<ISessionsConnection>;
  /** Reads and enables pagination through a set of `SessionInstructor`. */
  allSessionInstructors?: Maybe<ISessionInstructorsConnection>;
  /** Reads and enables pagination through a set of `Timeslot`. */
  allTimeslots?: Maybe<ITimeslotsConnection>;
  coachById?: Maybe<ICoach>;
  exerciseById?: Maybe<IExercise>;
  exerciseOverrideByExerciseIdAndWorkspaceId?: Maybe<IExerciseOverride>;
  exerciseOverrideById?: Maybe<IExerciseOverride>;
  favouriteFoodById?: Maybe<IFavouriteFood>;
  foodById?: Maybe<IFood>;
  historyActionById?: Maybe<IHistoryAction>;
  locationById?: Maybe<ILocation>;
  managerById?: Maybe<IManager>;
  managerClubOrgById?: Maybe<IManagerClubOrg>;
  mealItemById?: Maybe<IMealItem>;
  memberById?: Maybe<IMember>;
  memberCheckinById?: Maybe<IMemberCheckin>;
  memberEvaluatedRecipeById?: Maybe<IMemberEvaluatedRecipe>;
  memberFavouriteFoodById?: Maybe<IMemberFavouriteFood>;
  memberFavouriteFoodByMemberIdAndFoodId?: Maybe<IMemberFavouriteFood>;
  memberFavouriteFoodByMemberIdAndLabelAndMacrosEntryId?: Maybe<IMemberFavouriteFood>;
  memberFavouriteFoodByMemberIdAndMyFoodId?: Maybe<IMemberFavouriteFood>;
  memberMealById?: Maybe<IMemberMeal>;
  memberMetricByMemberIdAndDateAndKey?: Maybe<IMemberMetric>;
  memberMyFoodById?: Maybe<IMemberMyFood>;
  memberNutritionMetricByMemberIdAndDate?: Maybe<IMemberNutritionMetric>;
  memberNutritionPlanById?: Maybe<IMemberNutritionPlan>;
  memberRecentFoodById?: Maybe<IMemberRecentFood>;
  memberRecentFoodByMemberIdAndFatSecretId?: Maybe<IMemberRecentFood>;
  memberRecentFoodByMemberIdAndMacroEntryId?: Maybe<IMemberRecentFood>;
  memberRecentFoodByMemberIdAndMyFoodId?: Maybe<IMemberRecentFood>;
  memberRecentFoodByMemberIdAndFoodId?: Maybe<IMemberRecentFood>;
  memberRecipeById?: Maybe<IMemberRecipe>;
  memberReminderById?: Maybe<IMemberReminder>;
  memberStepsMetricByMemberIdAndDate?: Maybe<IMemberStepsMetric>;
  memberTrainingProgramById?: Maybe<IMemberTrainingProgram>;
  memberWaterMetricById?: Maybe<IMemberWaterMetric>;
  memberWaterMetricByDateAndMemberId?: Maybe<IMemberWaterMetric>;
  memberWorkoutById?: Maybe<IMemberWorkout>;
  mentorEventById?: Maybe<IMentorEvent>;
  mentoringReportById?: Maybe<IMentoringReport>;
  mentoringReportByToken?: Maybe<IMentoringReport>;
  mentoringReportMessageById?: Maybe<IMentoringReportMessage>;
  notificationById?: Maybe<INotification>;
  nutritionDayById?: Maybe<INutritionDay>;
  nutritionDayMealByNutritionDayIdAndMealId?: Maybe<INutritionDayMeal>;
  nutritionPlanById?: Maybe<INutritionPlan>;
  nutritionPlanDayByNutritionPlanIdAndNutritionDayId?: Maybe<INutritionPlanDay>;
  nutritionPlanScheduleByNutritionPlanIdAndOrderIndex?: Maybe<INutritionPlanSchedule>;
  nutritionProfileById?: Maybe<INutritionProfile>;
  nutritionProfileMealById?: Maybe<INutritionProfileMeal>;
  programWorkoutByProgramIdAndWorkoutId?: Maybe<IProgramWorkout>;
  recentFoodById?: Maybe<IRecentFood>;
  settingById?: Maybe<ISetting>;
  settingByKey?: Maybe<ISetting>;
  tagById?: Maybe<ITag>;
  trainingProgramById?: Maybe<ITrainingProgram>;
  userSettingById?: Maybe<IUserSetting>;
  workoutById?: Maybe<IWorkout>;
  workoutExerciseByIdAndWorkoutIdAndExerciseId?: Maybe<IWorkoutExercise>;
  workoutNodeById?: Maybe<IWorkoutNode>;
  workoutNodeEventById?: Maybe<IWorkoutNodeEvent>;
  brandById?: Maybe<IBrand>;
  brandBarcodeByBrandIdAndGtinId?: Maybe<IBrandBarcode>;
  categoryById?: Maybe<ICategory>;
  compositionByFoodId?: Maybe<IComposition>;
  countryById?: Maybe<ICountry>;
  dataSourceById?: Maybe<IDataSource>;
  dataSourceBySourceName?: Maybe<IDataSource>;
  foodbankFoodById?: Maybe<IFoodbankFood>;
  foodCategoryByFoodIdAndCategoryId?: Maybe<IFoodCategory>;
  gtinByFoodIdAndGtin?: Maybe<IGtin>;
  nutritionDictionaryById?: Maybe<INutritionDictionary>;
  foodbankNutritionFactByFoodId?: Maybe<IFoodbankNutritionFact>;
  servingById?: Maybe<IServing>;
  attendanceBySessionIdAndPersonId?: Maybe<IAttendance>;
  attendanceById?: Maybe<IAttendance>;
  attendanceOverrideById?: Maybe<IAttendanceOverride>;
  attendeeById?: Maybe<IAttendee>;
  attendeeClubByAttendeeIdAndClubId?: Maybe<IAttendeeClub>;
  bookingById?: Maybe<IBooking>;
  classById?: Maybe<IClass>;
  classInstructorByClassIdAndInstructorId?: Maybe<IClassInstructor>;
  clubById?: Maybe<IClub>;
  clubByKsClubId?: Maybe<IClub>;
  instructorById?: Maybe<IInstructor>;
  reservationRequestById?: Maybe<IReservationRequest>;
  sessionById?: Maybe<ISession>;
  sessionInstructorBySessionIdAndInstructorId?: Maybe<ISessionInstructor>;
  timeslotById?: Maybe<ITimeslot>;
  _foodServing?: Maybe<IFoodServing>;
  _nutritionFacts?: Maybe<INutritionFact>;
  /** Reads and enables pagination through a set of `Coach`. */
  allActiveCoaches: ICoachesConnection;
  /** Reads and enables pagination through a set of `Coach`. */
  allClubCoaches: ICoachesConnection;
  /** Reads and enables pagination through a set of `Member`. */
  allClubMembers: IMembersConnection;
  /** Reads and enables pagination through a set of `Feature`. */
  allFeatures: IFeaturesConnection;
  /** Reads and enables pagination through a set of `KsClub`. */
  allKsClubs: IKsClubsConnection;
  /** Reads and enables pagination through a set of `KsCountry`. */
  allKsCountries: IKsCountriesConnection;
  /** Reads and enables pagination through a set of `Organisation`. */
  allOrganisations: IOrganisationsConnection;
  /** Reads and enables pagination through a set of `Coach`. */
  allWorkspaceCoaches: ICoachesConnection;
  /** Reads and enables pagination through a set of `Member`. */
  allWorkspaceMembers: IMembersConnection;
  currentCoach?: Maybe<ICoach>;
  currentCoachId?: Maybe<Scalars["Int"]>;
  currentCoachLocationId?: Maybe<Scalars["Int"]>;
  currentMember?: Maybe<IMember>;
  currentMemberId?: Maybe<Scalars["Int"]>;
  /** Reads and enables pagination through a set of `Exercise`. */
  exercisesByIds: IExercisesConnection;
  fetchInvite?: Maybe<IInvite>;
  fetchInviteWithWorkspace?: Maybe<IWorkspaceInvite>;
  /** Reads and enables pagination through a set of `Food`. */
  foodByExternalIds: IFoodsConnection;
  /** Reads and enables pagination through a set of `Invite`. */
  getInvite: IInvitesConnection;
  insightBodyByMemberId?: Maybe<IInsightBody>;
  insightFeelingsByMemberId?: Maybe<IInsightFeeling>;
  insightNutritionByMemberId?: Maybe<IInsightNutritionNode>;
  insightTrainingByMemberId?: Maybe<IInsightTraining>;
  ksClubById?: Maybe<IKsClub>;
  ksClubsByOrgId?: Maybe<IKsClub>;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  latestFeelings: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  latestMeasurements: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  memberMealsByIds: IMemberMealsConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  memberMetricExtendedMeasurements: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  memberMetricKpis: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberMetric`. */
  memberMetricMeasurements: IMemberMetricsConnection;
  /** Reads and enables pagination through a set of `MemberNutritionHistoryItem`. */
  memberNutritionHistory: IMemberNutritionHistoryItemsConnection;
  /** Reads and enables pagination through a set of `MemberNutritionOverview`. */
  memberNutritionOverviewByMemberId: IMemberNutritionOverviewsConnection;
  memberNutritionStreak?: Maybe<INutritionStreakInfo>;
  /** Reads and enables pagination through a set of `MemberWorkout`. */
  memberWorkouts: IMemberWorkoutsConnection;
  /** Reads and enables pagination through a set of `MetricAverage`. */
  metricAverages: IMetricAveragesConnection;
  orgById?: Maybe<IOrganisation>;
  orgByKsClubId?: Maybe<IOrganisation>;
  programByWorkoutId?: Maybe<ITrainingProgram>;
  recipeByFoodId?: Maybe<IMemberEvaluatedRecipe>;
  /** Reads and enables pagination through a set of `Exercise`. */
  searchExercises: IExercisesConnection;
  /** Reads and enables pagination through a set of `Food`. */
  searchMyFood: IFoodsConnection;
  /** Reads and enables pagination through a set of `MemberMeal`. */
  searchMyMeals: IMemberMealsConnection;
  /** Reads and enables pagination through a set of `Tag`. */
  searchTags: ITagsConnection;
  /** Reads and enables pagination through a set of `Exercise`. */
  suggestExercises: IExercisesConnection;
  /** Reads and enables pagination through a set of `Tag`. */
  suggestTags: ITagsConnection;
  workoutByWorkoutId?: Maybe<IWorkoutNodeEvent>;
  checkCapacity?: Maybe<Scalars["Int"]>;
  countReservations?: Maybe<Scalars["Int"]>;
  currentAttendee?: Maybe<IAttendee>;
  currentAttendeeId?: Maybe<Scalars["Uuid"]>;
  currentClubId?: Maybe<Scalars["Uuid"]>;
  currentInstructor?: Maybe<IInstructor>;
  currentInstructorId?: Maybe<Scalars["Uuid"]>;
  /** Reads and enables pagination through a set of `Attendee`. */
  reportNoShows: IAttendeesConnection;
  /** Reads and enables pagination through a set of `QuottedAttendee`. */
  reportQuottedAttendance: IQuottedAttendeesConnection;
  /** Reads and enables pagination through a set of `MemberReservation`. */
  reservationsByAttendeeId: IMemberReservationsConnection;
  /** Reads and enables pagination through a set of `Member`. */
  searchBridgeMembers: IMembersConnection;
  /** Reads and enables pagination through a set of `SessionListItem`. */
  sessionsByDate: ISessionListItemsConnection;
  /** Reads a single `Coach` using its globally unique `ID`. */
  coach?: Maybe<ICoach>;
  /** Reads a single `Exercise` using its globally unique `ID`. */
  exercise?: Maybe<IExercise>;
  /** Reads a single `ExerciseOverride` using its globally unique `ID`. */
  exerciseOverride?: Maybe<IExerciseOverride>;
  /** Reads a single `FavouriteFood` using its globally unique `ID`. */
  favouriteFood?: Maybe<IFavouriteFood>;
  /** Reads a single `Food` using its globally unique `ID`. */
  food?: Maybe<IFood>;
  /** Reads a single `HistoryAction` using its globally unique `ID`. */
  historyAction?: Maybe<IHistoryAction>;
  /** Reads a single `Location` using its globally unique `ID`. */
  location?: Maybe<ILocation>;
  /** Reads a single `Manager` using its globally unique `ID`. */
  manager?: Maybe<IManager>;
  /** Reads a single `ManagerClubOrg` using its globally unique `ID`. */
  managerClubOrg?: Maybe<IManagerClubOrg>;
  /** Reads a single `MealItem` using its globally unique `ID`. */
  mealItem?: Maybe<IMealItem>;
  /** Reads a single `Member` using its globally unique `ID`. */
  member?: Maybe<IMember>;
  /** Reads a single `MemberCheckin` using its globally unique `ID`. */
  memberCheckin?: Maybe<IMemberCheckin>;
  /** Reads a single `MemberEvaluatedRecipe` using its globally unique `ID`. */
  memberEvaluatedRecipe?: Maybe<IMemberEvaluatedRecipe>;
  /** Reads a single `MemberFavouriteFood` using its globally unique `ID`. */
  memberFavouriteFood?: Maybe<IMemberFavouriteFood>;
  /** Reads a single `MemberMeal` using its globally unique `ID`. */
  memberMeal?: Maybe<IMemberMeal>;
  /** Reads a single `MemberMetric` using its globally unique `ID`. */
  memberMetric?: Maybe<IMemberMetric>;
  /** Reads a single `MemberMyFood` using its globally unique `ID`. */
  memberMyFood?: Maybe<IMemberMyFood>;
  /** Reads a single `MemberNutritionMetric` using its globally unique `ID`. */
  memberNutritionMetric?: Maybe<IMemberNutritionMetric>;
  /** Reads a single `MemberNutritionPlan` using its globally unique `ID`. */
  memberNutritionPlan?: Maybe<IMemberNutritionPlan>;
  /** Reads a single `MemberRecentFood` using its globally unique `ID`. */
  memberRecentFood?: Maybe<IMemberRecentFood>;
  /** Reads a single `MemberRecipe` using its globally unique `ID`. */
  memberRecipe?: Maybe<IMemberRecipe>;
  /** Reads a single `MemberReminder` using its globally unique `ID`. */
  memberReminder?: Maybe<IMemberReminder>;
  /** Reads a single `MemberStepsMetric` using its globally unique `ID`. */
  memberStepsMetric?: Maybe<IMemberStepsMetric>;
  /** Reads a single `MemberTrainingProgram` using its globally unique `ID`. */
  memberTrainingProgram?: Maybe<IMemberTrainingProgram>;
  /** Reads a single `MemberWaterMetric` using its globally unique `ID`. */
  memberWaterMetric?: Maybe<IMemberWaterMetric>;
  /** Reads a single `MemberWorkout` using its globally unique `ID`. */
  memberWorkout?: Maybe<IMemberWorkout>;
  /** Reads a single `MentorEvent` using its globally unique `ID`. */
  mentorEvent?: Maybe<IMentorEvent>;
  /** Reads a single `MentoringReport` using its globally unique `ID`. */
  mentoringReport?: Maybe<IMentoringReport>;
  /** Reads a single `MentoringReportMessage` using its globally unique `ID`. */
  mentoringReportMessage?: Maybe<IMentoringReportMessage>;
  /** Reads a single `Notification` using its globally unique `ID`. */
  notification?: Maybe<INotification>;
  /** Reads a single `NutritionDay` using its globally unique `ID`. */
  nutritionDay?: Maybe<INutritionDay>;
  /** Reads a single `NutritionDayMeal` using its globally unique `ID`. */
  nutritionDayMeal?: Maybe<INutritionDayMeal>;
  /** Reads a single `NutritionPlan` using its globally unique `ID`. */
  nutritionPlan?: Maybe<INutritionPlan>;
  /** Reads a single `NutritionPlanDay` using its globally unique `ID`. */
  nutritionPlanDay?: Maybe<INutritionPlanDay>;
  /** Reads a single `NutritionPlanSchedule` using its globally unique `ID`. */
  nutritionPlanSchedule?: Maybe<INutritionPlanSchedule>;
  /** Reads a single `NutritionProfile` using its globally unique `ID`. */
  nutritionProfile?: Maybe<INutritionProfile>;
  /** Reads a single `NutritionProfileMeal` using its globally unique `ID`. */
  nutritionProfileMeal?: Maybe<INutritionProfileMeal>;
  /** Reads a single `ProgramWorkout` using its globally unique `ID`. */
  programWorkout?: Maybe<IProgramWorkout>;
  /** Reads a single `RecentFood` using its globally unique `ID`. */
  recentFood?: Maybe<IRecentFood>;
  /** Reads a single `Setting` using its globally unique `ID`. */
  setting?: Maybe<ISetting>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tag?: Maybe<ITag>;
  /** Reads a single `TrainingProgram` using its globally unique `ID`. */
  trainingProgram?: Maybe<ITrainingProgram>;
  /** Reads a single `UserSetting` using its globally unique `ID`. */
  userSetting?: Maybe<IUserSetting>;
  /** Reads a single `Workout` using its globally unique `ID`. */
  workout?: Maybe<IWorkout>;
  /** Reads a single `WorkoutExercise` using its globally unique `ID`. */
  workoutExercise?: Maybe<IWorkoutExercise>;
  /** Reads a single `WorkoutNode` using its globally unique `ID`. */
  workoutNode?: Maybe<IWorkoutNode>;
  /** Reads a single `WorkoutNodeEvent` using its globally unique `ID`. */
  workoutNodeEvent?: Maybe<IWorkoutNodeEvent>;
  /** Reads a single `Brand` using its globally unique `ID`. */
  brand?: Maybe<IBrand>;
  /** Reads a single `BrandBarcode` using its globally unique `ID`. */
  brandBarcode?: Maybe<IBrandBarcode>;
  /** Reads a single `Category` using its globally unique `ID`. */
  category?: Maybe<ICategory>;
  /** Reads a single `Composition` using its globally unique `ID`. */
  composition?: Maybe<IComposition>;
  /** Reads a single `Country` using its globally unique `ID`. */
  country?: Maybe<ICountry>;
  /** Reads a single `DataSource` using its globally unique `ID`. */
  dataSource?: Maybe<IDataSource>;
  /** Reads a single `FoodbankFood` using its globally unique `ID`. */
  foodbankFood?: Maybe<IFoodbankFood>;
  /** Reads a single `FoodCategory` using its globally unique `ID`. */
  foodCategory?: Maybe<IFoodCategory>;
  /** Reads a single `Gtin` using its globally unique `ID`. */
  gtin?: Maybe<IGtin>;
  /** Reads a single `NutritionDictionary` using its globally unique `ID`. */
  nutritionDictionary?: Maybe<INutritionDictionary>;
  /** Reads a single `FoodbankNutritionFact` using its globally unique `ID`. */
  foodbankNutritionFact?: Maybe<IFoodbankNutritionFact>;
  /** Reads a single `Serving` using its globally unique `ID`. */
  serving?: Maybe<IServing>;
  /** Reads a single `Attendance` using its globally unique `ID`. */
  attendance?: Maybe<IAttendance>;
  /** Reads a single `AttendanceOverride` using its globally unique `ID`. */
  attendanceOverride?: Maybe<IAttendanceOverride>;
  /** Reads a single `Attendee` using its globally unique `ID`. */
  attendee?: Maybe<IAttendee>;
  /** Reads a single `AttendeeClub` using its globally unique `ID`. */
  attendeeClub?: Maybe<IAttendeeClub>;
  /** Reads a single `Booking` using its globally unique `ID`. */
  booking?: Maybe<IBooking>;
  /** Reads a single `Class` using its globally unique `ID`. */
  class?: Maybe<IClass>;
  /** Reads a single `ClassInstructor` using its globally unique `ID`. */
  classInstructor?: Maybe<IClassInstructor>;
  /** Reads a single `Club` using its globally unique `ID`. */
  club?: Maybe<IClub>;
  /** Reads a single `Instructor` using its globally unique `ID`. */
  instructor?: Maybe<IInstructor>;
  /** Reads a single `ReservationRequest` using its globally unique `ID`. */
  reservationRequest?: Maybe<IReservationRequest>;
  /** Reads a single `Session` using its globally unique `ID`. */
  session?: Maybe<ISession>;
  /** Reads a single `SessionInstructor` using its globally unique `ID`. */
  sessionInstructor?: Maybe<ISessionInstructor>;
  /** Reads a single `Timeslot` using its globally unique `ID`. */
  timeslot?: Maybe<ITimeslot>;
  memberWeeklyTrainingStat: IWeeklyTrainingStat;
  exerciseAttemptsByWorkoutId: IExerciseAttemptsConnection;
  workoutTemplateById?: Maybe<IWorkoutTemplate>;
  allWorkoutTemplates: IWorkoutTemplatesConnection;
  workoutTemplateSharingsByTemplateId: ISharingsConnection;
  workoutSessionById?: Maybe<IWorkoutSession>;
  memberWorkoutSessions: IWorkoutSessionsConnection;
  memberWorkoutSessionsByMonth: IWorkoutSessionsConnection;
  trainingPlanById?: Maybe<ITrainingPlan>;
  allTrainingPlans: ITrainingPlansConnection;
  trainingPlanAssignmentById?: Maybe<ITrainingPlanAssignment>;
  trainingPlanSharingsByPlanId: ISharingsConnection;
  workoutTemplateDirectoryById?: Maybe<IFullWorkoutTemplateDirectory>;
  allWorkoutTemplateDirectories: ITopLevelWorkoutTemplateDirectoriesConnection;
  /** META */
  allAvailableClubs: IKeystoneClubsConnection;
  allAvailableOrgs: IKeystoneOrgsConnection;
  allEnabledFeatures: IKeystoneFeaturesConnection;
  /** PROGRESS PICTURES */
  allProgressPictures: IProgressPicturesConnection;
  progressPicturesByDate: IProgressPicturesConnection;
  progressPicturesByInterval: IProgressPicturesConnection;
  metricByInterval: IMetricByIntervalPayload;
  metricDayByDate?: Maybe<IUserMetricDay>;
  lastMetricsByDate: ILastMetricsByDatePayload;
  metricsTimelineByUser: IMetricsTimelinePayload;
  allFoodJournalDaysByDateInterval: IFoodJournalPreviewDatesConnection;
  foodJournalDayByDate: IFoodJournalDate;
  allFoodJournalFood: IFoodJournalFoodConnection;
  randomFoodRequest: IKeystoneFoodRequestPayload;
  allBrandsByName: IKeystoneFoodBrandsConnection;
  allFoodJournalTargetTemplates: IFoodJournalDayTargetTemplatesConnection;
  allFoodJournalTargetsByUser: IFoodJournalUserTargetsConnection;
  foodbankFoodByBarcode: IKsFoodbankFoodItemsConnection;
}

export interface IQueryKeystoneFoodSearchArgs {
  term?: Maybe<Scalars["String"]>;
  meta?: Maybe<IKeystoneSearchInput>;
}

export interface IQueryNodeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryAllClubSummariesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClubSummariesOrderBy[]>;
  condition?: Maybe<IClubSummaryCondition>;
}

export interface IQueryAllCoachesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICoachesOrderBy[]>;
  condition?: Maybe<ICoachCondition>;
}

export interface IQueryAllExercisesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IExercisesOrderBy[]>;
  condition?: Maybe<IExerciseCondition>;
}

export interface IQueryAllExerciseOverridesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
  condition?: Maybe<IExerciseOverrideCondition>;
}

export interface IQueryAllFavouriteFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
  condition?: Maybe<IFavouriteFoodCondition>;
}

export interface IQueryAllFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodsOrderBy[]>;
  condition?: Maybe<IFoodCondition>;
}

export interface IQueryAllHistoryActionsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IHistoryActionsOrderBy[]>;
  condition?: Maybe<IHistoryActionCondition>;
}

export interface IQueryAllLocationsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ILocationsOrderBy[]>;
  condition?: Maybe<ILocationCondition>;
}

export interface IQueryAllManagersArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IManagersOrderBy[]>;
  condition?: Maybe<IManagerCondition>;
}

export interface IQueryAllManagerClubOrgsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IManagerClubOrgsOrderBy[]>;
  condition?: Maybe<IManagerClubOrgCondition>;
}

export interface IQueryAllMealItemsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMealItemsOrderBy[]>;
  condition?: Maybe<IMealItemCondition>;
}

export interface IQueryAllMembersArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMembersOrderBy[]>;
  condition?: Maybe<IMemberCondition>;
}

export interface IQueryAllMemberCheckinsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
  condition?: Maybe<IMemberCheckinCondition>;
}

export interface IQueryAllMemberEvaluatedRecipesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
  condition?: Maybe<IMemberEvaluatedRecipeCondition>;
}

export interface IQueryAllMemberFavouriteFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberFavouriteFoodsOrderBy[]>;
  condition?: Maybe<IMemberFavouriteFoodCondition>;
}

export interface IQueryAllMemberMealsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
  condition?: Maybe<IMemberMealCondition>;
}

export interface IQueryAllMemberMetricsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
  condition?: Maybe<IMemberMetricCondition>;
}

export interface IQueryAllMemberMyFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberMyFoodsOrderBy[]>;
  condition?: Maybe<IMemberMyFoodCondition>;
}

export interface IQueryAllMemberNutritionMetricsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
  condition?: Maybe<IMemberNutritionMetricCondition>;
}

export interface IQueryAllMemberNutritionPlansArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
  condition?: Maybe<IMemberNutritionPlanCondition>;
}

export interface IQueryAllMemberRecentFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
  condition?: Maybe<IMemberRecentFoodCondition>;
}

export interface IQueryAllMemberRecipesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
  condition?: Maybe<IMemberRecipeCondition>;
}

export interface IQueryAllMemberRemindersArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
  condition?: Maybe<IMemberReminderCondition>;
}

export interface IQueryAllMemberStepsMetricsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberStepsMetricsOrderBy[]>;
  condition?: Maybe<IMemberStepsMetricCondition>;
}

export interface IQueryAllMemberTagsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTagsOrderBy[]>;
  condition?: Maybe<IMemberTagCondition>;
}

export interface IQueryAllMemberTrainingProgramsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
  condition?: Maybe<IMemberTrainingProgramCondition>;
}

export interface IQueryAllMemberWaterMetricsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
  condition?: Maybe<IMemberWaterMetricCondition>;
}

export interface IQueryAllMemberWorkoutsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
  condition?: Maybe<IMemberWorkoutCondition>;
}

export interface IQueryAllMentorEventsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentorEventsOrderBy[]>;
  condition?: Maybe<IMentorEventCondition>;
}

export interface IQueryAllMentoringReportsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
  condition?: Maybe<IMentoringReportCondition>;
}

export interface IQueryAllMentoringReportMessagesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
  condition?: Maybe<IMentoringReportMessageCondition>;
}

export interface IQueryAllNotificationsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INotificationsOrderBy[]>;
  condition?: Maybe<INotificationCondition>;
}

export interface IQueryAllNutritionDaysArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
  condition?: Maybe<INutritionDayCondition>;
}

export interface IQueryAllNutritionDayMealsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
  condition?: Maybe<INutritionDayMealCondition>;
}

export interface IQueryAllNutritionPlansArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
  condition?: Maybe<INutritionPlanCondition>;
}

export interface IQueryAllNutritionPlanDaysArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
  condition?: Maybe<INutritionPlanDayCondition>;
}

export interface IQueryAllNutritionPlanSchedulesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
  condition?: Maybe<INutritionPlanScheduleCondition>;
}

export interface IQueryAllNutritionProfilesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionProfilesOrderBy[]>;
  condition?: Maybe<INutritionProfileCondition>;
}

export interface IQueryAllNutritionProfileMealsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionProfileMealsOrderBy[]>;
  condition?: Maybe<INutritionProfileMealCondition>;
}

export interface IQueryAllNutritionSummariesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionSummariesOrderBy[]>;
  condition?: Maybe<INutritionSummaryCondition>;
}

export interface IQueryAllOrgSummariesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IOrgSummariesOrderBy[]>;
  condition?: Maybe<IOrgSummaryCondition>;
}

export interface IQueryAllProgramWorkoutsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
  condition?: Maybe<IProgramWorkoutCondition>;
}

export interface IQueryAllRecentFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
  condition?: Maybe<IRecentFoodCondition>;
}

export interface IQueryAllSettingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISettingsOrderBy[]>;
  condition?: Maybe<ISettingCondition>;
}

export interface IQueryAllTagsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITagsOrderBy[]>;
  condition?: Maybe<ITagCondition>;
}

export interface IQueryAllTopLiftsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITopLiftsOrderBy[]>;
  condition?: Maybe<ITopLiftCondition>;
}

export interface IQueryAllTrainingProgramsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITrainingProgramsOrderBy[]>;
  condition?: Maybe<ITrainingProgramCondition>;
}

export interface IQueryAllUserSettingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
  condition?: Maybe<IUserSettingCondition>;
}

export interface IQueryAllWeeklyCaloricIntakesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWeeklyCaloricIntakesOrderBy[]>;
  condition?: Maybe<IWeeklyCaloricIntakeCondition>;
}

export interface IQueryAllWorkoutsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutsOrderBy[]>;
  condition?: Maybe<IWorkoutCondition>;
}

export interface IQueryAllWorkoutExercisesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseCondition>;
}

export interface IQueryAllWorkoutExerciseAttemptsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExerciseAttemptsOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseAttemptCondition>;
}

export interface IQueryAllWorkoutNodesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
  condition?: Maybe<IWorkoutNodeCondition>;
}

export interface IQueryAllWorkoutNodeEventsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodeEventsOrderBy[]>;
  condition?: Maybe<IWorkoutNodeEventCondition>;
}

export interface IQueryAllBrandsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBrandsOrderBy[]>;
  condition?: Maybe<IBrandCondition>;
}

export interface IQueryAllBrandBarcodesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBrandBarcodesOrderBy[]>;
  condition?: Maybe<IBrandBarcodeCondition>;
}

export interface IQueryAllCategoriesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICategoriesOrderBy[]>;
  condition?: Maybe<ICategoryCondition>;
}

export interface IQueryAllCompositionsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICompositionsOrderBy[]>;
  condition?: Maybe<ICompositionCondition>;
}

export interface IQueryAllCountriesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ICountriesOrderBy[]>;
  condition?: Maybe<ICountryCondition>;
}

export interface IQueryAllDataSourcesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IDataSourcesOrderBy[]>;
  condition?: Maybe<IDataSourceCondition>;
}

export interface IQueryAllFoodbankFoodsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
  condition?: Maybe<IFoodbankFoodCondition>;
}

export interface IQueryAllFoodCategoriesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
  condition?: Maybe<IFoodCategoryCondition>;
}

export interface IQueryAllGtinsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IGtinsOrderBy[]>;
  condition?: Maybe<IGtinCondition>;
}

export interface IQueryAllNutritionDictionariesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<INutritionDictionariesOrderBy[]>;
  condition?: Maybe<INutritionDictionaryCondition>;
}

export interface IQueryAllFoodbankNutritionFactsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IFoodbankNutritionFactsOrderBy[]>;
  condition?: Maybe<IFoodbankNutritionFactCondition>;
}

export interface IQueryAllServingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IServingsOrderBy[]>;
  condition?: Maybe<IServingCondition>;
}

export interface IQueryAllAttendancesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendancesOrderBy[]>;
  condition?: Maybe<IAttendanceCondition>;
}

export interface IQueryAllAttendanceHasOverrideFlagViewsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceHasOverrideFlagViewsOrderBy[]>;
  condition?: Maybe<IAttendanceHasOverrideFlagViewCondition>;
}

export interface IQueryAllAttendanceOverridesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
  condition?: Maybe<IAttendanceOverrideCondition>;
}

export interface IQueryAllAttendanceStatsByDateViewsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceStatsByDateViewsOrderBy[]>;
  condition?: Maybe<IAttendanceStatsByDateViewCondition>;
}

export interface IQueryAllAttendanceStatsByPersonViewsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendanceStatsByPersonViewsOrderBy[]>;
  condition?: Maybe<IAttendanceStatsByPersonViewCondition>;
}

export interface IQueryAllAttendeesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendeesOrderBy[]>;
  condition?: Maybe<IAttendeeCondition>;
}

export interface IQueryAllAttendeeClubsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
  condition?: Maybe<IAttendeeClubCondition>;
}

export interface IQueryAllBookingsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBookingsOrderBy[]>;
  condition?: Maybe<IBookingCondition>;
}

export interface IQueryAllClassesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClassesOrderBy[]>;
  condition?: Maybe<IClassCondition>;
}

export interface IQueryAllClassInstructorsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
  condition?: Maybe<IClassInstructorCondition>;
}

export interface IQueryAllClubsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IClubsOrderBy[]>;
  condition?: Maybe<IClubCondition>;
}

export interface IQueryAllDailyAttendanceViewsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IDailyAttendanceViewsOrderBy[]>;
  condition?: Maybe<IDailyAttendanceViewCondition>;
}

export interface IQueryAllInstructorsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IInstructorsOrderBy[]>;
  condition?: Maybe<IInstructorCondition>;
}

export interface IQueryAllReservationRequestsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
  condition?: Maybe<IReservationRequestCondition>;
}

export interface IQueryAllSessionsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionsOrderBy[]>;
  condition?: Maybe<ISessionCondition>;
}

export interface IQueryAllSessionInstructorsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
  condition?: Maybe<ISessionInstructorCondition>;
}

export interface IQueryAllTimeslotsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ITimeslotsOrderBy[]>;
  condition?: Maybe<ITimeslotCondition>;
}

export interface IQueryCoachByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryExerciseByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryExerciseOverrideByExerciseIdAndWorkspaceIdArgs {
  exerciseId: Scalars["Uuid"];
  workspaceId: Scalars["Int"];
}

export interface IQueryExerciseOverrideByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryFavouriteFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryHistoryActionByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryLocationByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryManagerByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryManagerClubOrgByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMealItemByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryMemberCheckinByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberEvaluatedRecipeByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberFavouriteFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberFavouriteFoodByMemberIdAndFoodIdArgs {
  memberId: Scalars["Int"];
  foodId: Scalars["Int"];
}

export interface IQueryMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdArgs {
  memberId: Scalars["Int"];
  label: Scalars["String"];
  macrosEntryId: IMacrosEntryIdInput;
}

export interface IQueryMemberFavouriteFoodByMemberIdAndMyFoodIdArgs {
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

export interface IQueryMemberMealByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberMetricByMemberIdAndDateAndKeyArgs {
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  key: IMetricKey;
}

export interface IQueryMemberMyFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberNutritionMetricByMemberIdAndDateArgs {
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

export interface IQueryMemberNutritionPlanByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberRecentFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberRecentFoodByMemberIdAndFatSecretIdArgs {
  memberId: Scalars["Int"];
  fatSecretId: Scalars["Int"];
}

export interface IQueryMemberRecentFoodByMemberIdAndMacroEntryIdArgs {
  memberId: Scalars["Int"];
  macroEntryId: IMacroEntryIdInput;
}

export interface IQueryMemberRecentFoodByMemberIdAndMyFoodIdArgs {
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

export interface IQueryMemberRecentFoodByMemberIdAndFoodIdArgs {
  memberId: Scalars["Int"];
  foodId: Scalars["Uuid"];
}

export interface IQueryMemberRecipeByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberReminderByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberStepsMetricByMemberIdAndDateArgs {
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

export interface IQueryMemberTrainingProgramByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberWaterMetricByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMemberWaterMetricByDateAndMemberIdArgs {
  date: Scalars["Date"];
  memberId: Scalars["Int"];
}

export interface IQueryMemberWorkoutByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMentorEventByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryMentoringReportByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryMentoringReportByTokenArgs {
  token: Scalars["String"];
}

export interface IQueryMentoringReportMessageByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryNotificationByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryNutritionDayByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryNutritionDayMealByNutritionDayIdAndMealIdArgs {
  nutritionDayId: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
}

export interface IQueryNutritionPlanByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryNutritionPlanDayByNutritionPlanIdAndNutritionDayIdArgs {
  nutritionPlanId: Scalars["Uuid"];
  nutritionDayId: Scalars["Uuid"];
}

export interface IQueryNutritionPlanScheduleByNutritionPlanIdAndOrderIndexArgs {
  nutritionPlanId: Scalars["Uuid"];
  orderIndex: Scalars["Int"];
}

export interface IQueryNutritionProfileByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryNutritionProfileMealByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryProgramWorkoutByProgramIdAndWorkoutIdArgs {
  programId: Scalars["Int"];
  workoutId: Scalars["Uuid"];
}

export interface IQueryRecentFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQuerySettingByIdArgs {
  id: Scalars["Int"];
}

export interface IQuerySettingByKeyArgs {
  key: Scalars["String"];
}

export interface IQueryTagByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryTrainingProgramByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryUserSettingByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryWorkoutByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryWorkoutExerciseByIdAndWorkoutIdAndExerciseIdArgs {
  id: Scalars["Uuid"];
  workoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
}

export interface IQueryWorkoutNodeByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryWorkoutNodeEventByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryBrandByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryBrandBarcodeByBrandIdAndGtinIdArgs {
  brandId: Scalars["Uuid"];
  gtinId: Scalars["String"];
}

export interface IQueryCategoryByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryCompositionByFoodIdArgs {
  foodId: Scalars["Uuid"];
}

export interface IQueryCountryByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryDataSourceByIdArgs {
  id: Scalars["String"];
}

export interface IQueryDataSourceBySourceNameArgs {
  sourceName: Scalars["String"];
}

export interface IQueryFoodbankFoodByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryFoodCategoryByFoodIdAndCategoryIdArgs {
  foodId: Scalars["Uuid"];
  categoryId: Scalars["Int"];
}

export interface IQueryGtinByFoodIdAndGtinArgs {
  foodId: Scalars["Uuid"];
  gtin: Scalars["String"];
}

export interface IQueryNutritionDictionaryByIdArgs {
  id: Scalars["Int"];
}

export interface IQueryFoodbankNutritionFactByFoodIdArgs {
  foodId: Scalars["Uuid"];
}

export interface IQueryServingByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryAttendanceBySessionIdAndPersonIdArgs {
  sessionId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
}

export interface IQueryAttendanceByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryAttendanceOverrideByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryAttendeeByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryAttendeeClubByAttendeeIdAndClubIdArgs {
  attendeeId: Scalars["Uuid"];
  clubId: Scalars["Uuid"];
}

export interface IQueryBookingByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryClassByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryClassInstructorByClassIdAndInstructorIdArgs {
  classId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

export interface IQueryClubByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryClubByKsClubIdArgs {
  ksClubId: Scalars["String"];
}

export interface IQueryInstructorByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQueryReservationRequestByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQuerySessionByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQuerySessionInstructorBySessionIdAndInstructorIdArgs {
  sessionId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

export interface IQueryTimeslotByIdArgs {
  id: Scalars["Uuid"];
}

export interface IQuery_FoodServingArgs {
  num: Scalars["BigFloat"];
  name: Scalars["String"];
  volume: Scalars["BigFloat"];
  unit: Scalars["String"];
}

export interface IQuery_NutritionFactsArgs {
  calories?: Maybe<Scalars["BigFloat"]>;
  protein?: Maybe<Scalars["BigFloat"]>;
  fat?: Maybe<Scalars["BigFloat"]>;
  carbs?: Maybe<Scalars["BigFloat"]>;
  fibre?: Maybe<Scalars["BigFloat"]>;
  alcohol?: Maybe<Scalars["BigFloat"]>;
}

export interface IQueryAllActiveCoachesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllClubCoachesArgs {
  clubId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllClubMembersArgs {
  clubId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllFeaturesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllKsClubsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllKsCountriesArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllOrganisationsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllWorkspaceCoachesArgs {
  organisationId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryAllWorkspaceMembersArgs {
  organisationId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryExercisesByIdsArgs {
  ids?: Maybe<Array<Maybe<Scalars["String"]>>>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryFetchInviteArgs {
  hash?: Maybe<Scalars["String"]>;
}

export interface IQueryFetchInviteWithWorkspaceArgs {
  hash?: Maybe<Scalars["String"]>;
}

export interface IQueryFoodByExternalIdsArgs {
  ids?: Maybe<Array<Maybe<Scalars["String"]>>>;
  provider?: Maybe<IFoodProvider>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryGetInviteArgs {
  hash?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryInsightBodyByMemberIdArgs {
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

export interface IQueryInsightFeelingsByMemberIdArgs {
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

export interface IQueryInsightNutritionByMemberIdArgs {
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

export interface IQueryInsightTrainingByMemberIdArgs {
  startDate?: Maybe<Scalars["Date"]>;
  endDate?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

export interface IQueryKsClubByIdArgs {
  id?: Maybe<Scalars["Uuid"]>;
}

export interface IQueryKsClubsByOrgIdArgs {
  orgId?: Maybe<Scalars["Uuid"]>;
}

export interface IQueryLatestFeelingsArgs {
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryLatestMeasurementsArgs {
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberMealsByIdsArgs {
  ids?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberMetricExtendedMeasurementsArgs {
  interval?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberMetricKpisArgs {
  interval?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberMetricMeasurementsArgs {
  interval?: Maybe<Scalars["Int"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberNutritionHistoryArgs {
  interval?: Maybe<Scalars["Int"]>;
  startDate?: Maybe<Scalars["Date"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberNutritionOverviewByMemberIdArgs {
  memberId?: Maybe<Scalars["Int"]>;
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMemberNutritionStreakArgs {
  startDate?: Maybe<Scalars["Date"]>;
  maxInterval?: Maybe<Scalars["Int"]>;
  calThresholdLower?: Maybe<Scalars["Float"]>;
  calThresholdUpper?: Maybe<Scalars["Float"]>;
  allowedTargetDistance?: Maybe<Scalars["Float"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

export interface IQueryMemberWorkoutsArgs {
  memberId?: Maybe<Scalars["Int"]>;
  startDate?: Maybe<Scalars["Date"]>;
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryMetricAveragesArgs {
  member?: Maybe<Scalars["Int"]>;
  interval?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryOrgByIdArgs {
  id?: Maybe<Scalars["Uuid"]>;
}

export interface IQueryOrgByKsClubIdArgs {
  clubId?: Maybe<Scalars["Uuid"]>;
}

export interface IQueryProgramByWorkoutIdArgs {
  workoutId: Scalars["Uuid"];
}

export interface IQueryRecipeByFoodIdArgs {
  foodId?: Maybe<Scalars["Uuid"]>;
}

export interface IQuerySearchExercisesArgs {
  search?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySearchMyFoodArgs {
  search?: Maybe<Scalars["String"]>;
  includeCommon?: Maybe<Scalars["Boolean"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySearchMyMealsArgs {
  search?: Maybe<Scalars["String"]>;
  includeCommon?: Maybe<Scalars["Boolean"]>;
  memberId?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySearchTagsArgs {
  search?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySuggestExercisesArgs {
  search?: Maybe<Scalars["String"]>;
  mLength?: Maybe<Scalars["Int"]>;
  sensitivity?: Maybe<Scalars["Int"]>;
  levIns?: Maybe<Scalars["Int"]>;
  levDel?: Maybe<Scalars["Int"]>;
  levSub?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySuggestTagsArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryWorkoutByWorkoutIdArgs {
  workoutId: Scalars["Uuid"];
}

export interface IQueryCheckCapacityArgs {
  timeslotId?: Maybe<Scalars["Uuid"]>;
  date?: Maybe<Scalars["Date"]>;
}

export interface IQueryCountReservationsArgs {
  timeslotId?: Maybe<Scalars["Uuid"]>;
  date?: Maybe<Scalars["Date"]>;
}

export interface IQueryReportNoShowsArgs {
  date?: Maybe<Scalars["Date"]>;
  attendedOnce?: Maybe<Scalars["Boolean"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryReportQuottedAttendanceArgs {
  startDate?: Maybe<Scalars["Date"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryReservationsByAttendeeIdArgs {
  attendeeId?: Maybe<Scalars["Uuid"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySearchBridgeMembersArgs {
  term?: Maybe<Scalars["String"]>;
  isInClub?: Maybe<Scalars["Boolean"]>;
  exact?: Maybe<Scalars["Boolean"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQuerySessionsByDateArgs {
  date?: Maybe<Scalars["Date"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
}

export interface IQueryCoachArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryExerciseArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryExerciseOverrideArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryFavouriteFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryHistoryActionArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryLocationArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryManagerArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryManagerClubOrgArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMealItemArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberCheckinArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberEvaluatedRecipeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberFavouriteFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberMealArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberMetricArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberMyFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberNutritionMetricArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberNutritionPlanArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberRecentFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberRecipeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberReminderArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberStepsMetricArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberTrainingProgramArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberWaterMetricArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberWorkoutArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMentorEventArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMentoringReportArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMentoringReportMessageArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNotificationArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionDayArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionDayMealArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionPlanArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionPlanDayArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionPlanScheduleArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionProfileArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionProfileMealArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryProgramWorkoutArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryRecentFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQuerySettingArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryTagArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryTrainingProgramArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryUserSettingArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryWorkoutArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryWorkoutExerciseArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryWorkoutNodeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryWorkoutNodeEventArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryBrandArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryBrandBarcodeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryCategoryArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryCompositionArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryCountryArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryDataSourceArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryFoodbankFoodArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryFoodCategoryArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryGtinArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryNutritionDictionaryArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryFoodbankNutritionFactArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryServingArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryAttendanceArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryAttendanceOverrideArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryAttendeeArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryAttendeeClubArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryBookingArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryClassArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryClassInstructorArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryClubArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryInstructorArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryReservationRequestArgs {
  nodeId: Scalars["ID"];
}

export interface IQuerySessionArgs {
  nodeId: Scalars["ID"];
}

export interface IQuerySessionInstructorArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryTimeslotArgs {
  nodeId: Scalars["ID"];
}

export interface IQueryMemberWeeklyTrainingStatArgs {
  memberId: Scalars["ID"];
  date: Scalars["NaiveDate"];
}

export interface IQueryExerciseAttemptsByWorkoutIdArgs {
  workoutId: Scalars["ID"];
}

export interface IQueryWorkoutTemplateByIdArgs {
  id: Scalars["ID"];
}

export interface IQueryAllWorkoutTemplatesArgs {
  filter?: Maybe<IWorkoutTemplateFilter>;
}

export interface IQueryWorkoutTemplateSharingsByTemplateIdArgs {
  id: Scalars["ID"];
}

export interface IQueryWorkoutSessionByIdArgs {
  id: Scalars["ID"];
}

export interface IQueryMemberWorkoutSessionsArgs {
  memberId: Scalars["ID"];
}

export interface IQueryMemberWorkoutSessionsByMonthArgs {
  memberId: Scalars["ID"];
  month: Scalars["NaiveDate"];
}

export interface IQueryTrainingPlanByIdArgs {
  id: Scalars["ID"];
}

export interface IQueryAllTrainingPlansArgs {
  filter?: Maybe<ITrainingPlanFilter>;
}

export interface IQueryTrainingPlanAssignmentByIdArgs {
  id: Scalars["ID"];
}

export interface IQueryTrainingPlanSharingsByPlanIdArgs {
  id: Scalars["ID"];
}

export interface IQueryWorkoutTemplateDirectoryByIdArgs {
  id: Scalars["ID"];
}

export interface IQueryProgressPicturesByDateArgs {
  date: Scalars["NaiveDate"];
}

export interface IQueryProgressPicturesByIntervalArgs {
  startDate: Scalars["NaiveDate"];
  endDate: Scalars["NaiveDate"];
}

export interface IQueryMetricByIntervalArgs {
  key: IMetricKey;
  startDate: Scalars["NaiveDate"];
  endDate: Scalars["NaiveDate"];
}

export interface IQueryMetricDayByDateArgs {
  date: Scalars["NaiveDate"];
}

export interface IQueryLastMetricsByDateArgs {
  keys?: Maybe<IBodyMeasurementKey[]>;
  date: Scalars["NaiveDate"];
}

export interface IQueryMetricsTimelineByUserArgs {
  userId?: Maybe<Scalars["ID"]>;
  offset?: Maybe<Scalars["Int"]>;
  first?: Maybe<Scalars["Int"]>;
}

export interface IQueryAllFoodJournalDaysByDateIntervalArgs {
  startDate: Scalars["NaiveDate"];
  endDate: Scalars["NaiveDate"];
  userId: Scalars["ID"];
}

export interface IQueryFoodJournalDayByDateArgs {
  date: Scalars["NaiveDate"];
  userId?: Maybe<Scalars["ID"]>;
}

export interface IQueryAllBrandsByNameArgs {
  brand: Scalars["String"];
}

export interface IQueryAllFoodJournalTargetsByUserArgs {
  userId: Scalars["ID"];
}

export interface IQueryFoodbankFoodByBarcodeArgs {
  barcode: Scalars["String"];
  meta: IBarcodeSearchMetaInput;
}

export interface IQuottedAttendee {
   __typename?: "QuottedAttendee";
  attendee?: Maybe<IAttendee>;
  quota?: Maybe<Scalars["Int"]>;
  attended?: Maybe<Scalars["Int"]>;
}

/** A connection to a list of `QuottedAttendee` values. */
export interface IQuottedAttendeesConnection {
   __typename?: "QuottedAttendeesConnection";
  /** A list of `QuottedAttendee` objects. */
  nodes: Array<Maybe<IQuottedAttendee>>;
  /** A list of edges which contains the `QuottedAttendee` and cursor to aid in pagination. */
  edges: IQuottedAttendeesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `QuottedAttendee` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `QuottedAttendee` edge in the connection. */
export interface IQuottedAttendeesEdge {
   __typename?: "QuottedAttendeesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `QuottedAttendee` at the end of the edge. */
  node?: Maybe<IQuottedAttendee>;
}

/** All input for the `randomString` mutation. */
export interface IRandomStringInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  length?: Maybe<Scalars["Int"]>;
}

/** The output of our `randomString` mutation. */
export interface IRandomStringPayload {
   __typename?: "RandomStringPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export enum IRating {
  R0 = "_0",
  R0_5 = "_0_5",
  R1 = "_1",
  R1_5 = "_1_5",
  R2 = "_2",
  R2_5 = "_2_5",
  R3 = "_3",
  R3_5 = "_3_5",
  R4 = "_4",
  R4_5 = "_4_5",
  R5 = "_5",
}

/** All input for the `readReminders` mutation. */
export interface IReadRemindersInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  reminders?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
}

/** The output of our `readReminders` mutation. */
export interface IReadRemindersPayload {
   __typename?: "ReadRemindersPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberReminders?: Maybe<Array<Maybe<IMemberReminder>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberReminder`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Coach` that is related to this `MemberReminder`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `MemberReminder`. May be used by Relay 1. */
  memberReminderEdge?: Maybe<IMemberRemindersEdge>;
}

/** The output of our `readReminders` mutation. */
export interface IReadRemindersPayloadMemberReminderEdgeArgs {
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
}

export interface IRecentFood  extends INode {
   __typename?: "RecentFood";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  userId?: Maybe<Scalars["Int"]>;
  /** Number of times user used the food item */
  timesUsed: Scalars["Int"];
  createdAt: Scalars["Datetime"];
  updatedAt: Scalars["Datetime"];
  ksUserId?: Maybe<Scalars["String"]>;
  /** Reads a single `Food` that is related to this `RecentFood`. */
  foodByFoodId?: Maybe<IFood>;
}

/**
 * A condition to be used against `RecentFood` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IRecentFoodCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `timesUsed` field. */
  timesUsed?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `RecentFood` */
export interface IRecentFoodInput {
  id?: Maybe<Scalars["Uuid"]>;
  foodId: Scalars["Uuid"];
  userId?: Maybe<Scalars["Int"]>;
  /** Number of times user used the food item */
  timesUsed: Scalars["Int"];
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `RecentFood`. Fields that are set will be updated. */
export interface IRecentFoodPatch {
  id?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  userId?: Maybe<Scalars["Int"]>;
  /** Number of times user used the food item */
  timesUsed?: Maybe<Scalars["Int"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `RecentFood` values. */
export interface IRecentFoodsConnection {
   __typename?: "RecentFoodsConnection";
  /** A list of `RecentFood` objects. */
  nodes: Array<Maybe<IRecentFood>>;
  /** A list of edges which contains the `RecentFood` and cursor to aid in pagination. */
  edges: IRecentFoodsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `RecentFood` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `RecentFood` edge in the connection. */
export interface IRecentFoodsEdge {
   __typename?: "RecentFoodsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `RecentFood` at the end of the edge. */
  node?: Maybe<IRecentFood>;
}

/** Methods to use when ordering `RecentFood`. */
export enum IRecentFoodsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  TimesUsedAsc = "TIMES_USED_ASC",
  TimesUsedDesc = "TIMES_USED_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IRegisterMemberInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Email of the member */
  email: Scalars["String"];
  /** First name of the member */
  firstName: Scalars["String"];
  /** Last name of the member */
  lastName?: Maybe<Scalars["String"]>;
  /** DEPRECATED: password of the member */
  password?: Maybe<Scalars["String"]>;
  /** DEPRECATED: coach of the member */
  coachId?: Maybe<Scalars["ID"]>;
  /** DEPRECATED: location of the member */
  locationId?: Maybe<Scalars["ID"]>;
  /** Is invite required */
  withInvite?: Maybe<Scalars["Boolean"]>;
}

export interface IRegisterMemberPayload {
   __typename?: "RegisterMemberPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of created member */
  memberId: Scalars["ID"];
  member?: Maybe<IMember>;
}

export interface IRegisterNewCoachInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Email of the coach */
  email: Scalars["String"];
  /** First name of the coach */
  firstName: Scalars["String"];
  /** Last name of the coach */
  lastName?: Maybe<Scalars["String"]>;
  /** Destination org of the coach */
  orgId?: Maybe<Scalars["ID"]>;
  /** Destination club of the coach */
  clubId?: Maybe<Scalars["ID"]>;
}

export interface IRegisterNewCoachPayload {
   __typename?: "RegisterNewCoachPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** id of created coach */
  coachId: Scalars["ID"];
}

export interface IRejectBarcodeRequestInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of barcode request */
  requestId: Scalars["ID"];
  /** Reason of reject */
  reason?: Maybe<Scalars["String"]>;
}

export interface IRejectBarcodeRequestPayload {
   __typename?: "RejectBarcodeRequestPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

export interface IRemoveDeviceMetaInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Id of device */
  deviceId: Scalars["String"];
}

export interface IRemoveDeviceMetaPayload {
   __typename?: "RemoveDeviceMetaPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
}

/** All input for the `requestPasswordReset` mutation. */
export interface IRequestPasswordResetInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  email: Scalars["String"];
}

/** The output of our `requestPasswordReset` mutation. */
export interface IRequestPasswordResetPayload {
   __typename?: "RequestPasswordResetPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `requestPasswordsReset` mutation. */
export interface IRequestPasswordsResetInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  emails: Array<Maybe<Scalars["String"]>>;
}

/** The output of our `requestPasswordsReset` mutation. */
export interface IRequestPasswordsResetPayload {
   __typename?: "RequestPasswordsResetPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface IReservationRequest  extends INode {
   __typename?: "ReservationRequest";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  type: IReservationType;
  status: IReservationStatus;
  date: Scalars["Date"];
  prevTimeslotId?: Maybe<Scalars["Uuid"]>;
  timeslotId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByPrevTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `ReservationRequest`. */
  attendeeByPersonId?: Maybe<IAttendee>;
}

/**
 * A condition to be used against `ReservationRequest` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IReservationRequestCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<IReservationType>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<IReservationStatus>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `prevTimeslotId` field. */
  prevTimeslotId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `timeslotId` field. */
  timeslotId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `ReservationRequest`. Fields that are set will be updated. */
export interface IReservationRequestPatch {
  id?: Maybe<Scalars["Uuid"]>;
  type?: Maybe<IReservationType>;
  status?: Maybe<IReservationStatus>;
  date?: Maybe<Scalars["Date"]>;
  prevTimeslotId?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  personId?: Maybe<Scalars["Uuid"]>;
  notes?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `ReservationRequest` values. */
export interface IReservationRequestsConnection {
   __typename?: "ReservationRequestsConnection";
  /** A list of `ReservationRequest` objects. */
  nodes: Array<Maybe<IReservationRequest>>;
  /** A list of edges which contains the `ReservationRequest` and cursor to aid in pagination. */
  edges: IReservationRequestsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `ReservationRequest` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `ReservationRequest` edge in the connection. */
export interface IReservationRequestsEdge {
   __typename?: "ReservationRequestsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `ReservationRequest` at the end of the edge. */
  node?: Maybe<IReservationRequest>;
}

/** Methods to use when ordering `ReservationRequest`. */
export enum IReservationRequestsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  PrevTimeslotIdAsc = "PREV_TIMESLOT_ID_ASC",
  PrevTimeslotIdDesc = "PREV_TIMESLOT_ID_DESC",
  TimeslotIdAsc = "TIMESLOT_ID_ASC",
  TimeslotIdDesc = "TIMESLOT_ID_DESC",
  PersonIdAsc = "PERSON_ID_ASC",
  PersonIdDesc = "PERSON_ID_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IReservationStatus {
  Pending = "PENDING",
  Approved = "APPROVED",
  Expired = "EXPIRED",
}

export enum IReservationType {
  Permanent = "PERMANENT",
  Temporary = "TEMPORARY",
}

/** All input for the `resetPassword` mutation. */
export interface IResetPasswordInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  pToken: Scalars["String"];
  newPass: Scalars["String"];
}

/** The output of our `resetPassword` mutation. */
export interface IResetPasswordPayload {
   __typename?: "ResetPasswordPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface ISaveBodyMeasurementInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Measurement for a user (self if missing) */
  userId?: Maybe<Scalars["ID"]>;
  /** Date of measurement */
  date: Scalars["NaiveDate"];
  /** Value for body weight */
  bodyWeight?: Maybe<Scalars["Float"]>;
  /** Value for BFP */
  bodyFatPercentage?: Maybe<Scalars["Float"]>;
  /** Value for BFM */
  bodyFatMass?: Maybe<Scalars["Float"]>;
  /** Value for SMM */
  skeletalMuscleMass?: Maybe<Scalars["Float"]>;
  /** Value for circumference measurement */
  circumference?: Maybe<ICircumferenceValueInput>;
  /** Value for skin folds measurement */
  skinFolds?: Maybe<ISkinFoldsValueInput>;
  /** Value for number of sleeping hours */
  sleepHours?: Maybe<Scalars["Float"]>;
  /** Value for blood pressure */
  bloodPressure?: Maybe<IBloodPressureValueInput>;
  /** Value for menstrual day */
  menstrualDay?: Maybe<Scalars["Boolean"]>;
  /** Value for heart rate */
  heartRate?: Maybe<Scalars["Int"]>;
  /** Value for heart rate variability */
  heartRateVar?: Maybe<Scalars["Int"]>;
  /** Value for body temperature */
  bodyTemp?: Maybe<Scalars["Float"]>;
}

export interface ISaveBodyMeasurementPayload {
   __typename?: "SaveBodyMeasurementPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** All metrics for a given date */
  metrics: IUserMetricDay;
}

/** All input for the `saveFavouriteFood` mutation. */
export interface ISaveFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  food?: Maybe<Scalars["Json"]>;
}

/** The output of our `saveFavouriteFood` mutation. */
export interface ISaveFavouriteFoodPayload {
   __typename?: "SaveFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  favouriteFood?: Maybe<IFavouriteFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `FavouriteFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `FavouriteFood`. May be used by Relay 1. */
  favouriteFoodEdge?: Maybe<IFavouriteFoodsEdge>;
}

/** The output of our `saveFavouriteFood` mutation. */
export interface ISaveFavouriteFoodPayloadFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
}

export interface ISaveJournalMealInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Updated meal */
  meal: IFoodJournalMealInput;
}

export interface ISaveJournalMealPayload {
   __typename?: "SaveJournalMealPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Updated meal */
  meal: IFoodJournalMeal;
}

export interface ISaveJournalWaterVolumeInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Day to update */
  day: Scalars["NaiveDate"];
  /** New water volume */
  volume: Scalars["Int"];
}

export interface ISaveJournalWaterVolumePayload {
   __typename?: "SaveJournalWaterVolumePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Updated water volume */
  volume: Scalars["Int"];
}

export interface ISaveMemberWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout template object created in the app */
  workoutTemplate: IMemberWorkoutTemplateInput;
}

export interface ISaveMemberWorkoutTemplatePayload {
   __typename?: "SaveMemberWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workoutTemplate: IWorkoutTemplate;
}

/** All input for the `saveMentoringReport` mutation. */
export interface ISaveMentoringReportInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  startDate: Scalars["Date"];
  endDate: Scalars["Date"];
  theme: Scalars["String"];
  showFeelings: Scalars["Boolean"];
  feelingsMessage: Scalars["String"];
  showBody: Scalars["Boolean"];
  bodyMessage: Scalars["String"];
  showNutrition: Scalars["Boolean"];
  nutritionMessage: Scalars["String"];
  showTraining: Scalars["Boolean"];
  trainingMessage: Scalars["String"];
  introNotes: Scalars["String"];
  coachId?: Maybe<Scalars["Int"]>;
}

/** All input for the `saveMentoringReportMessage` mutation. */
export interface ISaveMentoringReportMessageInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  mentoringReportId: Scalars["Uuid"];
  type: Scalars["String"];
  isHidden: Scalars["Boolean"];
  message: Scalars["String"];
}

/** The output of our `saveMentoringReportMessage` mutation. */
export interface ISaveMentoringReportMessagePayload {
   __typename?: "SaveMentoringReportMessagePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  mentoringReportMessage?: Maybe<IMentoringReportMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MentoringReport` that is related to this `MentoringReportMessage`. */
  mentoringReportByMentoringReportId?: Maybe<IMentoringReport>;
  /** An edge for our `MentoringReportMessage`. May be used by Relay 1. */
  mentoringReportMessageEdge?: Maybe<IMentoringReportMessagesEdge>;
}

/** The output of our `saveMentoringReportMessage` mutation. */
export interface ISaveMentoringReportMessagePayloadMentoringReportMessageEdgeArgs {
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
}

/** The output of our `saveMentoringReport` mutation. */
export interface ISaveMentoringReportPayload {
   __typename?: "SaveMentoringReportPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  mentoringReport?: Maybe<IMentoringReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Coach` that is related to this `MentoringReport`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads a single `Member` that is related to this `MentoringReport`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MentoringReport`. May be used by Relay 1. */
  mentoringReportEdge?: Maybe<IMentoringReportsEdge>;
}

/** The output of our `saveMentoringReport` mutation. */
export interface ISaveMentoringReportPayloadMentoringReportEdgeArgs {
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
}

/** All input for the `saveMyMeal` mutation. */
export interface ISaveMyMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  dbFood?: Maybe<Scalars["Json"]>;
  fsFood?: Maybe<Scalars["Json"]>;
  name?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

/** The output of our `saveMyMeal` mutation. */
export interface ISaveMyMealPayload {
   __typename?: "SaveMyMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberMeal?: Maybe<IMemberMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our `saveMyMeal` mutation. */
export interface ISaveMyMealPayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the `saveMyMealV2` mutation. */
export interface ISaveMyMealV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  name?: Maybe<Scalars["String"]>;
  items?: Maybe<Scalars["Json"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `saveMyMealV2` mutation. */
export interface ISaveMyMealV2Payload {
   __typename?: "SaveMyMealV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberMeal?: Maybe<IMemberMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our `saveMyMealV2` mutation. */
export interface ISaveMyMealV2PayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the `saveMyRecipe` mutation. */
export interface ISaveMyRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  ingredients?: Maybe<Scalars["Json"]>;
  servingsNum?: Maybe<Scalars["Float"]>;
  totalTime?: Maybe<Scalars["Int"]>;
  prepareTime?: Maybe<Scalars["Int"]>;
  notes?: Maybe<Scalars["String"]>;
  meta?: Maybe<Scalars["Json"]>;
  mealId?: Maybe<Scalars["Uuid"]>;
  recipeId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `saveMyRecipe` mutation. */
export interface ISaveMyRecipePayload {
   __typename?: "SaveMyRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberEvaluatedRecipe?: Maybe<IMemberEvaluatedRecipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `MemberEvaluatedRecipe`. */
  foodByFoodId?: Maybe<IFood>;
  /** Reads a single `MemberRecipe` that is related to this `MemberEvaluatedRecipe`. */
  memberRecipeByRecipeId?: Maybe<IMemberRecipe>;
  /** An edge for our `MemberEvaluatedRecipe`. May be used by Relay 1. */
  memberEvaluatedRecipeEdge?: Maybe<IMemberEvaluatedRecipesEdge>;
}

/** The output of our `saveMyRecipe` mutation. */
export interface ISaveMyRecipePayloadMemberEvaluatedRecipeEdgeArgs {
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
}

/** All input for the `saveNutritionDay` mutation. */
export interface ISaveNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  meals?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `saveNutritionDay` mutation. */
export interface ISaveNutritionDayPayload {
   __typename?: "SaveNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our `saveNutritionDay` mutation. */
export interface ISaveNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the `saveNutritionDayV2` mutation. */
export interface ISaveNutritionDayV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  name?: Maybe<Scalars["String"]>;
  meals?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `saveNutritionDayV2` mutation. */
export interface ISaveNutritionDayV2Payload {
   __typename?: "SaveNutritionDayV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our `saveNutritionDayV2` mutation. */
export interface ISaveNutritionDayV2PayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the `saveNutritionPlan` mutation. */
export interface ISaveNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  name?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  duration?: Maybe<Scalars["Int"]>;
  sequence?: Maybe<Array<Maybe<IPlanSequenceItemInput>>>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `saveNutritionPlan` mutation. */
export interface ISaveNutritionPlanPayload {
   __typename?: "SaveNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  nutritionPlan?: Maybe<INutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `NutritionPlan`. May be used by Relay 1. */
  nutritionPlanEdge?: Maybe<INutritionPlansEdge>;
}

/** The output of our `saveNutritionPlan` mutation. */
export interface ISaveNutritionPlanPayloadNutritionPlanEdgeArgs {
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
}

/** All input for the `saveRecentFoodItems` mutation. */
export interface ISaveRecentFoodItemsInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  foodIds?: Maybe<Array<Maybe<Scalars["Uuid"]>>>;
  userId?: Maybe<Scalars["String"]>;
}

/** The output of our `saveRecentFoodItems` mutation. */
export interface ISaveRecentFoodItemsPayload {
   __typename?: "SaveRecentFoodItemsPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  recentFoods?: Maybe<Array<Maybe<IRecentFood>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `RecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `RecentFood`. May be used by Relay 1. */
  recentFoodEdge?: Maybe<IRecentFoodsEdge>;
}

/** The output of our `saveRecentFoodItems` mutation. */
export interface ISaveRecentFoodItemsPayloadRecentFoodEdgeArgs {
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
}

export interface ISaveTrainingPlanInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout object */
  trainingPlan: ITrainingPlanInput;
}

export interface ISaveTrainingPlanPayload {
   __typename?: "SaveTrainingPlanPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** saved training plan */
  trainingPlan: ITrainingPlan;
}

export interface ISaveWorkoutSessionInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout object */
  workout: ISessionWorkoutInput;
}

export interface ISaveWorkoutSessionPayload {
   __typename?: "SaveWorkoutSessionPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** completed workout */
  workout: IWorkoutSession;
}

export interface ISaveWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** workout template object */
  workoutTemplate: IWorkoutTemplateInput;
}

export interface ISaveWorkoutTemplatePayload {
   __typename?: "SaveWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workoutTemplate: IWorkoutTemplate;
}

export interface ISearchInput {
  page_number?: Maybe<Scalars["Int"]>;
  max_results?: Maybe<Scalars["Int"]>;
  region?: Maybe<Scalars["String"]>;
  language?: Maybe<Scalars["String"]>;
}

/** All input for the `sendPushNotification` mutation. */
export interface ISendPushNotificationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  recipientId?: Maybe<Scalars["Int"]>;
  title?: Maybe<Scalars["String"]>;
  body?: Maybe<Scalars["String"]>;
  data?: Maybe<Scalars["Json"]>;
}

/** The output of our `sendPushNotification` mutation. */
export interface ISendPushNotificationPayload {
   __typename?: "SendPushNotificationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  sendPushNotificationResult?: Maybe<ISendPushNotificationResult>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export enum ISendPushNotificationResult {
  MemberNotFound = "MEMBER_NOT_FOUND",
  CoachNotFound = "COACH_NOT_FOUND",
  Ok = "OK",
}

/** Food servings */
export interface IServing  extends INode {
   __typename?: "Serving";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  foodId: Scalars["Uuid"];
  num: Scalars["Float"];
  name: Scalars["String"];
  volume?: Maybe<Scalars["Float"]>;
  unit: Scalars["String"];
  comment?: Maybe<Scalars["String"]>;
  isDefaultServing: Scalars["Boolean"];
  multiplier: Scalars["Float"];
  /** Reads a single `FoodbankFood` that is related to this `Serving`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
}

/** A condition to be used against `Serving` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IServingCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `foodId` field. */
  foodId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `num` field. */
  num?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `unit` field. */
  unit?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isDefaultServing` field. */
  isDefaultServing?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `multiplier` field. */
  multiplier?: Maybe<Scalars["Float"]>;
}

/** An input for mutations affecting `Serving` */
export interface IServingInput {
  id?: Maybe<Scalars["Uuid"]>;
  foodId: Scalars["Uuid"];
  num: Scalars["Float"];
  name: Scalars["String"];
  volume?: Maybe<Scalars["Float"]>;
  unit: Scalars["String"];
  comment?: Maybe<Scalars["String"]>;
  isDefaultServing?: Maybe<Scalars["Boolean"]>;
  multiplier?: Maybe<Scalars["Float"]>;
}

/** Represents an update to a `Serving`. Fields that are set will be updated. */
export interface IServingPatch {
  id?: Maybe<Scalars["Uuid"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  num?: Maybe<Scalars["Float"]>;
  name?: Maybe<Scalars["String"]>;
  volume?: Maybe<Scalars["Float"]>;
  unit?: Maybe<Scalars["String"]>;
  comment?: Maybe<Scalars["String"]>;
  isDefaultServing?: Maybe<Scalars["Boolean"]>;
  multiplier?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `Serving` values. */
export interface IServingsConnection {
   __typename?: "ServingsConnection";
  /** A list of `Serving` objects. */
  nodes: Array<Maybe<IServing>>;
  /** A list of edges which contains the `Serving` and cursor to aid in pagination. */
  edges: IServingsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Serving` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Serving` edge in the connection. */
export interface IServingsEdge {
   __typename?: "ServingsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Serving` at the end of the edge. */
  node?: Maybe<IServing>;
}

/** Methods to use when ordering `Serving`. */
export enum IServingsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  FoodIdAsc = "FOOD_ID_ASC",
  FoodIdDesc = "FOOD_ID_DESC",
  NumAsc = "NUM_ASC",
  NumDesc = "NUM_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  VolumeAsc = "VOLUME_ASC",
  VolumeDesc = "VOLUME_DESC",
  UnitAsc = "UNIT_ASC",
  UnitDesc = "UNIT_DESC",
  CommentAsc = "COMMENT_ASC",
  CommentDesc = "COMMENT_DESC",
  IsDefaultServingAsc = "IS_DEFAULT_SERVING_ASC",
  IsDefaultServingDesc = "IS_DEFAULT_SERVING_DESC",
  MultiplierAsc = "MULTIPLIER_ASC",
  MultiplierDesc = "MULTIPLIER_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface ISession  extends INode {
   __typename?: "Session";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  timeslotId?: Maybe<Scalars["Uuid"]>;
  status: ISessionStatus;
  timestamp?: Maybe<Scalars["Datetime"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /**
 * Do not use this field directly as the structure of it may vary as related
   * entities get migrated. Instead, rely on virtual fields.
 **/
  meta?: Maybe<Scalars["Json"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** Reads and enables pagination through a set of `Attendance`. */
  attendancesBySessionId: IAttendancesConnection;
  /** Reads and enables pagination through a set of `SessionInstructor`. */
  sessionInstructorsBySessionId: ISessionInstructorsConnection;
  class?: Maybe<ISessionMetaClass>;
  metaVersion?: Maybe<Scalars["String"]>;
  timeslot?: Maybe<ISessionMetaTimeslot>;
}

export interface ISessionAttendancesBySessionIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IAttendancesOrderBy[]>;
  condition?: Maybe<IAttendanceCondition>;
}

export interface ISessionSessionInstructorsBySessionIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
  condition?: Maybe<ISessionInstructorCondition>;
}

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ISessionCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `timeslotId` field. */
  timeslotId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ISessionStatus>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `meta` field. */
  meta?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `clubId` field. */
  clubId?: Maybe<Scalars["Uuid"]>;
}

/** An input for mutations affecting `Session` */
export interface ISessionInput {
  id?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  status: ISessionStatus;
  timestamp?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  /**
 * Do not use this field directly as the structure of it may vary as related
   * entities get migrated. Instead, rely on virtual fields.
 **/
  meta?: Maybe<Scalars["Json"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
}

export interface ISessionInstructor  extends INode {
   __typename?: "SessionInstructor";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  sessionId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  createdAt: Scalars["Datetime"];
  /** Reads a single `Session` that is related to this `SessionInstructor`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Instructor` that is related to this `SessionInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
}

/**
 * A condition to be used against `SessionInstructor` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface ISessionInstructorCondition {
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `instructorId` field. */
  instructorId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `SessionInstructor` */
export interface ISessionInstructorInput {
  sessionId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
  notes?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `SessionInstructor`. Fields that are set will be updated. */
export interface ISessionInstructorPatch {
  sessionId?: Maybe<Scalars["Uuid"]>;
  instructorId?: Maybe<Scalars["Uuid"]>;
  notes?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `SessionInstructor` values. */
export interface ISessionInstructorsConnection {
   __typename?: "SessionInstructorsConnection";
  /** A list of `SessionInstructor` objects. */
  nodes: Array<Maybe<ISessionInstructor>>;
  /** A list of edges which contains the `SessionInstructor` and cursor to aid in pagination. */
  edges: ISessionInstructorsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `SessionInstructor` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `SessionInstructor` edge in the connection. */
export interface ISessionInstructorsEdge {
   __typename?: "SessionInstructorsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `SessionInstructor` at the end of the edge. */
  node?: Maybe<ISessionInstructor>;
}

/** Methods to use when ordering `SessionInstructor`. */
export enum ISessionInstructorsOrderBy {
  Natural = "NATURAL",
  SessionIdAsc = "SESSION_ID_ASC",
  SessionIdDesc = "SESSION_ID_DESC",
  InstructorIdAsc = "INSTRUCTOR_ID_ASC",
  InstructorIdDesc = "INSTRUCTOR_ID_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface ISessionListItem {
   __typename?: "SessionListItem";
  className?: Maybe<Scalars["String"]>;
  day?: Maybe<Scalars["Int"]>;
  time?: Maybe<Scalars["Time"]>;
  sessionId?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `SessionListItem` values. */
export interface ISessionListItemsConnection {
   __typename?: "SessionListItemsConnection";
  /** A list of `SessionListItem` objects. */
  nodes: Array<Maybe<ISessionListItem>>;
  /** A list of edges which contains the `SessionListItem` and cursor to aid in pagination. */
  edges: ISessionListItemsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `SessionListItem` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `SessionListItem` edge in the connection. */
export interface ISessionListItemsEdge {
   __typename?: "SessionListItemsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `SessionListItem` at the end of the edge. */
  node?: Maybe<ISessionListItem>;
}

export interface ISessionMetaClass {
   __typename?: "SessionMetaClass";
  name?: Maybe<Scalars["String"]>;
  capacity?: Maybe<Scalars["Int"]>;
}

export interface ISessionMetaTimeslot {
   __typename?: "SessionMetaTimeslot";
  capacity?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  time?: Maybe<Scalars["Time"]>;
}

/** Represents an update to a `Session`. Fields that are set will be updated. */
export interface ISessionPatch {
  id?: Maybe<Scalars["Uuid"]>;
  timeslotId?: Maybe<Scalars["Uuid"]>;
  status?: Maybe<ISessionStatus>;
  timestamp?: Maybe<Scalars["Datetime"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  /**
 * Do not use this field directly as the structure of it may vary as related
   * entities get migrated. Instead, rely on virtual fields.
 **/
  meta?: Maybe<Scalars["Json"]>;
  clubId?: Maybe<Scalars["Uuid"]>;
}

/** A connection to a list of `Session` values. */
export interface ISessionsConnection {
   __typename?: "SessionsConnection";
  /** A list of `Session` objects. */
  nodes: Array<Maybe<ISession>>;
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: ISessionsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Session` edge in the connection. */
export interface ISessionsEdge {
   __typename?: "SessionsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Session` at the end of the edge. */
  node?: Maybe<ISession>;
}

/** Methods to use when ordering `Session`. */
export enum ISessionsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TimeslotIdAsc = "TIMESLOT_ID_ASC",
  TimeslotIdDesc = "TIMESLOT_ID_DESC",
  StatusAsc = "STATUS_ASC",
  StatusDesc = "STATUS_DESC",
  TimestampAsc = "TIMESTAMP_ASC",
  TimestampDesc = "TIMESTAMP_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  MetaAsc = "META_ASC",
  MetaDesc = "META_DESC",
  ClubIdAsc = "CLUB_ID_ASC",
  ClubIdDesc = "CLUB_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum ISessionStatus {
  Pending = "PENDING",
  InProgress = "IN_PROGRESS",
  Completed = "COMPLETED",
  Cancelled = "CANCELLED",
}

export interface ISessionWorkoutInput {
  id?: Maybe<Scalars["ID"]>;
  workoutTemplateId: Scalars["ID"];
  date: Scalars["NaiveDate"];
  body: Scalars["String"];
}

export interface ISetting  extends INode {
   __typename?: "Setting";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  key: Scalars["String"];
  name: Scalars["String"];
  type: ISettingType;
  options?: Maybe<Array<Maybe<Scalars["String"]>>>;
  default: Scalars["String"];
  userScope: ISettingScope;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettingsBySettingId: IUserSettingsConnection;
}

export interface ISettingUserSettingsBySettingIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
  condition?: Maybe<IUserSettingCondition>;
}

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ISettingCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<ISettingType>;
  /** Checks for equality with the object’s `options` field. */
  options?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `default` field. */
  default?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `userScope` field. */
  userScope?: Maybe<ISettingScope>;
}

/** An input for mutations affecting `Setting` */
export interface ISettingInput {
  id?: Maybe<Scalars["Int"]>;
  key: Scalars["String"];
  name: Scalars["String"];
  type: ISettingType;
  options?: Maybe<Array<Maybe<Scalars["String"]>>>;
  default: Scalars["String"];
  userScope?: Maybe<ISettingScope>;
}

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export interface ISettingPatch {
  id?: Maybe<Scalars["Int"]>;
  key?: Maybe<Scalars["String"]>;
  name?: Maybe<Scalars["String"]>;
  type?: Maybe<ISettingType>;
  options?: Maybe<Array<Maybe<Scalars["String"]>>>;
  default?: Maybe<Scalars["String"]>;
  userScope?: Maybe<ISettingScope>;
}

/** A connection to a list of `Setting` values. */
export interface ISettingsConnection {
   __typename?: "SettingsConnection";
  /** A list of `Setting` objects. */
  nodes: Array<Maybe<ISetting>>;
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: ISettingsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

export enum ISettingScope {
  None = "NONE",
  Coach = "COACH",
  Member = "MEMBER",
  Both = "BOTH",
}

/** A `Setting` edge in the connection. */
export interface ISettingsEdge {
   __typename?: "SettingsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Setting` at the end of the edge. */
  node?: Maybe<ISetting>;
}

/** Methods to use when ordering `Setting`. */
export enum ISettingsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  KeyAsc = "KEY_ASC",
  KeyDesc = "KEY_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  OptionsAsc = "OPTIONS_ASC",
  OptionsDesc = "OPTIONS_DESC",
  DefaultAsc = "DEFAULT_ASC",
  DefaultDesc = "DEFAULT_DESC",
  UserScopeAsc = "USER_SCOPE_ASC",
  UserScopeDesc = "USER_SCOPE_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum ISettingType {
  Bool = "BOOL",
  String = "STRING",
  Integer = "INTEGER",
  SelectSingle = "SELECT_SINGLE",
}

export interface IShareTrainingPlanInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  trainingPlanId: Scalars["ID"];
  recipientId: Scalars["ID"];
  recipientType: ISharingRecipientType;
  accessLevel: ISharingAccessLevel;
}

export interface IShareTrainingPlanPayload {
   __typename?: "ShareTrainingPlanPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** created sharing */
  sharing: ISharing;
}

export interface IShareWorkoutTemplateInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  templateId: Scalars["ID"];
  recipientId: Scalars["ID"];
  recipientType: ISharingRecipientType;
  accessLevel: ISharingAccessLevel;
}

export interface IShareWorkoutTemplatePayload {
   __typename?: "ShareWorkoutTemplatePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** created sharing */
  sharing: ISharing;
}

export interface ISharing {
   __typename?: "Sharing";
  id: Scalars["ID"];
  userId?: Maybe<Scalars["ID"]>;
  clubId?: Maybe<Scalars["ID"]>;
  orgId?: Maybe<Scalars["ID"]>;
  isPublic?: Maybe<Scalars["Boolean"]>;
  level: ISharingAccessLevel;
  addedAt: Scalars["NaiveDateTime"];
}

export enum ISharingAccessLevel {
  Full = "FULL",
  ReadWrite = "READ_WRITE",
  ReadOnly = "READ_ONLY",
}

export enum ISharingRecipientType {
  User = "USER",
  Club = "CLUB",
  Org = "ORG",
}

export interface ISharingsConnection {
   __typename?: "SharingsConnection";
  /** List of available training plan slots */
  nodes: ISharing[];
  /** Total number of available training plan slots */
  totalCount: Scalars["Int"];
}

export interface IShortMetricValue {
   __typename?: "ShortMetricValue";
  id: Scalars["ID"];
  date: Scalars["NaiveDate"];
  value: Scalars["Float"];
}

export interface IShortWorkoutMeta {
   __typename?: "ShortWorkoutMeta";
  volume?: Maybe<Scalars["Float"]>;
  calories?: Maybe<Scalars["Int"]>;
  distance?: Maybe<Scalars["Int"]>;
  performance?: Maybe<Scalars["Int"]>;
  difficulty?: Maybe<Scalars["Int"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** All input for the `signupCoach` mutation. */
export interface ISignupCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  inviteHash: Scalars["String"];
  email: Scalars["String"];
  firstName: Scalars["String"];
  lastName: Scalars["String"];
  brandName: Scalars["String"];
  password: Scalars["String"];
  termsVersion: Scalars["Int"];
}

/** The output of our `signupCoach` mutation. */
export interface ISignupCoachPayload {
   __typename?: "SignupCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  signupResult?: Maybe<ISignupResult>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export enum ISignupResult {
  InviteInvalid = "INVITE_INVALID",
  InviteExpired = "INVITE_EXPIRED",
  InviteUsed = "INVITE_USED",
  EmailTaken = "EMAIL_TAKEN",
  AccountNotFound = "ACCOUNT_NOT_FOUND",
  CoachNotFound = "COACH_NOT_FOUND",
  Ok = "OK",
}

export interface ISkinFolds {
   __typename?: "SkinFolds";
  back?: Maybe<Scalars["Float"]>;
  quad?: Maybe<Scalars["Float"]>;
  rightThigh?: Maybe<Scalars["Float"]>;
  chest?: Maybe<Scalars["Float"]>;
  abdomen?: Maybe<Scalars["Float"]>;
  thigh?: Maybe<Scalars["Float"]>;
  tricep?: Maybe<Scalars["Float"]>;
  subscapular?: Maybe<Scalars["Float"]>;
  suprailiac?: Maybe<Scalars["Float"]>;
  midaxillary?: Maybe<Scalars["Float"]>;
}

export interface ISkinFoldsValueInput {
  back?: Maybe<Scalars["Float"]>;
  quad?: Maybe<Scalars["Float"]>;
  rightThigh?: Maybe<Scalars["Float"]>;
  chest?: Maybe<Scalars["Float"]>;
  abdomen?: Maybe<Scalars["Float"]>;
  thigh?: Maybe<Scalars["Float"]>;
  tricep?: Maybe<Scalars["Float"]>;
  subscapular?: Maybe<Scalars["Float"]>;
  suprailiac?: Maybe<Scalars["Float"]>;
  midaxillary?: Maybe<Scalars["Float"]>;
}

export interface ISubmitBarcodeRequestInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Barcode of new food */
  barcode: Scalars["String"];
}

export interface ISubmitBarcodeRequestPayload {
   __typename?: "SubmitBarcodeRequestPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** URL for uploading front pic of package */
  frontUrl: Scalars["String"];
  /** URL for uploading pic of package with nutrition facts */
  factsUrl: Scalars["String"];
}

/** All input for the `suspendMember` mutation. */
export interface ISuspendMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
}

/** The output of our `suspendMember` mutation. */
export interface ISuspendMemberPayload {
   __typename?: "SuspendMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export interface ITag  extends INode {
   __typename?: "Tag";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads and enables pagination through a set of `MemberTag`. */
  memberTagsByTagId: IMemberTagsConnection;
}

export interface ITagMemberTagsByTagIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTagsOrderBy[]>;
  condition?: Maybe<IMemberTagCondition>;
}

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ITagCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `Tag` */
export interface ITagInput {
  id?: Maybe<Scalars["Int"]>;
  name: Scalars["String"];
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export interface ITagPatch {
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Tag` values. */
export interface ITagsConnection {
   __typename?: "TagsConnection";
  /** A list of `Tag` objects. */
  nodes: Array<Maybe<ITag>>;
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: ITagsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Tag` edge in the connection. */
export interface ITagsEdge {
   __typename?: "TagsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Tag` at the end of the edge. */
  node?: Maybe<ITag>;
}

/** Methods to use when ordering `Tag`. */
export enum ITagsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface ITimeslot  extends INode {
   __typename?: "Timeslot";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  classId: Scalars["Uuid"];
  time: Scalars["Time"];
  day: Scalars["Int"];
  capacity?: Maybe<Scalars["Int"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Class` that is related to this `Timeslot`. */
  classByClassId?: Maybe<IClass>;
  /** Reads and enables pagination through a set of `Booking`. */
  bookingsByTimeslotId: IBookingsConnection;
  /** Reads and enables pagination through a set of `ReservationRequest`. */
  reservationRequestsByPrevTimeslotId: IReservationRequestsConnection;
  /** Reads and enables pagination through a set of `ReservationRequest`. */
  reservationRequestsByTimeslotId: IReservationRequestsConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsByTimeslotId: ISessionsConnection;
}

export interface ITimeslotBookingsByTimeslotIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IBookingsOrderBy[]>;
  condition?: Maybe<IBookingCondition>;
}

export interface ITimeslotReservationRequestsByPrevTimeslotIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
  condition?: Maybe<IReservationRequestCondition>;
}

export interface ITimeslotReservationRequestsByTimeslotIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
  condition?: Maybe<IReservationRequestCondition>;
}

export interface ITimeslotSessionsByTimeslotIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<ISessionsOrderBy[]>;
  condition?: Maybe<ISessionCondition>;
}

/**
 * A condition to be used against `Timeslot` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface ITimeslotCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `classId` field. */
  classId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `time` field. */
  time?: Maybe<Scalars["Time"]>;
  /** Checks for equality with the object’s `day` field. */
  day?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `capacity` field. */
  capacity?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `Timeslot` */
export interface ITimeslotInput {
  id?: Maybe<Scalars["Uuid"]>;
  classId: Scalars["Uuid"];
  time: Scalars["Time"];
  day: Scalars["Int"];
  capacity?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `Timeslot`. Fields that are set will be updated. */
export interface ITimeslotPatch {
  id?: Maybe<Scalars["Uuid"]>;
  classId?: Maybe<Scalars["Uuid"]>;
  time?: Maybe<Scalars["Time"]>;
  day?: Maybe<Scalars["Int"]>;
  capacity?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `Timeslot` values. */
export interface ITimeslotsConnection {
   __typename?: "TimeslotsConnection";
  /** A list of `Timeslot` objects. */
  nodes: Array<Maybe<ITimeslot>>;
  /** A list of edges which contains the `Timeslot` and cursor to aid in pagination. */
  edges: ITimeslotsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Timeslot` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Timeslot` edge in the connection. */
export interface ITimeslotsEdge {
   __typename?: "TimeslotsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Timeslot` at the end of the edge. */
  node?: Maybe<ITimeslot>;
}

/** Methods to use when ordering `Timeslot`. */
export enum ITimeslotsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  ClassIdAsc = "CLASS_ID_ASC",
  ClassIdDesc = "CLASS_ID_DESC",
  TimeAsc = "TIME_ASC",
  TimeDesc = "TIME_DESC",
  DayAsc = "DAY_ASC",
  DayDesc = "DAY_DESC",
  CapacityAsc = "CAPACITY_ASC",
  CapacityDesc = "CAPACITY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface ITopLevelWorkoutTemplateDirectoriesConnection {
   __typename?: "TopLevelWorkoutTemplateDirectoriesConnection";
  directories: IWorkoutTemplateDirectoriesConnection;
  workoutTemplates: IWorkoutTemplatesConnection;
}

export interface ITopLift {
   __typename?: "TopLift";
  memberId?: Maybe<Scalars["Int"]>;
  label?: Maybe<Scalars["String"]>;
  maxWeight?: Maybe<Scalars["Float"]>;
}

/** A condition to be used against `TopLift` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ITopLiftCondition {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `maxWeight` field. */
  maxWeight?: Maybe<Scalars["Float"]>;
}

/** A connection to a list of `TopLift` values. */
export interface ITopLiftsConnection {
   __typename?: "TopLiftsConnection";
  /** A list of `TopLift` objects. */
  nodes: Array<Maybe<ITopLift>>;
  /** A list of edges which contains the `TopLift` and cursor to aid in pagination. */
  edges: ITopLiftsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `TopLift` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `TopLift` edge in the connection. */
export interface ITopLiftsEdge {
   __typename?: "TopLiftsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `TopLift` at the end of the edge. */
  node?: Maybe<ITopLift>;
}

/** Methods to use when ordering `TopLift`. */
export enum ITopLiftsOrderBy {
  Natural = "NATURAL",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  LabelAsc = "LABEL_ASC",
  LabelDesc = "LABEL_DESC",
  MaxWeightAsc = "MAX_WEIGHT_ASC",
  MaxWeightDesc = "MAX_WEIGHT_DESC",
}

export interface ITopWeight {
   __typename?: "TopWeight";
  date?: Maybe<Scalars["Date"]>;
  weight?: Maybe<Scalars["Float"]>;
  reps?: Maybe<Scalars["Int"]>;
}

/** A connection to a list of `TopWeight` values. */
export interface ITopWeightsConnection {
   __typename?: "TopWeightsConnection";
  /** A list of `TopWeight` objects. */
  nodes: Array<Maybe<ITopWeight>>;
  /** A list of edges which contains the `TopWeight` and cursor to aid in pagination. */
  edges: ITopWeightsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `TopWeight` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `TopWeight` edge in the connection. */
export interface ITopWeightsEdge {
   __typename?: "TopWeightsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `TopWeight` at the end of the edge. */
  node?: Maybe<ITopWeight>;
}

export interface ITrainingPlan {
   __typename?: "TrainingPlan";
  /** Public ID of a workout template */
  id: Scalars["ID"];
  /** Name of the template */
  name: Scalars["String"];
  /** Expected duration of one session (on the first week) */
  duration: Scalars["Int"];
  /** Random notes for a whole template */
  notes?: Maybe<Scalars["String"]>;
  /** Author of workout */
  authorId: Scalars["ID"];
  /** Timestamp of the last save */
  updatedAt: Scalars["NaiveDateTime"];
  /** Timestamp of the first save */
  createdAt: Scalars["NaiveDateTime"];
  /** Is program shared */
  isShared: Scalars["Boolean"];
  /** ID of legacy plan */
  legacyPlanId?: Maybe<Scalars["ID"]>;
  author?: Maybe<IUser>;
  slots: ITrainingPlanSlotsConnection;
}

export interface ITrainingPlanAssignment {
   __typename?: "TrainingPlanAssignment";
  id: Scalars["ID"];
  trainingPlanId: Scalars["ID"];
  startDate: Scalars["NaiveDate"];
  endDate: Scalars["NaiveDate"];
  assignedBy: Scalars["ID"];
  trainingPlan?: Maybe<ITrainingPlan>;
}

export interface ITrainingPlanAssignmentsConnection {
   __typename?: "TrainingPlanAssignmentsConnection";
  /** List of available training plan slots */
  nodes: ITrainingPlanAssignment[];
  /** Total number of available training plan slots */
  totalCount: Scalars["Int"];
}

export enum ITrainingPlanFilter {
  Own = "OWN",
  Assigned = "ASSIGNED",
  Club = "CLUB",
  Org = "ORG",
  Keystone = "KEYSTONE",
  All = "ALL",
  AllLegacy = "ALL_LEGACY",
}

export interface ITrainingPlanInput {
  id?: Maybe<Scalars["ID"]>;
  name: Scalars["String"];
  duration: Scalars["Int"];
  notes?: Maybe<Scalars["String"]>;
  slots: ITrainingPlanSlotInput[];
}

export interface ITrainingPlansConnection {
   __typename?: "TrainingPlansConnection";
  /** List of available workout templates */
  nodes: ITrainingPlan[];
  /** Total number of available workout templates */
  totalCount: Scalars["Int"];
}

export interface ITrainingPlanSlot {
   __typename?: "TrainingPlanSlot";
  workoutTemplateId?: Maybe<Scalars["ID"]>;
  workoutTemplateName?: Maybe<Scalars["String"]>;
  offset: Scalars["Int"];
  phase?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  workoutTemplate?: Maybe<IWorkoutTemplate>;
}

export interface ITrainingPlanSlotInput {
  workoutTemplateId?: Maybe<Scalars["ID"]>;
  offset: Scalars["Int"];
  phase?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
}

export interface ITrainingPlanSlotsConnection {
   __typename?: "TrainingPlanSlotsConnection";
  /** List of available training plan slots */
  nodes: ITrainingPlanSlot[];
  /** Total number of available training plan slots */
  totalCount: Scalars["Int"];
}

export interface ITrainingProgram  extends INode {
   __typename?: "TrainingProgram";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  name: Scalars["String"];
  tags?: Maybe<Array<Maybe<Scalars["String"]>>>;
  coachId?: Maybe<Scalars["Int"]>;
  body?: Maybe<Scalars["Json"]>;
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  duration?: Maybe<Scalars["Int"]>;
  notes?: Maybe<Scalars["String"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  builderVersion?: Maybe<Scalars["Int"]>;
  cycles?: Maybe<Scalars["Json"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads a single `Coach` that is related to this `TrainingProgram`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads and enables pagination through a set of `MemberTrainingProgram`. */
  memberTrainingProgramsByTrainingProgramId: IMemberTrainingProgramsConnection;
  /** Reads and enables pagination through a set of `ProgramWorkout`. */
  programWorkoutsByProgramId: IProgramWorkoutsConnection;
  allWorkoutsV3Compatible?: Maybe<Scalars["Boolean"]>;
  hasCycles?: Maybe<Scalars["Boolean"]>;
}

export interface ITrainingProgramMemberTrainingProgramsByTrainingProgramIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
  condition?: Maybe<IMemberTrainingProgramCondition>;
}

export interface ITrainingProgramProgramWorkoutsByProgramIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
  condition?: Maybe<IProgramWorkoutCondition>;
}

/**
 * A condition to be used against `TrainingProgram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface ITrainingProgramCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: Maybe<Array<Maybe<Scalars["String"]>>>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `builderVersion` field. */
  builderVersion?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `cycles` field. */
  cycles?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface ITrainingProgramInput {
  name: Scalars["String"];
  coachId: Scalars["Int"];
  workspaceId: Scalars["Int"];
  tags: Array<Scalars["String"]>;
  builderVersion: Scalars["Int"];
}

export interface ITrainingProgramPatch {
  /** new program name */
  name?: Maybe<Scalars["String"]>;
  /** new program duration */
  duration?: Maybe<Scalars["Int"]>;
  /** new program notes */
  notes?: Maybe<Scalars["String"]>;
  /** new program cycles */
  cycles?: Maybe<Scalars["Json"]>;
}

/** A connection to a list of `TrainingProgram` values. */
export interface ITrainingProgramsConnection {
   __typename?: "TrainingProgramsConnection";
  /** A list of `TrainingProgram` objects. */
  nodes: Array<Maybe<ITrainingProgram>>;
  /** A list of edges which contains the `TrainingProgram` and cursor to aid in pagination. */
  edges: ITrainingProgramsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `TrainingProgram` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `TrainingProgram` edge in the connection. */
export interface ITrainingProgramsEdge {
   __typename?: "TrainingProgramsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `TrainingProgram` at the end of the edge. */
  node?: Maybe<ITrainingProgram>;
}

/** Methods to use when ordering `TrainingProgram`. */
export enum ITrainingProgramsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  TagsAsc = "TAGS_ASC",
  TagsDesc = "TAGS_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  BodyAsc = "BODY_ASC",
  BodyDesc = "BODY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  DurationAsc = "DURATION_ASC",
  DurationDesc = "DURATION_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  BuilderVersionAsc = "BUILDER_VERSION_ASC",
  BuilderVersionDesc = "BUILDER_VERSION_DESC",
  CyclesAsc = "CYCLES_ASC",
  CyclesDesc = "CYCLES_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface ITransferMembersInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
  /** List of member ids to transfer */
  memberIds: Array<Scalars["ID"]>;
  /** Recipient coach id */
  coachId: Scalars["ID"];
}

export interface ITransferMembersPayload {
   __typename?: "TransferMembersPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["String"]>;
}

/** All input for the `unarchiveWorkout` mutation. */
export interface IUnarchiveWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workoutId: Scalars["Uuid"];
}

/** The output of our `unarchiveWorkout` mutation. */
export interface IUnarchiveWorkoutPayload {
   __typename?: "UnarchiveWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workout?: Maybe<IWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Workout`. May be used by Relay 1. */
  workoutEdge?: Maybe<IWorkoutsEdge>;
}

/** The output of our `unarchiveWorkout` mutation. */
export interface IUnarchiveWorkoutPayloadWorkoutEdgeArgs {
  orderBy?: Maybe<IWorkoutsOrderBy[]>;
}

/** All input for the `updateAttendanceById` mutation. */
export interface IUpdateAttendanceByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Attendance` being updated. */
  attendancePatch: IAttendancePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateAttendanceBySessionIdAndPersonId` mutation. */
export interface IUpdateAttendanceBySessionIdAndPersonIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Attendance` being updated. */
  attendancePatch: IAttendancePatch;
  sessionId: Scalars["Uuid"];
  personId: Scalars["Uuid"];
}

/** All input for the `updateAttendance` mutation. */
export interface IUpdateAttendanceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Attendance` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Attendance` being updated. */
  attendancePatch: IAttendancePatch;
}

/** All input for the `updateAttendanceOverrideById` mutation. */
export interface IUpdateAttendanceOverrideByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `AttendanceOverride` being updated. */
  attendanceOverridePatch: IAttendanceOverridePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateAttendanceOverride` mutation. */
export interface IUpdateAttendanceOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `AttendanceOverride` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `AttendanceOverride` being updated. */
  attendanceOverridePatch: IAttendanceOverridePatch;
}

/** The output of our update `AttendanceOverride` mutation. */
export interface IUpdateAttendanceOverridePayload {
   __typename?: "UpdateAttendanceOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendanceOverride` that was updated by this mutation. */
  attendanceOverride?: Maybe<IAttendanceOverride>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendanceOverride`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Attendance` that is related to this `AttendanceOverride`. */
  attendanceByAttendanceId?: Maybe<IAttendance>;
  /** Reads a single `Booking` that is related to this `AttendanceOverride`. */
  bookingByBookingId?: Maybe<IBooking>;
  /** An edge for our `AttendanceOverride`. May be used by Relay 1. */
  attendanceOverrideEdge?: Maybe<IAttendanceOverridesEdge>;
}

/** The output of our update `AttendanceOverride` mutation. */
export interface IUpdateAttendanceOverridePayloadAttendanceOverrideEdgeArgs {
  orderBy?: Maybe<IAttendanceOverridesOrderBy[]>;
}

/** The output of our update `Attendance` mutation. */
export interface IUpdateAttendancePayload {
   __typename?: "UpdateAttendancePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendance` that was updated by this mutation. */
  attendance?: Maybe<IAttendance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `Attendance`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Attendee` that is related to this `Attendance`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Attendance`. May be used by Relay 1. */
  attendanceEdge?: Maybe<IAttendancesEdge>;
}

/** The output of our update `Attendance` mutation. */
export interface IUpdateAttendancePayloadAttendanceEdgeArgs {
  orderBy?: Maybe<IAttendancesOrderBy[]>;
}

/** All input for the `updateAttendeeById` mutation. */
export interface IUpdateAttendeeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Attendee` being updated. */
  attendeePatch: IAttendeePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateAttendeeClubByAttendeeIdAndClubId` mutation. */
export interface IUpdateAttendeeClubByAttendeeIdAndClubIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `AttendeeClub` being updated. */
  attendeeClubPatch: IAttendeeClubPatch;
  attendeeId: Scalars["Uuid"];
  clubId: Scalars["Uuid"];
}

/** All input for the `updateAttendeeClub` mutation. */
export interface IUpdateAttendeeClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `AttendeeClub` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `AttendeeClub` being updated. */
  attendeeClubPatch: IAttendeeClubPatch;
}

/** The output of our update `AttendeeClub` mutation. */
export interface IUpdateAttendeeClubPayload {
   __typename?: "UpdateAttendeeClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `AttendeeClub` that was updated by this mutation. */
  attendeeClub?: Maybe<IAttendeeClub>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Attendee` that is related to this `AttendeeClub`. */
  attendeeByAttendeeId?: Maybe<IAttendee>;
  /** Reads a single `Club` that is related to this `AttendeeClub`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `AttendeeClub`. May be used by Relay 1. */
  attendeeClubEdge?: Maybe<IAttendeeClubsEdge>;
}

/** The output of our update `AttendeeClub` mutation. */
export interface IUpdateAttendeeClubPayloadAttendeeClubEdgeArgs {
  orderBy?: Maybe<IAttendeeClubsOrderBy[]>;
}

/** All input for the `updateAttendee` mutation. */
export interface IUpdateAttendeeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Attendee` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Attendee` being updated. */
  attendeePatch: IAttendeePatch;
}

/** The output of our update `Attendee` mutation. */
export interface IUpdateAttendeePayload {
   __typename?: "UpdateAttendeePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Attendee` that was updated by this mutation. */
  attendee?: Maybe<IAttendee>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Attendee`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Attendee`. May be used by Relay 1. */
  attendeeEdge?: Maybe<IAttendeesEdge>;
}

/** The output of our update `Attendee` mutation. */
export interface IUpdateAttendeePayloadAttendeeEdgeArgs {
  orderBy?: Maybe<IAttendeesOrderBy[]>;
}

/** All input for the `updateBookingById` mutation. */
export interface IUpdateBookingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Booking` being updated. */
  bookingPatch: IBookingPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateBooking` mutation. */
export interface IUpdateBookingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Booking` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Booking` being updated. */
  bookingPatch: IBookingPatch;
}

/** The output of our update `Booking` mutation. */
export interface IUpdateBookingPayload {
   __typename?: "UpdateBookingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Booking` that was updated by this mutation. */
  booking?: Maybe<IBooking>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Booking`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `Booking`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `Booking`. May be used by Relay 1. */
  bookingEdge?: Maybe<IBookingsEdge>;
}

/** The output of our update `Booking` mutation. */
export interface IUpdateBookingPayloadBookingEdgeArgs {
  orderBy?: Maybe<IBookingsOrderBy[]>;
}

/** All input for the `updateBrandBarcodeByBrandIdAndGtinId` mutation. */
export interface IUpdateBrandBarcodeByBrandIdAndGtinIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `BrandBarcode` being updated. */
  brandBarcodePatch: IBrandBarcodePatch;
  brandId: Scalars["Uuid"];
  gtinId: Scalars["String"];
}

/** All input for the `updateBrandBarcode` mutation. */
export interface IUpdateBrandBarcodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `BrandBarcode` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `BrandBarcode` being updated. */
  brandBarcodePatch: IBrandBarcodePatch;
}

/** The output of our update `BrandBarcode` mutation. */
export interface IUpdateBrandBarcodePayload {
   __typename?: "UpdateBrandBarcodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `BrandBarcode` that was updated by this mutation. */
  brandBarcode?: Maybe<IBrandBarcode>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `BrandBarcode`. */
  brandByBrandId?: Maybe<IBrand>;
  /** An edge for our `BrandBarcode`. May be used by Relay 1. */
  brandBarcodeEdge?: Maybe<IBrandBarcodesEdge>;
}

/** The output of our update `BrandBarcode` mutation. */
export interface IUpdateBrandBarcodePayloadBrandBarcodeEdgeArgs {
  orderBy?: Maybe<IBrandBarcodesOrderBy[]>;
}

/** All input for the `updateBrandById` mutation. */
export interface IUpdateBrandByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: IBrandPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateBrand` mutation. */
export interface IUpdateBrandInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Brand` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: IBrandPatch;
}

/** The output of our update `Brand` mutation. */
export interface IUpdateBrandPayload {
   __typename?: "UpdateBrandPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Brand` that was updated by this mutation. */
  brand?: Maybe<IBrand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<IBrandsEdge>;
}

/** The output of our update `Brand` mutation. */
export interface IUpdateBrandPayloadBrandEdgeArgs {
  orderBy?: Maybe<IBrandsOrderBy[]>;
}

/** All input for the `updateCategoryById` mutation. */
export interface IUpdateCategoryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: ICategoryPatch;
  id: Scalars["Int"];
}

/** All input for the `updateCategory` mutation. */
export interface IUpdateCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Category` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: ICategoryPatch;
}

/** The output of our update `Category` mutation. */
export interface IUpdateCategoryPayload {
   __typename?: "UpdateCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Category` that was updated by this mutation. */
  category?: Maybe<ICategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<ICategoriesEdge>;
}

/** The output of our update `Category` mutation. */
export interface IUpdateCategoryPayloadCategoryEdgeArgs {
  orderBy?: Maybe<ICategoriesOrderBy[]>;
}

/** All input for the `updateClassById` mutation. */
export interface IUpdateClassByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Class` being updated. */
  classPatch: IClassPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateClass` mutation. */
export interface IUpdateClassInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Class` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Class` being updated. */
  classPatch: IClassPatch;
}

/** All input for the `updateClassInstructorByClassIdAndInstructorId` mutation. */
export interface IUpdateClassInstructorByClassIdAndInstructorIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ClassInstructor` being updated. */
  classInstructorPatch: IClassInstructorPatch;
  classId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

/** All input for the `updateClassInstructor` mutation. */
export interface IUpdateClassInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ClassInstructor` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `ClassInstructor` being updated. */
  classInstructorPatch: IClassInstructorPatch;
}

/** The output of our update `ClassInstructor` mutation. */
export interface IUpdateClassInstructorPayload {
   __typename?: "UpdateClassInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ClassInstructor` that was updated by this mutation. */
  classInstructor?: Maybe<IClassInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `ClassInstructor`. */
  classByClassId?: Maybe<IClass>;
  /** Reads a single `Instructor` that is related to this `ClassInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `ClassInstructor`. May be used by Relay 1. */
  classInstructorEdge?: Maybe<IClassInstructorsEdge>;
}

/** The output of our update `ClassInstructor` mutation. */
export interface IUpdateClassInstructorPayloadClassInstructorEdgeArgs {
  orderBy?: Maybe<IClassInstructorsOrderBy[]>;
}

/** The output of our update `Class` mutation. */
export interface IUpdateClassPayload {
   __typename?: "UpdateClassPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Class` that was updated by this mutation. */
  class?: Maybe<IClass>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Class`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Class`. May be used by Relay 1. */
  classEdge?: Maybe<IClassesEdge>;
}

/** The output of our update `Class` mutation. */
export interface IUpdateClassPayloadClassEdgeArgs {
  orderBy?: Maybe<IClassesOrderBy[]>;
}

/** All input for the `updateClubById` mutation. */
export interface IUpdateClubByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Club` being updated. */
  clubPatch: IClubPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateClubByKsClubId` mutation. */
export interface IUpdateClubByKsClubIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Club` being updated. */
  clubPatch: IClubPatch;
  /** 1-1 ref to ks_meta.club(id) */
  ksClubId: Scalars["String"];
}

/** All input for the `updateClub` mutation. */
export interface IUpdateClubInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Club` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Club` being updated. */
  clubPatch: IClubPatch;
}

/** The output of our update `Club` mutation. */
export interface IUpdateClubPayload {
   __typename?: "UpdateClubPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Club` that was updated by this mutation. */
  club?: Maybe<IClub>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Club`. May be used by Relay 1. */
  clubEdge?: Maybe<IClubsEdge>;
}

/** The output of our update `Club` mutation. */
export interface IUpdateClubPayloadClubEdgeArgs {
  orderBy?: Maybe<IClubsOrderBy[]>;
}

/** All input for the `updateCoachById` mutation. */
export interface IUpdateCoachByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Coach` being updated. */
  coachPatch: ICoachPatch;
  /** The primary unique identifier for the coach. */
  id: Scalars["Int"];
}

/** All input for the `updateCoach` mutation. */
export interface IUpdateCoachInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Coach` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Coach` being updated. */
  coachPatch: ICoachPatch;
}

/** The output of our update `Coach` mutation. */
export interface IUpdateCoachPayload {
   __typename?: "UpdateCoachPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Coach` that was updated by this mutation. */
  coach?: Maybe<ICoach>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Coach`. */
  locationByLocationId?: Maybe<ILocation>;
  /** An edge for our `Coach`. May be used by Relay 1. */
  coachEdge?: Maybe<ICoachesEdge>;
}

/** The output of our update `Coach` mutation. */
export interface IUpdateCoachPayloadCoachEdgeArgs {
  orderBy?: Maybe<ICoachesOrderBy[]>;
}

/** All input for the `updateCompositionByFoodId` mutation. */
export interface IUpdateCompositionByFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Composition` being updated. */
  compositionPatch: ICompositionPatch;
  foodId: Scalars["Uuid"];
}

/** All input for the `updateComposition` mutation. */
export interface IUpdateCompositionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Composition` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Composition` being updated. */
  compositionPatch: ICompositionPatch;
}

/** The output of our update `Composition` mutation. */
export interface IUpdateCompositionPayload {
   __typename?: "UpdateCompositionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Composition` that was updated by this mutation. */
  composition?: Maybe<IComposition>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Composition`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Composition`. May be used by Relay 1. */
  compositionEdge?: Maybe<ICompositionsEdge>;
}

/** The output of our update `Composition` mutation. */
export interface IUpdateCompositionPayloadCompositionEdgeArgs {
  orderBy?: Maybe<ICompositionsOrderBy[]>;
}

/** All input for the `updateCountryById` mutation. */
export interface IUpdateCountryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: ICountryPatch;
  id: Scalars["Int"];
}

/** All input for the `updateCountry` mutation. */
export interface IUpdateCountryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: ICountryPatch;
}

/** The output of our update `Country` mutation. */
export interface IUpdateCountryPayload {
   __typename?: "UpdateCountryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<ICountry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<ICountriesEdge>;
}

/** The output of our update `Country` mutation. */
export interface IUpdateCountryPayloadCountryEdgeArgs {
  orderBy?: Maybe<ICountriesOrderBy[]>;
}

/** All input for the `updateDataSourceById` mutation. */
export interface IUpdateDataSourceByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `DataSource` being updated. */
  dataSourcePatch: IDataSourcePatch;
  id: Scalars["String"];
}

/** All input for the `updateDataSourceBySourceName` mutation. */
export interface IUpdateDataSourceBySourceNameInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `DataSource` being updated. */
  dataSourcePatch: IDataSourcePatch;
  sourceName: Scalars["String"];
}

/** All input for the `updateDataSource` mutation. */
export interface IUpdateDataSourceInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `DataSource` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `DataSource` being updated. */
  dataSourcePatch: IDataSourcePatch;
}

/** The output of our update `DataSource` mutation. */
export interface IUpdateDataSourcePayload {
   __typename?: "UpdateDataSourcePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `DataSource` that was updated by this mutation. */
  dataSource?: Maybe<IDataSource>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `DataSource`. May be used by Relay 1. */
  dataSourceEdge?: Maybe<IDataSourcesEdge>;
}

/** The output of our update `DataSource` mutation. */
export interface IUpdateDataSourcePayloadDataSourceEdgeArgs {
  orderBy?: Maybe<IDataSourcesOrderBy[]>;
}

/** All input for the `updateExerciseById` mutation. */
export interface IUpdateExerciseByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Exercise` being updated. */
  exercisePatch: IExercisePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateExercise` mutation. */
export interface IUpdateExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Exercise` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Exercise` being updated. */
  exercisePatch: IExercisePatch;
}

/** All input for the `updateExerciseOverrideByExerciseIdAndWorkspaceId` mutation. */
export interface IUpdateExerciseOverrideByExerciseIdAndWorkspaceIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ExerciseOverride` being updated. */
  exerciseOverridePatch: IExerciseOverridePatch;
  exerciseId: Scalars["Uuid"];
  workspaceId: Scalars["Int"];
}

/** All input for the `updateExerciseOverrideById` mutation. */
export interface IUpdateExerciseOverrideByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ExerciseOverride` being updated. */
  exerciseOverridePatch: IExerciseOverridePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateExerciseOverride` mutation. */
export interface IUpdateExerciseOverrideInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ExerciseOverride` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `ExerciseOverride` being updated. */
  exerciseOverridePatch: IExerciseOverridePatch;
}

/** The output of our update `ExerciseOverride` mutation. */
export interface IUpdateExerciseOverridePayload {
   __typename?: "UpdateExerciseOverridePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ExerciseOverride` that was updated by this mutation. */
  exerciseOverride?: Maybe<IExerciseOverride>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Exercise` that is related to this `ExerciseOverride`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `ExerciseOverride`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `ExerciseOverride`. May be used by Relay 1. */
  exerciseOverrideEdge?: Maybe<IExerciseOverridesEdge>;
}

/** The output of our update `ExerciseOverride` mutation. */
export interface IUpdateExerciseOverridePayloadExerciseOverrideEdgeArgs {
  orderBy?: Maybe<IExerciseOverridesOrderBy[]>;
}

/** The output of our update `Exercise` mutation. */
export interface IUpdateExercisePayload {
   __typename?: "UpdateExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Exercise` that was updated by this mutation. */
  exercise?: Maybe<IExercise>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Exercise`. May be used by Relay 1. */
  exerciseEdge?: Maybe<IExercisesEdge>;
}

/** The output of our update `Exercise` mutation. */
export interface IUpdateExercisePayloadExerciseEdgeArgs {
  orderBy?: Maybe<IExercisesOrderBy[]>;
}

/** All input for the `updateFavouriteFoodById` mutation. */
export interface IUpdateFavouriteFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `FavouriteFood` being updated. */
  favouriteFoodPatch: IFavouriteFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateFavouriteFood` mutation. */
export interface IUpdateFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FavouriteFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `FavouriteFood` being updated. */
  favouriteFoodPatch: IFavouriteFoodPatch;
}

/** The output of our update `FavouriteFood` mutation. */
export interface IUpdateFavouriteFoodPayload {
   __typename?: "UpdateFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FavouriteFood` that was updated by this mutation. */
  favouriteFood?: Maybe<IFavouriteFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `FavouriteFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `FavouriteFood`. May be used by Relay 1. */
  favouriteFoodEdge?: Maybe<IFavouriteFoodsEdge>;
}

/** The output of our update `FavouriteFood` mutation. */
export interface IUpdateFavouriteFoodPayloadFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IFavouriteFoodsOrderBy[]>;
}

/** All input for the `updateFoodbankFoodById` mutation. */
export interface IUpdateFoodbankFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `FoodbankFood` being updated. */
  foodbankFoodPatch: IFoodbankFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateFoodbankFood` mutation. */
export interface IUpdateFoodbankFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodbankFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `FoodbankFood` being updated. */
  foodbankFoodPatch: IFoodbankFoodPatch;
}

/** The output of our update `FoodbankFood` mutation. */
export interface IUpdateFoodbankFoodPayload {
   __typename?: "UpdateFoodbankFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankFood` that was updated by this mutation. */
  foodbankFood?: Maybe<IFoodbankFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Brand` that is related to this `FoodbankFood`. */
  brandByBrand?: Maybe<IBrand>;
  /** Reads a single `Country` that is related to this `FoodbankFood`. */
  countryByCountryId?: Maybe<ICountry>;
  /** Reads a single `DataSource` that is related to this `FoodbankFood`. */
  dataSourceBySource?: Maybe<IDataSource>;
  /** An edge for our `FoodbankFood`. May be used by Relay 1. */
  foodbankFoodEdge?: Maybe<IFoodbankFoodsEdge>;
}

/** The output of our update `FoodbankFood` mutation. */
export interface IUpdateFoodbankFoodPayloadFoodbankFoodEdgeArgs {
  orderBy?: Maybe<IFoodbankFoodsOrderBy[]>;
}

/** All input for the `updateFoodbankNutritionFactByFoodId` mutation. */
export interface IUpdateFoodbankNutritionFactByFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `FoodbankNutritionFact` being updated. */
  foodbankNutritionFactPatch: IFoodbankNutritionFactPatch;
  foodId: Scalars["Uuid"];
}

/** All input for the `updateFoodbankNutritionFact` mutation. */
export interface IUpdateFoodbankNutritionFactInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodbankNutritionFact` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `FoodbankNutritionFact` being updated. */
  foodbankNutritionFactPatch: IFoodbankNutritionFactPatch;
}

/** The output of our update `FoodbankNutritionFact` mutation. */
export interface IUpdateFoodbankNutritionFactPayload {
   __typename?: "UpdateFoodbankNutritionFactPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodbankNutritionFact` that was updated by this mutation. */
  foodbankNutritionFact?: Maybe<IFoodbankNutritionFact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodbankNutritionFact`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `FoodbankNutritionFact`. May be used by Relay 1. */
  foodbankNutritionFactEdge?: Maybe<IFoodbankNutritionFactsEdge>;
}

/** The output of our update `FoodbankNutritionFact` mutation. */
export interface IUpdateFoodbankNutritionFactPayloadFoodbankNutritionFactEdgeArgs {
  orderBy?: Maybe<IFoodbankNutritionFactsOrderBy[]>;
}

/** All input for the `updateFoodById` mutation. */
export interface IUpdateFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Food` being updated. */
  foodPatch: IFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateFoodCategoryByFoodIdAndCategoryId` mutation. */
export interface IUpdateFoodCategoryByFoodIdAndCategoryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `FoodCategory` being updated. */
  foodCategoryPatch: IFoodCategoryPatch;
  foodId: Scalars["Uuid"];
  categoryId: Scalars["Int"];
}

/** All input for the `updateFoodCategory` mutation. */
export interface IUpdateFoodCategoryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `FoodCategory` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `FoodCategory` being updated. */
  foodCategoryPatch: IFoodCategoryPatch;
}

/** The output of our update `FoodCategory` mutation. */
export interface IUpdateFoodCategoryPayload {
   __typename?: "UpdateFoodCategoryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `FoodCategory` that was updated by this mutation. */
  foodCategory?: Maybe<IFoodCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `FoodCategory`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** Reads a single `Category` that is related to this `FoodCategory`. */
  categoryByCategoryId?: Maybe<ICategory>;
  /** An edge for our `FoodCategory`. May be used by Relay 1. */
  foodCategoryEdge?: Maybe<IFoodCategoriesEdge>;
}

/** The output of our update `FoodCategory` mutation. */
export interface IUpdateFoodCategoryPayloadFoodCategoryEdgeArgs {
  orderBy?: Maybe<IFoodCategoriesOrderBy[]>;
}

/** All input for the `updateFood` mutation. */
export interface IUpdateFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Food` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Food` being updated. */
  foodPatch: IFoodPatch;
}

/** The output of our update `Food` mutation. */
export interface IUpdateFoodPayload {
   __typename?: "UpdateFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Food` that was updated by this mutation. */
  food?: Maybe<IFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `Food`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `Food`. May be used by Relay 1. */
  foodEdge?: Maybe<IFoodsEdge>;
}

/** The output of our update `Food` mutation. */
export interface IUpdateFoodPayloadFoodEdgeArgs {
  orderBy?: Maybe<IFoodsOrderBy[]>;
}

/** All input for the `updateGtinByFoodIdAndGtin` mutation. */
export interface IUpdateGtinByFoodIdAndGtinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Gtin` being updated. */
  gtinPatch: IGtinPatch;
  foodId: Scalars["Uuid"];
  gtin: Scalars["String"];
}

/** All input for the `updateGtin` mutation. */
export interface IUpdateGtinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Gtin` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Gtin` being updated. */
  gtinPatch: IGtinPatch;
}

/** The output of our update `Gtin` mutation. */
export interface IUpdateGtinPayload {
   __typename?: "UpdateGtinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Gtin` that was updated by this mutation. */
  gtin?: Maybe<IGtin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Gtin`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Gtin`. May be used by Relay 1. */
  gtinEdge?: Maybe<IGtinsEdge>;
}

/** The output of our update `Gtin` mutation. */
export interface IUpdateGtinPayloadGtinEdgeArgs {
  orderBy?: Maybe<IGtinsOrderBy[]>;
}

/** All input for the `updateHistoryActionById` mutation. */
export interface IUpdateHistoryActionByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `HistoryAction` being updated. */
  historyActionPatch: IHistoryActionPatch;
  id: Scalars["Int"];
}

/** All input for the `updateHistoryAction` mutation. */
export interface IUpdateHistoryActionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `HistoryAction` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `HistoryAction` being updated. */
  historyActionPatch: IHistoryActionPatch;
}

/** The output of our update `HistoryAction` mutation. */
export interface IUpdateHistoryActionPayload {
   __typename?: "UpdateHistoryActionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `HistoryAction` that was updated by this mutation. */
  historyAction?: Maybe<IHistoryAction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `HistoryAction`. May be used by Relay 1. */
  historyActionEdge?: Maybe<IHistoryActionsEdge>;
}

/** The output of our update `HistoryAction` mutation. */
export interface IUpdateHistoryActionPayloadHistoryActionEdgeArgs {
  orderBy?: Maybe<IHistoryActionsOrderBy[]>;
}

/** All input for the `updateInstructorById` mutation. */
export interface IUpdateInstructorByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Instructor` being updated. */
  instructorPatch: IInstructorPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateInstructor` mutation. */
export interface IUpdateInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Instructor` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Instructor` being updated. */
  instructorPatch: IInstructorPatch;
}

/** The output of our update `Instructor` mutation. */
export interface IUpdateInstructorPayload {
   __typename?: "UpdateInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Instructor` that was updated by this mutation. */
  instructor?: Maybe<IInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Club` that is related to this `Instructor`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Instructor`. May be used by Relay 1. */
  instructorEdge?: Maybe<IInstructorsEdge>;
}

/** The output of our update `Instructor` mutation. */
export interface IUpdateInstructorPayloadInstructorEdgeArgs {
  orderBy?: Maybe<IInstructorsOrderBy[]>;
}

/** All input for the `updateLocationById` mutation. */
export interface IUpdateLocationByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Location` being updated. */
  locationPatch: ILocationPatch;
  id: Scalars["Int"];
}

/** All input for the `updateLocation` mutation. */
export interface IUpdateLocationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Location` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Location` being updated. */
  locationPatch: ILocationPatch;
}

/** The output of our update `Location` mutation. */
export interface IUpdateLocationPayload {
   __typename?: "UpdateLocationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Location` that was updated by this mutation. */
  location?: Maybe<ILocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge?: Maybe<ILocationsEdge>;
}

/** The output of our update `Location` mutation. */
export interface IUpdateLocationPayloadLocationEdgeArgs {
  orderBy?: Maybe<ILocationsOrderBy[]>;
}

/** All input for the `updateManagerById` mutation. */
export interface IUpdateManagerByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Manager` being updated. */
  managerPatch: IManagerPatch;
  id: Scalars["Int"];
}

/** All input for the `updateManagerClubOrgById` mutation. */
export interface IUpdateManagerClubOrgByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ManagerClubOrg` being updated. */
  managerClubOrgPatch: IManagerClubOrgPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateManagerClubOrg` mutation. */
export interface IUpdateManagerClubOrgInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ManagerClubOrg` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `ManagerClubOrg` being updated. */
  managerClubOrgPatch: IManagerClubOrgPatch;
}

/** The output of our update `ManagerClubOrg` mutation. */
export interface IUpdateManagerClubOrgPayload {
   __typename?: "UpdateManagerClubOrgPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ManagerClubOrg` that was updated by this mutation. */
  managerClubOrg?: Maybe<IManagerClubOrg>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Manager` that is related to this `ManagerClubOrg`. */
  managerByManagerId?: Maybe<IManager>;
  /** An edge for our `ManagerClubOrg`. May be used by Relay 1. */
  managerClubOrgEdge?: Maybe<IManagerClubOrgsEdge>;
}

/** The output of our update `ManagerClubOrg` mutation. */
export interface IUpdateManagerClubOrgPayloadManagerClubOrgEdgeArgs {
  orderBy?: Maybe<IManagerClubOrgsOrderBy[]>;
}

/** All input for the `updateManager` mutation. */
export interface IUpdateManagerInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Manager` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Manager` being updated. */
  managerPatch: IManagerPatch;
}

/** The output of our update `Manager` mutation. */
export interface IUpdateManagerPayload {
   __typename?: "UpdateManagerPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Manager` that was updated by this mutation. */
  manager?: Maybe<IManager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Manager`. May be used by Relay 1. */
  managerEdge?: Maybe<IManagersEdge>;
}

/** The output of our update `Manager` mutation. */
export interface IUpdateManagerPayloadManagerEdgeArgs {
  orderBy?: Maybe<IManagersOrderBy[]>;
}

/** All input for the `updateMealItemById` mutation. */
export interface IUpdateMealItemByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MealItem` being updated. */
  mealItemPatch: IMealItemPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMealItem` mutation. */
export interface IUpdateMealItemInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MealItem` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MealItem` being updated. */
  mealItemPatch: IMealItemPatch;
}

/** The output of our update `MealItem` mutation. */
export interface IUpdateMealItemPayload {
   __typename?: "UpdateMealItemPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MealItem` that was updated by this mutation. */
  mealItem?: Maybe<IMealItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MemberMeal` that is related to this `MealItem`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** Reads a single `Food` that is related to this `MealItem`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MealItem`. May be used by Relay 1. */
  mealItemEdge?: Maybe<IMealItemsEdge>;
}

/** The output of our update `MealItem` mutation. */
export interface IUpdateMealItemPayloadMealItemEdgeArgs {
  orderBy?: Maybe<IMealItemsOrderBy[]>;
}

/** All input for the `updateMemberById` mutation. */
export interface IUpdateMemberByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Member` being updated. */
  memberPatch: IMemberPatch;
  /** The primary unique identifier for the member. */
  id: Scalars["Int"];
}

/** All input for the `updateMemberCheckinById` mutation. */
export interface IUpdateMemberCheckinByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberCheckin` being updated. */
  memberCheckinPatch: IMemberCheckinPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberCheckin` mutation. */
export interface IUpdateMemberCheckinInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberCheckin` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberCheckin` being updated. */
  memberCheckinPatch: IMemberCheckinPatch;
}

/** The output of our update `MemberCheckin` mutation. */
export interface IUpdateMemberCheckinPayload {
   __typename?: "UpdateMemberCheckinPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberCheckin` that was updated by this mutation. */
  memberCheckin?: Maybe<IMemberCheckin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberCheckin`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberCheckin`. May be used by Relay 1. */
  memberCheckinEdge?: Maybe<IMemberCheckinsEdge>;
}

/** The output of our update `MemberCheckin` mutation. */
export interface IUpdateMemberCheckinPayloadMemberCheckinEdgeArgs {
  orderBy?: Maybe<IMemberCheckinsOrderBy[]>;
}

/** All input for the `updateMemberEvaluatedRecipeById` mutation. */
export interface IUpdateMemberEvaluatedRecipeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberEvaluatedRecipe` being updated. */
  memberEvaluatedRecipePatch: IMemberEvaluatedRecipePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberEvaluatedRecipe` mutation. */
export interface IUpdateMemberEvaluatedRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberEvaluatedRecipe` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberEvaluatedRecipe` being updated. */
  memberEvaluatedRecipePatch: IMemberEvaluatedRecipePatch;
}

/** The output of our update `MemberEvaluatedRecipe` mutation. */
export interface IUpdateMemberEvaluatedRecipePayload {
   __typename?: "UpdateMemberEvaluatedRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberEvaluatedRecipe` that was updated by this mutation. */
  memberEvaluatedRecipe?: Maybe<IMemberEvaluatedRecipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `MemberEvaluatedRecipe`. */
  foodByFoodId?: Maybe<IFood>;
  /** Reads a single `MemberRecipe` that is related to this `MemberEvaluatedRecipe`. */
  memberRecipeByRecipeId?: Maybe<IMemberRecipe>;
  /** An edge for our `MemberEvaluatedRecipe`. May be used by Relay 1. */
  memberEvaluatedRecipeEdge?: Maybe<IMemberEvaluatedRecipesEdge>;
}

/** The output of our update `MemberEvaluatedRecipe` mutation. */
export interface IUpdateMemberEvaluatedRecipePayloadMemberEvaluatedRecipeEdgeArgs {
  orderBy?: Maybe<IMemberEvaluatedRecipesOrderBy[]>;
}

/** All input for the `updateMemberFavouriteFoodById` mutation. */
export interface IUpdateMemberFavouriteFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberFavouriteFood` being updated. */
  memberFavouriteFoodPatch: IMemberFavouriteFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberFavouriteFoodByMemberIdAndFoodId` mutation. */
export interface IUpdateMemberFavouriteFoodByMemberIdAndFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberFavouriteFood` being updated. */
  memberFavouriteFoodPatch: IMemberFavouriteFoodPatch;
  memberId: Scalars["Int"];
  foodId: Scalars["Int"];
}

/** All input for the `updateMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryId` mutation. */
export interface IUpdateMemberFavouriteFoodByMemberIdAndLabelAndMacrosEntryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberFavouriteFood` being updated. */
  memberFavouriteFoodPatch: IMemberFavouriteFoodPatch;
  memberId: Scalars["Int"];
  label: Scalars["String"];
  macrosEntryId: IMacrosEntryIdInput;
}

/** All input for the `updateMemberFavouriteFoodByMemberIdAndMyFoodId` mutation. */
export interface IUpdateMemberFavouriteFoodByMemberIdAndMyFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberFavouriteFood` being updated. */
  memberFavouriteFoodPatch: IMemberFavouriteFoodPatch;
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

/** All input for the `updateMemberFavouriteFood` mutation. */
export interface IUpdateMemberFavouriteFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberFavouriteFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberFavouriteFood` being updated. */
  memberFavouriteFoodPatch: IMemberFavouriteFoodPatch;
}

/** The output of our update `MemberFavouriteFood` mutation. */
export interface IUpdateMemberFavouriteFoodPayload {
   __typename?: "UpdateMemberFavouriteFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberFavouriteFood` that was updated by this mutation. */
  memberFavouriteFood?: Maybe<IMemberFavouriteFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberFavouriteFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberFavouriteFood`. May be used by Relay 1. */
  memberFavouriteFoodEdge?: Maybe<IMemberFavouriteFoodsEdge>;
}

/** The output of our update `MemberFavouriteFood` mutation. */
export interface IUpdateMemberFavouriteFoodPayloadMemberFavouriteFoodEdgeArgs {
  orderBy?: Maybe<IMemberFavouriteFoodsOrderBy[]>;
}

/** All input for the `updateMemberInfo` mutation. */
export interface IUpdateMemberInfoInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId: Scalars["Int"];
  firstName: Scalars["String"];
  lastName: Scalars["String"];
  email: Scalars["String"];
}

/** The output of our `updateMemberInfo` mutation. */
export interface IUpdateMemberInfoPayload {
   __typename?: "UpdateMemberInfoPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  string?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `updateMember` mutation. */
export interface IUpdateMemberInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Member` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Member` being updated. */
  memberPatch: IMemberPatch;
}

/** All input for the `updateMemberMealById` mutation. */
export interface IUpdateMemberMealByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberMeal` being updated. */
  memberMealPatch: IMemberMealPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberMeal` mutation. */
export interface IUpdateMemberMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMeal` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberMeal` being updated. */
  memberMealPatch: IMemberMealPatch;
}

/** The output of our update `MemberMeal` mutation. */
export interface IUpdateMemberMealPayload {
   __typename?: "UpdateMemberMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMeal` that was updated by this mutation. */
  memberMeal?: Maybe<IMemberMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMeal`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMeal`. May be used by Relay 1. */
  memberMealEdge?: Maybe<IMemberMealsEdge>;
}

/** The output of our update `MemberMeal` mutation. */
export interface IUpdateMemberMealPayloadMemberMealEdgeArgs {
  orderBy?: Maybe<IMemberMealsOrderBy[]>;
}

/** All input for the `updateMemberMetricByMemberIdAndDateAndKey` mutation. */
export interface IUpdateMemberMetricByMemberIdAndDateAndKeyInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberMetric` being updated. */
  memberMetricPatch: IMemberMetricPatch;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
  key: IMetricKey;
}

/** All input for the `updateMemberMetric` mutation. */
export interface IUpdateMemberMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMetric` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberMetric` being updated. */
  memberMetricPatch: IMemberMetricPatch;
}

/** The output of our update `MemberMetric` mutation. */
export interface IUpdateMemberMetricPayload {
   __typename?: "UpdateMemberMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMetric` that was updated by this mutation. */
  memberMetric?: Maybe<IMemberMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMetric`. May be used by Relay 1. */
  memberMetricEdge?: Maybe<IMemberMetricsEdge>;
}

/** The output of our update `MemberMetric` mutation. */
export interface IUpdateMemberMetricPayloadMemberMetricEdgeArgs {
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
}

/** All input for the `updateMemberMyFoodById` mutation. */
export interface IUpdateMemberMyFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberMyFood` being updated. */
  memberMyFoodPatch: IMemberMyFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberMyFood` mutation. */
export interface IUpdateMemberMyFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberMyFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberMyFood` being updated. */
  memberMyFoodPatch: IMemberMyFoodPatch;
}

/** The output of our update `MemberMyFood` mutation. */
export interface IUpdateMemberMyFoodPayload {
   __typename?: "UpdateMemberMyFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberMyFood` that was updated by this mutation. */
  memberMyFood?: Maybe<IMemberMyFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMyFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMyFood`. May be used by Relay 1. */
  memberMyFoodEdge?: Maybe<IMemberMyFoodsEdge>;
}

/** The output of our update `MemberMyFood` mutation. */
export interface IUpdateMemberMyFoodPayloadMemberMyFoodEdgeArgs {
  orderBy?: Maybe<IMemberMyFoodsOrderBy[]>;
}

/** All input for the `updateMemberNutritionMetricByMemberIdAndDate` mutation. */
export interface IUpdateMemberNutritionMetricByMemberIdAndDateInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberNutritionMetric` being updated. */
  memberNutritionMetricPatch: IMemberNutritionMetricPatch;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

/** All input for the `updateMemberNutritionMetric` mutation. */
export interface IUpdateMemberNutritionMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberNutritionMetric` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberNutritionMetric` being updated. */
  memberNutritionMetricPatch: IMemberNutritionMetricPatch;
}

/** The output of our update `MemberNutritionMetric` mutation. */
export interface IUpdateMemberNutritionMetricPayload {
   __typename?: "UpdateMemberNutritionMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionMetric` that was updated by this mutation. */
  memberNutritionMetric?: Maybe<IMemberNutritionMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberNutritionMetric`. May be used by Relay 1. */
  memberNutritionMetricEdge?: Maybe<IMemberNutritionMetricsEdge>;
}

/** The output of our update `MemberNutritionMetric` mutation. */
export interface IUpdateMemberNutritionMetricPayloadMemberNutritionMetricEdgeArgs {
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
}

/** All input for the `updateMemberNutritionPlanById` mutation. */
export interface IUpdateMemberNutritionPlanByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberNutritionPlan` being updated. */
  memberNutritionPlanPatch: IMemberNutritionPlanPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberNutritionPlan` mutation. */
export interface IUpdateMemberNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberNutritionPlan` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberNutritionPlan` being updated. */
  memberNutritionPlanPatch: IMemberNutritionPlanPatch;
}

/** The output of our update `MemberNutritionPlan` mutation. */
export interface IUpdateMemberNutritionPlanPayload {
   __typename?: "UpdateMemberNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberNutritionPlan` that was updated by this mutation. */
  memberNutritionPlan?: Maybe<IMemberNutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionPlan`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `NutritionPlan` that is related to this `MemberNutritionPlan`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `MemberNutritionPlan`. May be used by Relay 1. */
  memberNutritionPlanEdge?: Maybe<IMemberNutritionPlansEdge>;
}

/** The output of our update `MemberNutritionPlan` mutation. */
export interface IUpdateMemberNutritionPlanPayloadMemberNutritionPlanEdgeArgs {
  orderBy?: Maybe<IMemberNutritionPlansOrderBy[]>;
}

/** The output of our update `Member` mutation. */
export interface IUpdateMemberPayload {
   __typename?: "UpdateMemberPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Member` that was updated by this mutation. */
  member?: Maybe<IMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<IMembersEdge>;
}

/** The output of our update `Member` mutation. */
export interface IUpdateMemberPayloadMemberEdgeArgs {
  orderBy?: Maybe<IMembersOrderBy[]>;
}

/** All input for the `updateMemberProfile` mutation. */
export interface IUpdateMemberProfileInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  firstName?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  gender?: Maybe<Scalars["String"]>;
  dateOfBirth?: Maybe<Scalars["Date"]>;
  height?: Maybe<Scalars["Float"]>;
  goal?: Maybe<Scalars["String"]>;
}

/** The output of our `updateMemberProfile` mutation. */
export interface IUpdateMemberProfilePayload {
   __typename?: "UpdateMemberProfilePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  member?: Maybe<IMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Location` that is related to this `Member`. */
  locationByLocationId?: Maybe<ILocation>;
  /** Reads a single `Coach` that is related to this `Member`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<IMembersEdge>;
}

/** The output of our `updateMemberProfile` mutation. */
export interface IUpdateMemberProfilePayloadMemberEdgeArgs {
  orderBy?: Maybe<IMembersOrderBy[]>;
}

/** All input for the `updateMemberRecentFoodById` mutation. */
export interface IUpdateMemberRecentFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberRecentFoodByMemberIdAndFatSecretId` mutation. */
export interface IUpdateMemberRecentFoodByMemberIdAndFatSecretIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
  memberId: Scalars["Int"];
  fatSecretId: Scalars["Int"];
}

/** All input for the `updateMemberRecentFoodByMemberIdAndFoodId` mutation. */
export interface IUpdateMemberRecentFoodByMemberIdAndFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
  memberId: Scalars["Int"];
  foodId: Scalars["Uuid"];
}

/** All input for the `updateMemberRecentFoodByMemberIdAndMacroEntryId` mutation. */
export interface IUpdateMemberRecentFoodByMemberIdAndMacroEntryIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
  memberId: Scalars["Int"];
  macroEntryId: IMacroEntryIdInput;
}

/** All input for the `updateMemberRecentFoodByMemberIdAndMyFoodId` mutation. */
export interface IUpdateMemberRecentFoodByMemberIdAndMyFoodIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
  memberId: Scalars["Int"];
  myFoodId: Scalars["Uuid"];
}

/** All input for the `updateMemberRecentFood` mutation. */
export interface IUpdateMemberRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberRecentFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberRecentFood` being updated. */
  memberRecentFoodPatch: IMemberRecentFoodPatch;
}

/** The output of our update `MemberRecentFood` mutation. */
export interface IUpdateMemberRecentFoodPayload {
   __typename?: "UpdateMemberRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecentFood` that was updated by this mutation. */
  memberRecentFood?: Maybe<IMemberRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MemberRecentFood`. May be used by Relay 1. */
  memberRecentFoodEdge?: Maybe<IMemberRecentFoodsEdge>;
}

/** The output of our update `MemberRecentFood` mutation. */
export interface IUpdateMemberRecentFoodPayloadMemberRecentFoodEdgeArgs {
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
}

/** All input for the `updateMemberRecipeById` mutation. */
export interface IUpdateMemberRecipeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberRecipe` being updated. */
  memberRecipePatch: IMemberRecipePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberRecipe` mutation. */
export interface IUpdateMemberRecipeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberRecipe` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberRecipe` being updated. */
  memberRecipePatch: IMemberRecipePatch;
}

/** The output of our update `MemberRecipe` mutation. */
export interface IUpdateMemberRecipePayload {
   __typename?: "UpdateMemberRecipePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberRecipe` that was updated by this mutation. */
  memberRecipe?: Maybe<IMemberRecipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecipe`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `MemberMeal` that is related to this `MemberRecipe`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `MemberRecipe`. May be used by Relay 1. */
  memberRecipeEdge?: Maybe<IMemberRecipesEdge>;
}

/** The output of our update `MemberRecipe` mutation. */
export interface IUpdateMemberRecipePayloadMemberRecipeEdgeArgs {
  orderBy?: Maybe<IMemberRecipesOrderBy[]>;
}

/** All input for the `updateMemberReminderById` mutation. */
export interface IUpdateMemberReminderByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberReminder` being updated. */
  memberReminderPatch: IMemberReminderPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberReminder` mutation. */
export interface IUpdateMemberReminderInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberReminder` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberReminder` being updated. */
  memberReminderPatch: IMemberReminderPatch;
}

/** The output of our update `MemberReminder` mutation. */
export interface IUpdateMemberReminderPayload {
   __typename?: "UpdateMemberReminderPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberReminder` that was updated by this mutation. */
  memberReminder?: Maybe<IMemberReminder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberReminder`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Coach` that is related to this `MemberReminder`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `MemberReminder`. May be used by Relay 1. */
  memberReminderEdge?: Maybe<IMemberRemindersEdge>;
}

/** The output of our update `MemberReminder` mutation. */
export interface IUpdateMemberReminderPayloadMemberReminderEdgeArgs {
  orderBy?: Maybe<IMemberRemindersOrderBy[]>;
}

/** All input for the `updateMemberStepsMetricByMemberIdAndDate` mutation. */
export interface IUpdateMemberStepsMetricByMemberIdAndDateInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberStepsMetric` being updated. */
  memberStepsMetricPatch: IMemberStepsMetricPatch;
  memberId: Scalars["Int"];
  date: Scalars["Date"];
}

/** All input for the `updateMemberStepsMetric` mutation. */
export interface IUpdateMemberStepsMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberStepsMetric` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberStepsMetric` being updated. */
  memberStepsMetricPatch: IMemberStepsMetricPatch;
}

/** The output of our update `MemberStepsMetric` mutation. */
export interface IUpdateMemberStepsMetricPayload {
   __typename?: "UpdateMemberStepsMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberStepsMetric` that was updated by this mutation. */
  memberStepsMetric?: Maybe<IMemberStepsMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberStepsMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberStepsMetric`. May be used by Relay 1. */
  memberStepsMetricEdge?: Maybe<IMemberStepsMetricsEdge>;
}

/** The output of our update `MemberStepsMetric` mutation. */
export interface IUpdateMemberStepsMetricPayloadMemberStepsMetricEdgeArgs {
  orderBy?: Maybe<IMemberStepsMetricsOrderBy[]>;
}

/** All input for the `updateMemberTrainingProgramById` mutation. */
export interface IUpdateMemberTrainingProgramByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberTrainingProgram` being updated. */
  memberTrainingProgramPatch: IMemberTrainingProgramPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberTrainingProgram` mutation. */
export interface IUpdateMemberTrainingProgramInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberTrainingProgram` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberTrainingProgram` being updated. */
  memberTrainingProgramPatch: IMemberTrainingProgramPatch;
}

/** The output of our update `MemberTrainingProgram` mutation. */
export interface IUpdateMemberTrainingProgramPayload {
   __typename?: "UpdateMemberTrainingProgramPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberTrainingProgram` that was updated by this mutation. */
  memberTrainingProgram?: Maybe<IMemberTrainingProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberTrainingProgram`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `TrainingProgram` that is related to this `MemberTrainingProgram`. */
  trainingProgramByTrainingProgramId?: Maybe<ITrainingProgram>;
  /** An edge for our `MemberTrainingProgram`. May be used by Relay 1. */
  memberTrainingProgramEdge?: Maybe<IMemberTrainingProgramsEdge>;
}

/** The output of our update `MemberTrainingProgram` mutation. */
export interface IUpdateMemberTrainingProgramPayloadMemberTrainingProgramEdgeArgs {
  orderBy?: Maybe<IMemberTrainingProgramsOrderBy[]>;
}

/** All input for the `updateMemberWaterMetricByDateAndMemberId` mutation. */
export interface IUpdateMemberWaterMetricByDateAndMemberIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberWaterMetric` being updated. */
  memberWaterMetricPatch: IMemberWaterMetricPatch;
  date: Scalars["Date"];
  memberId: Scalars["Int"];
}

/** All input for the `updateMemberWaterMetricById` mutation. */
export interface IUpdateMemberWaterMetricByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberWaterMetric` being updated. */
  memberWaterMetricPatch: IMemberWaterMetricPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberWaterMetric` mutation. */
export interface IUpdateMemberWaterMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberWaterMetric` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberWaterMetric` being updated. */
  memberWaterMetricPatch: IMemberWaterMetricPatch;
}

/** The output of our update `MemberWaterMetric` mutation. */
export interface IUpdateMemberWaterMetricPayload {
   __typename?: "UpdateMemberWaterMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWaterMetric` that was updated by this mutation. */
  memberWaterMetric?: Maybe<IMemberWaterMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWaterMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberWaterMetric`. May be used by Relay 1. */
  memberWaterMetricEdge?: Maybe<IMemberWaterMetricsEdge>;
}

/** The output of our update `MemberWaterMetric` mutation. */
export interface IUpdateMemberWaterMetricPayloadMemberWaterMetricEdgeArgs {
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
}

/** All input for the `updateMemberWorkoutById` mutation. */
export interface IUpdateMemberWorkoutByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MemberWorkout` being updated. */
  memberWorkoutPatch: IMemberWorkoutPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMemberWorkout` mutation. */
export interface IUpdateMemberWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MemberWorkout` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MemberWorkout` being updated. */
  memberWorkoutPatch: IMemberWorkoutPatch;
}

/** The output of our update `MemberWorkout` mutation. */
export interface IUpdateMemberWorkoutPayload {
   __typename?: "UpdateMemberWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MemberWorkout` that was updated by this mutation. */
  memberWorkout?: Maybe<IMemberWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `MemberWorkout`. May be used by Relay 1. */
  memberWorkoutEdge?: Maybe<IMemberWorkoutsEdge>;
}

/** The output of our update `MemberWorkout` mutation. */
export interface IUpdateMemberWorkoutPayloadMemberWorkoutEdgeArgs {
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
}

/** All input for the `updateMentorEventById` mutation. */
export interface IUpdateMentorEventByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MentorEvent` being updated. */
  mentorEventPatch: IMentorEventPatch;
  id: Scalars["Int"];
}

/** All input for the `updateMentorEvent` mutation. */
export interface IUpdateMentorEventInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentorEvent` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MentorEvent` being updated. */
  mentorEventPatch: IMentorEventPatch;
}

/** The output of our update `MentorEvent` mutation. */
export interface IUpdateMentorEventPayload {
   __typename?: "UpdateMentorEventPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentorEvent` that was updated by this mutation. */
  mentorEvent?: Maybe<IMentorEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `MentorEvent`. May be used by Relay 1. */
  mentorEventEdge?: Maybe<IMentorEventsEdge>;
}

/** The output of our update `MentorEvent` mutation. */
export interface IUpdateMentorEventPayloadMentorEventEdgeArgs {
  orderBy?: Maybe<IMentorEventsOrderBy[]>;
}

/** All input for the `updateMentoringReportById` mutation. */
export interface IUpdateMentoringReportByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MentoringReport` being updated. */
  mentoringReportPatch: IMentoringReportPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMentoringReportByToken` mutation. */
export interface IUpdateMentoringReportByTokenInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MentoringReport` being updated. */
  mentoringReportPatch: IMentoringReportPatch;
  /** Unique token for member access to report on the member portal */
  token: Scalars["String"];
}

/** All input for the `updateMentoringReport` mutation. */
export interface IUpdateMentoringReportInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentoringReport` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MentoringReport` being updated. */
  mentoringReportPatch: IMentoringReportPatch;
}

/** All input for the `updateMentoringReportMessageById` mutation. */
export interface IUpdateMentoringReportMessageByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `MentoringReportMessage` being updated. */
  mentoringReportMessagePatch: IMentoringReportMessagePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateMentoringReportMessage` mutation. */
export interface IUpdateMentoringReportMessageInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `MentoringReportMessage` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `MentoringReportMessage` being updated. */
  mentoringReportMessagePatch: IMentoringReportMessagePatch;
}

/** The output of our update `MentoringReportMessage` mutation. */
export interface IUpdateMentoringReportMessagePayload {
   __typename?: "UpdateMentoringReportMessagePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReportMessage` that was updated by this mutation. */
  mentoringReportMessage?: Maybe<IMentoringReportMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `MentoringReport` that is related to this `MentoringReportMessage`. */
  mentoringReportByMentoringReportId?: Maybe<IMentoringReport>;
  /** An edge for our `MentoringReportMessage`. May be used by Relay 1. */
  mentoringReportMessageEdge?: Maybe<IMentoringReportMessagesEdge>;
}

/** The output of our update `MentoringReportMessage` mutation. */
export interface IUpdateMentoringReportMessagePayloadMentoringReportMessageEdgeArgs {
  orderBy?: Maybe<IMentoringReportMessagesOrderBy[]>;
}

/** The output of our update `MentoringReport` mutation. */
export interface IUpdateMentoringReportPayload {
   __typename?: "UpdateMentoringReportPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `MentoringReport` that was updated by this mutation. */
  mentoringReport?: Maybe<IMentoringReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Coach` that is related to this `MentoringReport`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads a single `Member` that is related to this `MentoringReport`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MentoringReport`. May be used by Relay 1. */
  mentoringReportEdge?: Maybe<IMentoringReportsEdge>;
}

/** The output of our update `MentoringReport` mutation. */
export interface IUpdateMentoringReportPayloadMentoringReportEdgeArgs {
  orderBy?: Maybe<IMentoringReportsOrderBy[]>;
}

/** All input for the `updateNotificationById` mutation. */
export interface IUpdateNotificationByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Notification` being updated. */
  notificationPatch: INotificationPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateNotification` mutation. */
export interface IUpdateNotificationInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  notificationPatch: INotificationPatch;
}

/** The output of our update `Notification` mutation. */
export interface IUpdateNotificationPayload {
   __typename?: "UpdateNotificationPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<INotification>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<INotificationsEdge>;
}

/** The output of our update `Notification` mutation. */
export interface IUpdateNotificationPayloadNotificationEdgeArgs {
  orderBy?: Maybe<INotificationsOrderBy[]>;
}

/** All input for the `updateNutritionDayById` mutation. */
export interface IUpdateNutritionDayByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionDay` being updated. */
  nutritionDayPatch: INutritionDayPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateNutritionDay` mutation. */
export interface IUpdateNutritionDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDay` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionDay` being updated. */
  nutritionDayPatch: INutritionDayPatch;
}

/** All input for the `updateNutritionDayMealByNutritionDayIdAndMealId` mutation. */
export interface IUpdateNutritionDayMealByNutritionDayIdAndMealIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionDayMeal` being updated. */
  nutritionDayMealPatch: INutritionDayMealPatch;
  nutritionDayId: Scalars["Uuid"];
  mealId: Scalars["Uuid"];
}

/** All input for the `updateNutritionDayMeal` mutation. */
export interface IUpdateNutritionDayMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDayMeal` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionDayMeal` being updated. */
  nutritionDayMealPatch: INutritionDayMealPatch;
}

/** The output of our update `NutritionDayMeal` mutation. */
export interface IUpdateNutritionDayMealPayload {
   __typename?: "UpdateNutritionDayMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDayMeal` that was updated by this mutation. */
  nutritionDayMeal?: Maybe<INutritionDayMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionDayMeal`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `MemberMeal` that is related to this `NutritionDayMeal`. */
  memberMealByMealId?: Maybe<IMemberMeal>;
  /** An edge for our `NutritionDayMeal`. May be used by Relay 1. */
  nutritionDayMealEdge?: Maybe<INutritionDayMealsEdge>;
}

/** The output of our update `NutritionDayMeal` mutation. */
export interface IUpdateNutritionDayMealPayloadNutritionDayMealEdgeArgs {
  orderBy?: Maybe<INutritionDayMealsOrderBy[]>;
}

/** The output of our update `NutritionDay` mutation. */
export interface IUpdateNutritionDayPayload {
   __typename?: "UpdateNutritionDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDay` that was updated by this mutation. */
  nutritionDay?: Maybe<INutritionDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionDay`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionDay`. May be used by Relay 1. */
  nutritionDayEdge?: Maybe<INutritionDaysEdge>;
}

/** The output of our update `NutritionDay` mutation. */
export interface IUpdateNutritionDayPayloadNutritionDayEdgeArgs {
  orderBy?: Maybe<INutritionDaysOrderBy[]>;
}

/** All input for the `updateNutritionDictionaryById` mutation. */
export interface IUpdateNutritionDictionaryByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionDictionary` being updated. */
  nutritionDictionaryPatch: INutritionDictionaryPatch;
  id: Scalars["Int"];
}

/** All input for the `updateNutritionDictionary` mutation. */
export interface IUpdateNutritionDictionaryInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionDictionary` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionDictionary` being updated. */
  nutritionDictionaryPatch: INutritionDictionaryPatch;
}

/** The output of our update `NutritionDictionary` mutation. */
export interface IUpdateNutritionDictionaryPayload {
   __typename?: "UpdateNutritionDictionaryPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionDictionary` that was updated by this mutation. */
  nutritionDictionary?: Maybe<INutritionDictionary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDictionary` that is related to this `NutritionDictionary`. */
  nutritionDictionaryByParentNutritionId?: Maybe<INutritionDictionary>;
  /** An edge for our `NutritionDictionary`. May be used by Relay 1. */
  nutritionDictionaryEdge?: Maybe<INutritionDictionariesEdge>;
}

/** The output of our update `NutritionDictionary` mutation. */
export interface IUpdateNutritionDictionaryPayloadNutritionDictionaryEdgeArgs {
  orderBy?: Maybe<INutritionDictionariesOrderBy[]>;
}

/** All input for the `updateNutritionPlanById` mutation. */
export interface IUpdateNutritionPlanByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionPlan` being updated. */
  nutritionPlanPatch: INutritionPlanPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateNutritionPlanDayByNutritionPlanIdAndNutritionDayId` mutation. */
export interface IUpdateNutritionPlanDayByNutritionPlanIdAndNutritionDayIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionPlanDay` being updated. */
  nutritionPlanDayPatch: INutritionPlanDayPatch;
  nutritionPlanId: Scalars["Uuid"];
  nutritionDayId: Scalars["Uuid"];
}

/** All input for the `updateNutritionPlanDay` mutation. */
export interface IUpdateNutritionPlanDayInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlanDay` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionPlanDay` being updated. */
  nutritionPlanDayPatch: INutritionPlanDayPatch;
}

/** The output of our update `NutritionPlanDay` mutation. */
export interface IUpdateNutritionPlanDayPayload {
   __typename?: "UpdateNutritionPlanDayPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanDay` that was updated by this mutation. */
  nutritionPlanDay?: Maybe<INutritionPlanDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanDay`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanDay`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** An edge for our `NutritionPlanDay`. May be used by Relay 1. */
  nutritionPlanDayEdge?: Maybe<INutritionPlanDaysEdge>;
}

/** The output of our update `NutritionPlanDay` mutation. */
export interface IUpdateNutritionPlanDayPayloadNutritionPlanDayEdgeArgs {
  orderBy?: Maybe<INutritionPlanDaysOrderBy[]>;
}

/** All input for the `updateNutritionPlan` mutation. */
export interface IUpdateNutritionPlanInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlan` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionPlan` being updated. */
  nutritionPlanPatch: INutritionPlanPatch;
}

/** The output of our update `NutritionPlan` mutation. */
export interface IUpdateNutritionPlanPayload {
   __typename?: "UpdateNutritionPlanPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlan` that was updated by this mutation. */
  nutritionPlan?: Maybe<INutritionPlan>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `NutritionPlan`. May be used by Relay 1. */
  nutritionPlanEdge?: Maybe<INutritionPlansEdge>;
}

/** The output of our update `NutritionPlan` mutation. */
export interface IUpdateNutritionPlanPayloadNutritionPlanEdgeArgs {
  orderBy?: Maybe<INutritionPlansOrderBy[]>;
}

/** All input for the `updateNutritionPlanScheduleByNutritionPlanIdAndOrderIndex` mutation. */
export interface IUpdateNutritionPlanScheduleByNutritionPlanIdAndOrderIndexInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionPlanSchedule` being updated. */
  nutritionPlanSchedulePatch: INutritionPlanSchedulePatch;
  nutritionPlanId: Scalars["Uuid"];
  orderIndex: Scalars["Int"];
}

/** All input for the `updateNutritionPlanSchedule` mutation. */
export interface IUpdateNutritionPlanScheduleInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionPlanSchedule` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionPlanSchedule` being updated. */
  nutritionPlanSchedulePatch: INutritionPlanSchedulePatch;
}

/** The output of our update `NutritionPlanSchedule` mutation. */
export interface IUpdateNutritionPlanSchedulePayload {
   __typename?: "UpdateNutritionPlanSchedulePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionPlanSchedule` that was updated by this mutation. */
  nutritionPlanSchedule?: Maybe<INutritionPlanSchedule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionDay` that is related to this `NutritionPlanSchedule`. */
  nutritionDayByNutritionDayId?: Maybe<INutritionDay>;
  /** Reads a single `NutritionPlan` that is related to this `NutritionPlanSchedule`. */
  nutritionPlanByNutritionPlanId?: Maybe<INutritionPlan>;
  /** An edge for our `NutritionPlanSchedule`. May be used by Relay 1. */
  nutritionPlanScheduleEdge?: Maybe<INutritionPlanSchedulesEdge>;
}

/** The output of our update `NutritionPlanSchedule` mutation. */
export interface IUpdateNutritionPlanSchedulePayloadNutritionPlanScheduleEdgeArgs {
  orderBy?: Maybe<INutritionPlanSchedulesOrderBy[]>;
}

/** All input for the `updateNutritionProfileById` mutation. */
export interface IUpdateNutritionProfileByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionProfile` being updated. */
  nutritionProfilePatch: INutritionProfilePatch;
  id: Scalars["Int"];
}

/** All input for the `updateNutritionProfile` mutation. */
export interface IUpdateNutritionProfileInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionProfile` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionProfile` being updated. */
  nutritionProfilePatch: INutritionProfilePatch;
}

/** All input for the `updateNutritionProfileMealById` mutation. */
export interface IUpdateNutritionProfileMealByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `NutritionProfileMeal` being updated. */
  nutritionProfileMealPatch: INutritionProfileMealPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateNutritionProfileMeal` mutation. */
export interface IUpdateNutritionProfileMealInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `NutritionProfileMeal` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `NutritionProfileMeal` being updated. */
  nutritionProfileMealPatch: INutritionProfileMealPatch;
}

/** The output of our update `NutritionProfileMeal` mutation. */
export interface IUpdateNutritionProfileMealPayload {
   __typename?: "UpdateNutritionProfileMealPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfileMeal` that was updated by this mutation. */
  nutritionProfileMeal?: Maybe<INutritionProfileMeal>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `NutritionProfile` that is related to this `NutritionProfileMeal`. */
  nutritionProfileByNutritionProfileId?: Maybe<INutritionProfile>;
  /** An edge for our `NutritionProfileMeal`. May be used by Relay 1. */
  nutritionProfileMealEdge?: Maybe<INutritionProfileMealsEdge>;
}

/** The output of our update `NutritionProfileMeal` mutation. */
export interface IUpdateNutritionProfileMealPayloadNutritionProfileMealEdgeArgs {
  orderBy?: Maybe<INutritionProfileMealsOrderBy[]>;
}

/** The output of our update `NutritionProfile` mutation. */
export interface IUpdateNutritionProfilePayload {
   __typename?: "UpdateNutritionProfilePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `NutritionProfile` that was updated by this mutation. */
  nutritionProfile?: Maybe<INutritionProfile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `NutritionProfile`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `NutritionProfile`. May be used by Relay 1. */
  nutritionProfileEdge?: Maybe<INutritionProfilesEdge>;
}

/** The output of our update `NutritionProfile` mutation. */
export interface IUpdateNutritionProfilePayloadNutritionProfileEdgeArgs {
  orderBy?: Maybe<INutritionProfilesOrderBy[]>;
}

/** All input for the `updateProgramWorkoutByProgramIdAndWorkoutId` mutation. */
export interface IUpdateProgramWorkoutByProgramIdAndWorkoutIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ProgramWorkout` being updated. */
  programWorkoutPatch: IProgramWorkoutPatch;
  programId: Scalars["Int"];
  workoutId: Scalars["Uuid"];
}

/** All input for the `updateProgramWorkout` mutation. */
export interface IUpdateProgramWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ProgramWorkout` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `ProgramWorkout` being updated. */
  programWorkoutPatch: IProgramWorkoutPatch;
}

/** The output of our update `ProgramWorkout` mutation. */
export interface IUpdateProgramWorkoutPayload {
   __typename?: "UpdateProgramWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ProgramWorkout` that was updated by this mutation. */
  programWorkout?: Maybe<IProgramWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `TrainingProgram` that is related to this `ProgramWorkout`. */
  trainingProgramByProgramId?: Maybe<ITrainingProgram>;
  /** Reads a single `Workout` that is related to this `ProgramWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `ProgramWorkout`. May be used by Relay 1. */
  programWorkoutEdge?: Maybe<IProgramWorkoutsEdge>;
}

/** The output of our update `ProgramWorkout` mutation. */
export interface IUpdateProgramWorkoutPayloadProgramWorkoutEdgeArgs {
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
}

export interface IUpdateProgressPictureInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Picture ID */
  pictureId: Scalars["ID"];
  /** Comment */
  comment?: Maybe<Scalars["String"]>;
  /** Is picture private only */
  isPrivate: Scalars["Boolean"];
}

export interface IUpdateProgressPicturePayload {
   __typename?: "UpdateProgressPicturePayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** Generated progress picture */
  picture: IProgressPicture;
}

/** All input for the `updateRecentFoodById` mutation. */
export interface IUpdateRecentFoodByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `RecentFood` being updated. */
  recentFoodPatch: IRecentFoodPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateRecentFood` mutation. */
export interface IUpdateRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `RecentFood` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `RecentFood` being updated. */
  recentFoodPatch: IRecentFoodPatch;
}

/** The output of our update `RecentFood` mutation. */
export interface IUpdateRecentFoodPayload {
   __typename?: "UpdateRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `RecentFood` that was updated by this mutation. */
  recentFood?: Maybe<IRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Food` that is related to this `RecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `RecentFood`. May be used by Relay 1. */
  recentFoodEdge?: Maybe<IRecentFoodsEdge>;
}

/** The output of our update `RecentFood` mutation. */
export interface IUpdateRecentFoodPayloadRecentFoodEdgeArgs {
  orderBy?: Maybe<IRecentFoodsOrderBy[]>;
}

/** All input for the `updateReservationRequestById` mutation. */
export interface IUpdateReservationRequestByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `ReservationRequest` being updated. */
  reservationRequestPatch: IReservationRequestPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateReservationRequest` mutation. */
export interface IUpdateReservationRequestInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `ReservationRequest` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `ReservationRequest` being updated. */
  reservationRequestPatch: IReservationRequestPatch;
}

/** The output of our update `ReservationRequest` mutation. */
export interface IUpdateReservationRequestPayload {
   __typename?: "UpdateReservationRequestPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `ReservationRequest` that was updated by this mutation. */
  reservationRequest?: Maybe<IReservationRequest>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByPrevTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Timeslot` that is related to this `ReservationRequest`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Attendee` that is related to this `ReservationRequest`. */
  attendeeByPersonId?: Maybe<IAttendee>;
  /** An edge for our `ReservationRequest`. May be used by Relay 1. */
  reservationRequestEdge?: Maybe<IReservationRequestsEdge>;
}

/** The output of our update `ReservationRequest` mutation. */
export interface IUpdateReservationRequestPayloadReservationRequestEdgeArgs {
  orderBy?: Maybe<IReservationRequestsOrderBy[]>;
}

/** All input for the `updateServingById` mutation. */
export interface IUpdateServingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Serving` being updated. */
  servingPatch: IServingPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateServing` mutation. */
export interface IUpdateServingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Serving` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Serving` being updated. */
  servingPatch: IServingPatch;
}

/** The output of our update `Serving` mutation. */
export interface IUpdateServingPayload {
   __typename?: "UpdateServingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Serving` that was updated by this mutation. */
  serving?: Maybe<IServing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `FoodbankFood` that is related to this `Serving`. */
  foodbankFoodByFoodId?: Maybe<IFoodbankFood>;
  /** An edge for our `Serving`. May be used by Relay 1. */
  servingEdge?: Maybe<IServingsEdge>;
}

/** The output of our update `Serving` mutation. */
export interface IUpdateServingPayloadServingEdgeArgs {
  orderBy?: Maybe<IServingsOrderBy[]>;
}

/** All input for the `updateSessionById` mutation. */
export interface IUpdateSessionByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Session` being updated. */
  sessionPatch: ISessionPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateSession` mutation. */
export interface IUpdateSessionInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Session` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Session` being updated. */
  sessionPatch: ISessionPatch;
}

/** All input for the `updateSessionInstructorBySessionIdAndInstructorId` mutation. */
export interface IUpdateSessionInstructorBySessionIdAndInstructorIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `SessionInstructor` being updated. */
  sessionInstructorPatch: ISessionInstructorPatch;
  sessionId: Scalars["Uuid"];
  instructorId: Scalars["Uuid"];
}

/** All input for the `updateSessionInstructor` mutation. */
export interface IUpdateSessionInstructorInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `SessionInstructor` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `SessionInstructor` being updated. */
  sessionInstructorPatch: ISessionInstructorPatch;
}

/** The output of our update `SessionInstructor` mutation. */
export interface IUpdateSessionInstructorPayload {
   __typename?: "UpdateSessionInstructorPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `SessionInstructor` that was updated by this mutation. */
  sessionInstructor?: Maybe<ISessionInstructor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Session` that is related to this `SessionInstructor`. */
  sessionBySessionId?: Maybe<ISession>;
  /** Reads a single `Instructor` that is related to this `SessionInstructor`. */
  instructorByInstructorId?: Maybe<IInstructor>;
  /** An edge for our `SessionInstructor`. May be used by Relay 1. */
  sessionInstructorEdge?: Maybe<ISessionInstructorsEdge>;
}

/** The output of our update `SessionInstructor` mutation. */
export interface IUpdateSessionInstructorPayloadSessionInstructorEdgeArgs {
  orderBy?: Maybe<ISessionInstructorsOrderBy[]>;
}

/** The output of our update `Session` mutation. */
export interface IUpdateSessionPayload {
   __typename?: "UpdateSessionPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Session` that was updated by this mutation. */
  session?: Maybe<ISession>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Timeslot` that is related to this `Session`. */
  timeslotByTimeslotId?: Maybe<ITimeslot>;
  /** Reads a single `Club` that is related to this `Session`. */
  clubByClubId?: Maybe<IClub>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<ISessionsEdge>;
}

/** The output of our update `Session` mutation. */
export interface IUpdateSessionPayloadSessionEdgeArgs {
  orderBy?: Maybe<ISessionsOrderBy[]>;
}

/** All input for the `updateSettingById` mutation. */
export interface IUpdateSettingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: ISettingPatch;
  id: Scalars["Int"];
}

/** All input for the `updateSettingByKey` mutation. */
export interface IUpdateSettingByKeyInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: ISettingPatch;
  key: Scalars["String"];
}

/** All input for the `updateSetting` mutation. */
export interface IUpdateSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: ISettingPatch;
}

/** The output of our update `Setting` mutation. */
export interface IUpdateSettingPayload {
   __typename?: "UpdateSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<ISetting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<ISettingsEdge>;
}

/** The output of our update `Setting` mutation. */
export interface IUpdateSettingPayloadSettingEdgeArgs {
  orderBy?: Maybe<ISettingsOrderBy[]>;
}

export interface IUpdateStepsInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** set of dates to update */
  steps: IUpdateStepsSetInput[];
}

export interface IUpdateStepsPayload {
   __typename?: "UpdateStepsPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** All updated steps values */
  steps: IUserMetricsConnection;
}

export interface IUpdateStepsSetInput {
  date: Scalars["NaiveDate"];
  stepsCount: Scalars["Int"];
}

/** All input for the `updateTagById` mutation. */
export interface IUpdateTagByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: ITagPatch;
  id: Scalars["Int"];
}

/** All input for the `updateTag` mutation. */
export interface IUpdateTagInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: ITagPatch;
}

/** The output of our update `Tag` mutation. */
export interface IUpdateTagPayload {
   __typename?: "UpdateTagPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Tag` that was updated by this mutation. */
  tag?: Maybe<ITag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<ITagsEdge>;
}

/** The output of our update `Tag` mutation. */
export interface IUpdateTagPayloadTagEdgeArgs {
  orderBy?: Maybe<ITagsOrderBy[]>;
}

/** All input for the `updateTimeslotById` mutation. */
export interface IUpdateTimeslotByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `Timeslot` being updated. */
  timeslotPatch: ITimeslotPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateTimeslot` mutation. */
export interface IUpdateTimeslotInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `Timeslot` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `Timeslot` being updated. */
  timeslotPatch: ITimeslotPatch;
}

/** The output of our update `Timeslot` mutation. */
export interface IUpdateTimeslotPayload {
   __typename?: "UpdateTimeslotPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `Timeslot` that was updated by this mutation. */
  timeslot?: Maybe<ITimeslot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Class` that is related to this `Timeslot`. */
  classByClassId?: Maybe<IClass>;
  /** An edge for our `Timeslot`. May be used by Relay 1. */
  timeslotEdge?: Maybe<ITimeslotsEdge>;
}

/** The output of our update `Timeslot` mutation. */
export interface IUpdateTimeslotPayloadTimeslotEdgeArgs {
  orderBy?: Maybe<ITimeslotsOrderBy[]>;
}

export interface IUpdateTrainingPlanSharingInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  sharingId: Scalars["ID"];
  accessLevel: ISharingAccessLevel;
}

export interface IUpdateTrainingPlanSharingPayload {
   __typename?: "UpdateTrainingPlanSharingPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated sharing */
  sharing: ISharing;
}

export interface IUpdateTrainingProgramByIdInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of training program to be updated */
  id: Scalars["Int"];
  /** Patch object with changes */
  trainingProgramPatch: ITrainingProgramPatch;
}

export interface IUpdateTrainingProgramByIdPayload {
   __typename?: "UpdateTrainingProgramByIdPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated training program */
  trainingProgram: IOldTrainingProgram;
}

/** All input for the `updateUserSettingById` mutation. */
export interface IUpdateUserSettingByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `UserSetting` being updated. */
  userSettingPatch: IUserSettingPatch;
  id: Scalars["Int"];
}

/** All input for the `updateUserSetting` mutation. */
export interface IUpdateUserSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `UserSetting` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `UserSetting` being updated. */
  userSettingPatch: IUserSettingPatch;
}

/** The output of our update `UserSetting` mutation. */
export interface IUpdateUserSettingPayload {
   __typename?: "UpdateUserSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `UserSetting` that was updated by this mutation. */
  userSetting?: Maybe<IUserSetting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  settingBySettingId?: Maybe<ISetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<IUserSettingsEdge>;
}

/** The output of our update `UserSetting` mutation. */
export interface IUpdateUserSettingPayloadUserSettingEdgeArgs {
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
}

export interface IUpdateWorkoutByIdInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  id: Scalars["Uuid"];
  workoutPatch: IWorkoutPatch;
}

export interface IUpdateWorkoutByIdPayload {
   __typename?: "UpdateWorkoutByIdPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  workout: IOldWorkout;
}

/** All input for the `updateWorkoutExerciseByIdAndWorkoutIdAndExerciseId` mutation. */
export interface IUpdateWorkoutExerciseByIdAndWorkoutIdAndExerciseIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `WorkoutExercise` being updated. */
  workoutExercisePatch: IWorkoutExercisePatch;
  id: Scalars["Uuid"];
  workoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
}

/** All input for the `updateWorkoutExercise` mutation. */
export interface IUpdateWorkoutExerciseInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutExercise` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `WorkoutExercise` being updated. */
  workoutExercisePatch: IWorkoutExercisePatch;
}

/** The output of our update `WorkoutExercise` mutation. */
export interface IUpdateWorkoutExercisePayload {
   __typename?: "UpdateWorkoutExercisePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutExercise` that was updated by this mutation. */
  workoutExercise?: Maybe<IWorkoutExercise>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutExercise`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExercise`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** An edge for our `WorkoutExercise`. May be used by Relay 1. */
  workoutExerciseEdge?: Maybe<IWorkoutExercisesEdge>;
}

/** The output of our update `WorkoutExercise` mutation. */
export interface IUpdateWorkoutExercisePayloadWorkoutExerciseEdgeArgs {
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
}

/** All input for the `updateWorkoutNodeById` mutation. */
export interface IUpdateWorkoutNodeByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `WorkoutNode` being updated. */
  workoutNodePatch: IWorkoutNodePatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateWorkoutNodeEventById` mutation. */
export interface IUpdateWorkoutNodeEventByIdInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** An object where the defined keys will be set on the `WorkoutNodeEvent` being updated. */
  workoutNodeEventPatch: IWorkoutNodeEventPatch;
  id: Scalars["Uuid"];
}

/** All input for the `updateWorkoutNodeEvent` mutation. */
export interface IUpdateWorkoutNodeEventInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutNodeEvent` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `WorkoutNodeEvent` being updated. */
  workoutNodeEventPatch: IWorkoutNodeEventPatch;
}

/** The output of our update `WorkoutNodeEvent` mutation. */
export interface IUpdateWorkoutNodeEventPayload {
   __typename?: "UpdateWorkoutNodeEventPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNodeEvent` that was updated by this mutation. */
  workoutNodeEvent?: Maybe<IWorkoutNodeEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutNodeEvent`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Coach` that is related to this `WorkoutNodeEvent`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `WorkoutNodeEvent`. May be used by Relay 1. */
  workoutNodeEventEdge?: Maybe<IWorkoutNodeEventsEdge>;
}

/** The output of our update `WorkoutNodeEvent` mutation. */
export interface IUpdateWorkoutNodeEventPayloadWorkoutNodeEventEdgeArgs {
  orderBy?: Maybe<IWorkoutNodeEventsOrderBy[]>;
}

/** All input for the `updateWorkoutNode` mutation. */
export interface IUpdateWorkoutNodeInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The globally unique `ID` which will identify a single `WorkoutNode` to be updated. */
  nodeId: Scalars["ID"];
  /** An object where the defined keys will be set on the `WorkoutNode` being updated. */
  workoutNodePatch: IWorkoutNodePatch;
}

/** The output of our update `WorkoutNode` mutation. */
export interface IUpdateWorkoutNodePayload {
   __typename?: "UpdateWorkoutNodePayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** The `WorkoutNode` that was updated by this mutation. */
  workoutNode?: Maybe<IWorkoutNode>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `WorkoutNode` that is related to this `WorkoutNode`. */
  workoutNodeByParentId?: Maybe<IWorkoutNode>;
  /** Reads a single `Workout` that is related to this `WorkoutNode`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutNode`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `WorkoutNode`. */
  coachByCoachId?: Maybe<ICoach>;
  /** An edge for our `WorkoutNode`. May be used by Relay 1. */
  workoutNodeEdge?: Maybe<IWorkoutNodesEdge>;
}

/** The output of our update `WorkoutNode` mutation. */
export interface IUpdateWorkoutNodePayloadWorkoutNodeEdgeArgs {
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
}

export interface IUpdateWorkoutTemplateDirectoryInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** ID of directory to update */
  dirId: Scalars["ID"];
  /** object with changes */
  values: IWorkoutTemplateDirectoryPatch;
}

export interface IUpdateWorkoutTemplateDirectoryPayload {
   __typename?: "UpdateWorkoutTemplateDirectoryPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** updated workout template directory */
  workoutTemplateDirectory: IWorkoutTemplateDirectory;
}

export interface IUpdateWorkoutTemplateSharingInput {
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  sharingId: Scalars["ID"];
  accessLevel: ISharingAccessLevel;
}

export interface IUpdateWorkoutTemplateSharingPayload {
   __typename?: "UpdateWorkoutTemplateSharingPayload";
  /** client sync id */
  clientMutationId?: Maybe<Scalars["ID"]>;
  /** created sharing */
  sharing: ISharing;
}

/** All input for the `upsertDeviceMeta` mutation. */
export interface IUpsertDeviceMetaInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  deviceId?: Maybe<Scalars["String"]>;
  platform?: Maybe<Scalars["String"]>;
  version?: Maybe<Scalars["String"]>;
  timezone?: Maybe<Scalars["String"]>;
  permissions?: Maybe<Scalars["Json"]>;
  loggedIn?: Maybe<Scalars["Boolean"]>;
}

/** The output of our `upsertDeviceMeta` mutation. */
export interface IUpsertDeviceMetaPayload {
   __typename?: "UpsertDeviceMetaPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  upsertDeviceMetaResult?: Maybe<IUpsertDeviceMetaResult>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

export enum IUpsertDeviceMetaResult {
  MemberNotFound = "MEMBER_NOT_FOUND",
  Ok = "OK",
}

/** All input for the `upsertFood` mutation. */
export interface IUpsertFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id: Scalars["Uuid"];
  food: Scalars["Json"];
}

/** The output of our `upsertFood` mutation. */
export interface IUpsertFoodPayload {
   __typename?: "UpsertFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  food?: Maybe<IFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `Food`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `Food`. May be used by Relay 1. */
  foodEdge?: Maybe<IFoodsEdge>;
}

/** The output of our `upsertFood` mutation. */
export interface IUpsertFoodPayloadFoodEdgeArgs {
  orderBy?: Maybe<IFoodsOrderBy[]>;
}

/** All input for the `upsertMemberMetric` mutation. */
export interface IUpsertMemberMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  key?: Maybe<IMetricKey>;
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Float"]>;
  parts?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `upsertMemberMetric` mutation. */
export interface IUpsertMemberMetricPayload {
   __typename?: "UpsertMemberMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
}

/** All input for the `upsertMemberMetricV2` mutation. */
export interface IUpsertMemberMetricV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  key?: Maybe<IMetricKey>;
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Float"]>;
  parts?: Maybe<Scalars["Json"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** The output of our `upsertMemberMetricV2` mutation. */
export interface IUpsertMemberMetricV2Payload {
   __typename?: "UpsertMemberMetricV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberMetric?: Maybe<IMemberMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberMetric`. May be used by Relay 1. */
  memberMetricEdge?: Maybe<IMemberMetricsEdge>;
}

/** The output of our `upsertMemberMetricV2` mutation. */
export interface IUpsertMemberMetricV2PayloadMemberMetricEdgeArgs {
  orderBy?: Maybe<IMemberMetricsOrderBy[]>;
}

/** All input for the `upsertMemberNutritionMetric` mutation. */
export interface IUpsertMemberNutritionMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  body?: Maybe<Scalars["Json"]>;
  profileBody?: Maybe<Scalars["Json"]>;
}

/** The output of our `upsertMemberNutritionMetric` mutation. */
export interface IUpsertMemberNutritionMetricPayload {
   __typename?: "UpsertMemberNutritionMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberNutritionMetric?: Maybe<IMemberNutritionMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberNutritionMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberNutritionMetric`. May be used by Relay 1. */
  memberNutritionMetricEdge?: Maybe<IMemberNutritionMetricsEdge>;
}

/** The output of our `upsertMemberNutritionMetric` mutation. */
export interface IUpsertMemberNutritionMetricPayloadMemberNutritionMetricEdgeArgs {
  orderBy?: Maybe<IMemberNutritionMetricsOrderBy[]>;
}

/** All input for the `upsertMemberRecentFood` mutation. */
export interface IUpsertMemberRecentFoodInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  id?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
  addedAt?: Maybe<Scalars["Datetime"]>;
  label?: Maybe<Scalars["String"]>;
  entry?: Maybe<Scalars["Json"]>;
  fatSecretId?: Maybe<Scalars["Int"]>;
  macroEntryId?: Maybe<IMacroEntryIdInput>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `upsertMemberRecentFood` mutation. */
export interface IUpsertMemberRecentFoodPayload {
   __typename?: "UpsertMemberRecentFoodPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberRecentFood?: Maybe<IMemberRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MemberRecentFood`. May be used by Relay 1. */
  memberRecentFoodEdge?: Maybe<IMemberRecentFoodsEdge>;
}

/** The output of our `upsertMemberRecentFood` mutation. */
export interface IUpsertMemberRecentFoodPayloadMemberRecentFoodEdgeArgs {
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
}

/** All input for the `upsertMemberRecentFoodV2` mutation. */
export interface IUpsertMemberRecentFoodV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  label?: Maybe<Scalars["String"]>;
  entry?: Maybe<Scalars["Json"]>;
  macroEntryId?: Maybe<IMacroEntryIdInput>;
  fatSecretId?: Maybe<Scalars["Int"]>;
  foodId?: Maybe<Scalars["Uuid"]>;
  myFoodId?: Maybe<Scalars["Uuid"]>;
  memberId?: Maybe<Scalars["Int"]>;
}

/** The output of our `upsertMemberRecentFoodV2` mutation. */
export interface IUpsertMemberRecentFoodV2Payload {
   __typename?: "UpsertMemberRecentFoodV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberRecentFood?: Maybe<IMemberRecentFood>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberRecentFood`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Food` that is related to this `MemberRecentFood`. */
  foodByFoodId?: Maybe<IFood>;
  /** An edge for our `MemberRecentFood`. May be used by Relay 1. */
  memberRecentFoodEdge?: Maybe<IMemberRecentFoodsEdge>;
}

/** The output of our `upsertMemberRecentFoodV2` mutation. */
export interface IUpsertMemberRecentFoodV2PayloadMemberRecentFoodEdgeArgs {
  orderBy?: Maybe<IMemberRecentFoodsOrderBy[]>;
}

/** All input for the `upsertMemberWaterMetric` mutation. */
export interface IUpsertMemberWaterMetricInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  value?: Maybe<Scalars["Int"]>;
}

/** The output of our `upsertMemberWaterMetric` mutation. */
export interface IUpsertMemberWaterMetricPayload {
   __typename?: "UpsertMemberWaterMetricPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberWaterMetric?: Maybe<IMemberWaterMetric>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWaterMetric`. */
  memberByMemberId?: Maybe<IMember>;
  /** An edge for our `MemberWaterMetric`. May be used by Relay 1. */
  memberWaterMetricEdge?: Maybe<IMemberWaterMetricsEdge>;
}

/** The output of our `upsertMemberWaterMetric` mutation. */
export interface IUpsertMemberWaterMetricPayloadMemberWaterMetricEdgeArgs {
  orderBy?: Maybe<IMemberWaterMetricsOrderBy[]>;
}

/** All input for the `upsertMemberWorkout` mutation. */
export interface IUpsertMemberWorkoutInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  workoutBody?: Maybe<Scalars["Json"]>;
  configBody?: Maybe<Scalars["Json"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `upsertMemberWorkout` mutation. */
export interface IUpsertMemberWorkoutPayload {
   __typename?: "UpsertMemberWorkoutPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberWorkout?: Maybe<IMemberWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `MemberWorkout`. May be used by Relay 1. */
  memberWorkoutEdge?: Maybe<IMemberWorkoutsEdge>;
}

/** The output of our `upsertMemberWorkout` mutation. */
export interface IUpsertMemberWorkoutPayloadMemberWorkoutEdgeArgs {
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
}

/** All input for the `upsertMemberWorkoutV2` mutation. */
export interface IUpsertMemberWorkoutV2Input {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  workoutBody?: Maybe<Scalars["Json"]>;
  configBody?: Maybe<Scalars["Json"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  id?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `upsertMemberWorkoutV2` mutation. */
export interface IUpsertMemberWorkoutV2Payload {
   __typename?: "UpsertMemberWorkoutV2Payload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  memberWorkout?: Maybe<IMemberWorkout>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Member` that is related to this `MemberWorkout`. */
  memberByMemberId?: Maybe<IMember>;
  /** Reads a single `Workout` that is related to this `MemberWorkout`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** An edge for our `MemberWorkout`. May be used by Relay 1. */
  memberWorkoutEdge?: Maybe<IMemberWorkoutsEdge>;
}

/** The output of our `upsertMemberWorkoutV2` mutation. */
export interface IUpsertMemberWorkoutV2PayloadMemberWorkoutEdgeArgs {
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
}

/** All input for the `upsertUserSetting` mutation. */
export interface IUpsertUserSettingInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  key?: Maybe<Scalars["String"]>;
  value?: Maybe<Scalars["String"]>;
  userId?: Maybe<Scalars["Uuid"]>;
}

/** The output of our `upsertUserSetting` mutation. */
export interface IUpsertUserSettingPayload {
   __typename?: "UpsertUserSettingPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  userSetting?: Maybe<IUserSetting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  settingBySettingId?: Maybe<ISetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<IUserSettingsEdge>;
}

/** The output of our `upsertUserSetting` mutation. */
export interface IUpsertUserSettingPayloadUserSettingEdgeArgs {
  orderBy?: Maybe<IUserSettingsOrderBy[]>;
}

/** All input for the `upsertWorkoutExercises` mutation. */
export interface IUpsertWorkoutExercisesInput {
  /**
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  recordsetPayload?: Maybe<Scalars["Json"]>;
}

/** The output of our `upsertWorkoutExercises` mutation. */
export interface IUpsertWorkoutExercisesPayload {
   __typename?: "UpsertWorkoutExercisesPayload";
  /**
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 **/
  clientMutationId?: Maybe<Scalars["String"]>;
  workoutExercises?: Maybe<Array<Maybe<IWorkoutExercise>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<IQuery>;
  /** Reads a single `Workout` that is related to this `WorkoutExercise`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExercise`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** An edge for our `WorkoutExercise`. May be used by Relay 1. */
  workoutExerciseEdge?: Maybe<IWorkoutExercisesEdge>;
}

/** The output of our `upsertWorkoutExercises` mutation. */
export interface IUpsertWorkoutExercisesPayloadWorkoutExerciseEdgeArgs {
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
}

export interface IUser {
   __typename?: "User";
  id: Scalars["ID"];
  firstName: Scalars["String"];
  lastName: Scalars["String"];
  fullName: Scalars["String"];
}

export interface IUserFeature {
   __typename?: "UserFeature";
  userId: Scalars["Uuid"];
  featureId: Scalars["Uuid"];
  addedBy?: Maybe<Scalars["Uuid"]>;
  comment?: Maybe<Scalars["String"]>;
  createdAt: Scalars["Datetime"];
}

export interface IUserMetric {
   __typename?: "UserMetric";
  id: Scalars["ID"];
  memberId: Scalars["ID"];
  date: Scalars["NaiveDate"];
  key: IMetricKey;
  value: Scalars["Float"];
}

export interface IUserMetricDay {
   __typename?: "UserMetricDay";
  date: Scalars["NaiveDate"];
  bodyWeight?: Maybe<Scalars["Float"]>;
  bodyFatPercentage?: Maybe<Scalars["Float"]>;
  bodyFatMass?: Maybe<Scalars["Float"]>;
  skeletalMuscleMass?: Maybe<Scalars["Float"]>;
  skinFolds?: Maybe<ISkinFolds>;
  circumference?: Maybe<IBodyCircumference>;
  sleepHours?: Maybe<Scalars["Float"]>;
  bloodPressure?: Maybe<IBloodPressure>;
  menstrualDay?: Maybe<Scalars["Boolean"]>;
  heartRate?: Maybe<Scalars["Int"]>;
  heartRateVar?: Maybe<Scalars["Int"]>;
  bodyTemp?: Maybe<Scalars["Float"]>;
}

export interface IUserMetricsConnection {
   __typename?: "UserMetricsConnection";
  /** List of available metrics */
  nodes: IUserMetric[];
  /** Total number of metrics */
  totalCount: Scalars["Int"];
}

export interface IUserSetting  extends INode {
   __typename?: "UserSetting";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Int"];
  settingId: Scalars["Int"];
  userId?: Maybe<Scalars["Int"]>;
  value: Scalars["String"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  ksUserId?: Maybe<Scalars["String"]>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  settingBySettingId?: Maybe<ISetting>;
}

/**
 * A condition to be used against `UserSetting` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IUserSettingCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `settingId` field. */
  settingId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksUserId` field. */
  ksUserId?: Maybe<Scalars["String"]>;
}

/** An input for mutations affecting `UserSetting` */
export interface IUserSettingInput {
  id?: Maybe<Scalars["Int"]>;
  settingId: Scalars["Int"];
  userId?: Maybe<Scalars["Int"]>;
  value: Scalars["String"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `UserSetting`. Fields that are set will be updated. */
export interface IUserSettingPatch {
  id?: Maybe<Scalars["Int"]>;
  settingId?: Maybe<Scalars["Int"]>;
  userId?: Maybe<Scalars["Int"]>;
  value?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksUserId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `UserSetting` values. */
export interface IUserSettingsConnection {
   __typename?: "UserSettingsConnection";
  /** A list of `UserSetting` objects. */
  nodes: Array<Maybe<IUserSetting>>;
  /** A list of edges which contains the `UserSetting` and cursor to aid in pagination. */
  edges: IUserSettingsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `UserSetting` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `UserSetting` edge in the connection. */
export interface IUserSettingsEdge {
   __typename?: "UserSettingsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `UserSetting` at the end of the edge. */
  node?: Maybe<IUserSetting>;
}

/** Methods to use when ordering `UserSetting`. */
export enum IUserSettingsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  SettingIdAsc = "SETTING_ID_ASC",
  SettingIdDesc = "SETTING_ID_DESC",
  UserIdAsc = "USER_ID_ASC",
  UserIdDesc = "USER_ID_DESC",
  ValueAsc = "VALUE_ASC",
  ValueDesc = "VALUE_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  KsUserIdAsc = "KS_USER_ID_ASC",
  KsUserIdDesc = "KS_USER_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IWeekday {
  Monday = "MONDAY",
  Tuesday = "TUESDAY",
  Wednesday = "WEDNESDAY",
  Thursday = "THURSDAY",
  Friday = "FRIDAY",
  Saturday = "SATURDAY",
  Sunday = "SUNDAY",
}

export interface IWeeklyCaloricIntake {
   __typename?: "WeeklyCaloricIntake";
  memberId?: Maybe<Scalars["Int"]>;
  date?: Maybe<Scalars["Date"]>;
  weeklyCals?: Maybe<Scalars["String"]>;
}

/**
 * A condition to be used against `WeeklyCaloricIntake` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IWeeklyCaloricIntakeCondition {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `weeklyCals` field. */
  weeklyCals?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `WeeklyCaloricIntake` values. */
export interface IWeeklyCaloricIntakesConnection {
   __typename?: "WeeklyCaloricIntakesConnection";
  /** A list of `WeeklyCaloricIntake` objects. */
  nodes: Array<Maybe<IWeeklyCaloricIntake>>;
  /** A list of edges which contains the `WeeklyCaloricIntake` and cursor to aid in pagination. */
  edges: IWeeklyCaloricIntakesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `WeeklyCaloricIntake` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `WeeklyCaloricIntake` edge in the connection. */
export interface IWeeklyCaloricIntakesEdge {
   __typename?: "WeeklyCaloricIntakesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `WeeklyCaloricIntake` at the end of the edge. */
  node?: Maybe<IWeeklyCaloricIntake>;
}

/** Methods to use when ordering `WeeklyCaloricIntake`. */
export enum IWeeklyCaloricIntakesOrderBy {
  Natural = "NATURAL",
  MemberIdAsc = "MEMBER_ID_ASC",
  MemberIdDesc = "MEMBER_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  WeeklyCalsAsc = "WEEKLY_CALS_ASC",
  WeeklyCalsDesc = "WEEKLY_CALS_DESC",
}

export interface IWeeklyTrainingStat {
   __typename?: "WeeklyTrainingStat";
  steps: Scalars["Int"];
  volume: Scalars["Float"];
  distance: Scalars["Float"];
  calories: Scalars["Float"];
}

export interface IWorkout  extends INode {
   __typename?: "Workout";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  name: Scalars["String"];
  body: Scalars["Json"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  duration?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  isArchived: Scalars["Boolean"];
  v3CompilationStatus?: Maybe<Scalars["Boolean"]>;
  /** Reads and enables pagination through a set of `MemberWorkout`. */
  memberWorkoutsByWorkoutId: IMemberWorkoutsConnection;
  /** Reads and enables pagination through a set of `ProgramWorkout`. */
  programWorkoutsByWorkoutId: IProgramWorkoutsConnection;
  /** Reads and enables pagination through a set of `WorkoutExercise`. */
  workoutExercisesByWorkoutId: IWorkoutExercisesConnection;
  /** Reads and enables pagination through a set of `WorkoutNode`. */
  workoutNodesByWorkoutId: IWorkoutNodesConnection;
  /** Reads and enables pagination through a set of `WorkoutNodeEvent`. */
  workoutNodeEventsByWorkoutId: IWorkoutNodeEventsConnection;
}

export interface IWorkoutMemberWorkoutsByWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IMemberWorkoutsOrderBy[]>;
  condition?: Maybe<IMemberWorkoutCondition>;
}

export interface IWorkoutProgramWorkoutsByWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IProgramWorkoutsOrderBy[]>;
  condition?: Maybe<IProgramWorkoutCondition>;
}

export interface IWorkoutWorkoutExercisesByWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutExercisesOrderBy[]>;
  condition?: Maybe<IWorkoutExerciseCondition>;
}

export interface IWorkoutWorkoutNodesByWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
  condition?: Maybe<IWorkoutNodeCondition>;
}

export interface IWorkoutWorkoutNodeEventsByWorkoutIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodeEventsOrderBy[]>;
  condition?: Maybe<IWorkoutNodeEventCondition>;
}

/** A condition to be used against `Workout` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface IWorkoutCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars["String"]>;
  /** Checks for equality with the object’s `isArchived` field. */
  isArchived?: Maybe<Scalars["Boolean"]>;
  /** Checks for equality with the object’s `v3CompilationStatus` field. */
  v3CompilationStatus?: Maybe<Scalars["Boolean"]>;
}

export interface IWorkoutExercise  extends INode {
   __typename?: "WorkoutExercise";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  workoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
  configBody: Scalars["Json"];
  group: Scalars["Int"];
  sortOrder: Scalars["Int"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  /** Reads a single `Workout` that is related to this `WorkoutExercise`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExercise`. */
  exerciseByExerciseId?: Maybe<IExercise>;
}

export interface IWorkoutExerciseAttempt {
   __typename?: "WorkoutExerciseAttempt";
  memberWorkoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
  date: Scalars["Date"];
  weight?: Maybe<Scalars["Float"]>;
  reps?: Maybe<Scalars["Int"]>;
  setIndex: Scalars["Int"];
  /** Reads a single `MemberWorkout` that is related to this `WorkoutExerciseAttempt`. */
  memberWorkoutByMemberWorkoutId?: Maybe<IMemberWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutExerciseAttempt`. */
  exerciseByExerciseId?: Maybe<IExercise>;
}

/**
 * A condition to be used against `WorkoutExerciseAttempt` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 **/
export interface IWorkoutExerciseAttemptCondition {
  /** Checks for equality with the object’s `memberWorkoutId` field. */
  memberWorkoutId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `exerciseId` field. */
  exerciseId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars["Date"]>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars["Float"]>;
  /** Checks for equality with the object’s `reps` field. */
  reps?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `setIndex` field. */
  setIndex?: Maybe<Scalars["Int"]>;
}

/** An input for mutations affecting `WorkoutExerciseAttempt` */
export interface IWorkoutExerciseAttemptInput {
  memberWorkoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
  date: Scalars["Date"];
  weight?: Maybe<Scalars["Float"]>;
  reps?: Maybe<Scalars["Int"]>;
  setIndex?: Maybe<Scalars["Int"]>;
}

/** A connection to a list of `WorkoutExerciseAttempt` values. */
export interface IWorkoutExerciseAttemptsConnection {
   __typename?: "WorkoutExerciseAttemptsConnection";
  /** A list of `WorkoutExerciseAttempt` objects. */
  nodes: Array<Maybe<IWorkoutExerciseAttempt>>;
  /** A list of edges which contains the `WorkoutExerciseAttempt` and cursor to aid in pagination. */
  edges: IWorkoutExerciseAttemptsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `WorkoutExerciseAttempt` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `WorkoutExerciseAttempt` edge in the connection. */
export interface IWorkoutExerciseAttemptsEdge {
   __typename?: "WorkoutExerciseAttemptsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `WorkoutExerciseAttempt` at the end of the edge. */
  node?: Maybe<IWorkoutExerciseAttempt>;
}

/** Methods to use when ordering `WorkoutExerciseAttempt`. */
export enum IWorkoutExerciseAttemptsOrderBy {
  Natural = "NATURAL",
  MemberWorkoutIdAsc = "MEMBER_WORKOUT_ID_ASC",
  MemberWorkoutIdDesc = "MEMBER_WORKOUT_ID_DESC",
  ExerciseIdAsc = "EXERCISE_ID_ASC",
  ExerciseIdDesc = "EXERCISE_ID_DESC",
  DateAsc = "DATE_ASC",
  DateDesc = "DATE_DESC",
  WeightAsc = "WEIGHT_ASC",
  WeightDesc = "WEIGHT_DESC",
  RepsAsc = "REPS_ASC",
  RepsDesc = "REPS_DESC",
  SetIndexAsc = "SET_INDEX_ASC",
  SetIndexDesc = "SET_INDEX_DESC",
}

/**
 * A condition to be used against `WorkoutExercise` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IWorkoutExerciseCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `workoutId` field. */
  workoutId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `exerciseId` field. */
  exerciseId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `configBody` field. */
  configBody?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `group` field. */
  group?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** An input for mutations affecting `WorkoutExercise` */
export interface IWorkoutExerciseInput {
  id?: Maybe<Scalars["Uuid"]>;
  workoutId: Scalars["Uuid"];
  exerciseId: Scalars["Uuid"];
  configBody: Scalars["Json"];
  group: Scalars["Int"];
  sortOrder: Scalars["Int"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** Represents an update to a `WorkoutExercise`. Fields that are set will be updated. */
export interface IWorkoutExercisePatch {
  id?: Maybe<Scalars["Uuid"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  exerciseId?: Maybe<Scalars["Uuid"]>;
  configBody?: Maybe<Scalars["Json"]>;
  group?: Maybe<Scalars["Int"]>;
  sortOrder?: Maybe<Scalars["Int"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
}

/** A connection to a list of `WorkoutExercise` values. */
export interface IWorkoutExercisesConnection {
   __typename?: "WorkoutExercisesConnection";
  /** A list of `WorkoutExercise` objects. */
  nodes: Array<Maybe<IWorkoutExercise>>;
  /** A list of edges which contains the `WorkoutExercise` and cursor to aid in pagination. */
  edges: IWorkoutExercisesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `WorkoutExercise` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `WorkoutExercise` edge in the connection. */
export interface IWorkoutExercisesEdge {
   __typename?: "WorkoutExercisesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `WorkoutExercise` at the end of the edge. */
  node?: Maybe<IWorkoutExercise>;
}

/** Methods to use when ordering `WorkoutExercise`. */
export enum IWorkoutExercisesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  WorkoutIdAsc = "WORKOUT_ID_ASC",
  WorkoutIdDesc = "WORKOUT_ID_DESC",
  ExerciseIdAsc = "EXERCISE_ID_ASC",
  ExerciseIdDesc = "EXERCISE_ID_DESC",
  ConfigBodyAsc = "CONFIG_BODY_ASC",
  ConfigBodyDesc = "CONFIG_BODY_DESC",
  GroupAsc = "GROUP_ASC",
  GroupDesc = "GROUP_DESC",
  SortOrderAsc = "SORT_ORDER_ASC",
  SortOrderDesc = "SORT_ORDER_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

/** An input for mutations affecting `Workout` */
export interface IWorkoutInput {
  id?: Maybe<Scalars["Uuid"]>;
  name: Scalars["String"];
  body: Scalars["Json"];
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  duration?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
  isArchived?: Maybe<Scalars["Boolean"]>;
  v3CompilationStatus?: Maybe<Scalars["Boolean"]>;
}

export interface IWorkoutMeta {
   __typename?: "WorkoutMeta";
  workoutId: Scalars["ID"];
  date: Scalars["NaiveDate"];
  userId: Scalars["ID"];
  volume?: Maybe<Scalars["Float"]>;
  calories?: Maybe<Scalars["Int"]>;
  distance?: Maybe<Scalars["Int"]>;
  performance?: Maybe<Scalars["Int"]>;
  difficulty?: Maybe<Scalars["Int"]>;
  notes?: Maybe<Scalars["String"]>;
}

export interface IWorkoutMetaConnection {
   __typename?: "WorkoutMetaConnection";
  /** List of available workout sessions */
  nodes: IWorkoutMeta[];
  /** Total number of available workout sessions */
  totalCount: Scalars["Int"];
}

export interface IWorkoutNode  extends INode {
   __typename?: "WorkoutNode";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  parentId?: Maybe<Scalars["Uuid"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  exerciseId?: Maybe<Scalars["Uuid"]>;
  meta: Scalars["Json"];
  index: Scalars["Int"];
  coachId: Scalars["Int"];
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads a single `WorkoutNode` that is related to this `WorkoutNode`. */
  workoutNodeByParentId?: Maybe<IWorkoutNode>;
  /** Reads a single `Workout` that is related to this `WorkoutNode`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Exercise` that is related to this `WorkoutNode`. */
  exerciseByExerciseId?: Maybe<IExercise>;
  /** Reads a single `Coach` that is related to this `WorkoutNode`. */
  coachByCoachId?: Maybe<ICoach>;
  /** Reads and enables pagination through a set of `WorkoutNode`. */
  workoutNodesByParentId: IWorkoutNodesConnection;
}

export interface IWorkoutNodeWorkoutNodesByParentIdArgs {
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  before?: Maybe<Scalars["Cursor"]>;
  after?: Maybe<Scalars["Cursor"]>;
  orderBy?: Maybe<IWorkoutNodesOrderBy[]>;
  condition?: Maybe<IWorkoutNodeCondition>;
}

/**
 * A condition to be used against `WorkoutNode` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 **/
export interface IWorkoutNodeCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `workoutId` field. */
  workoutId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `exerciseId` field. */
  exerciseId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `meta` field. */
  meta?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `index` field. */
  index?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface IWorkoutNodeEvent  extends INode {
   __typename?: "WorkoutNodeEvent";
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars["ID"];
  id: Scalars["Uuid"];
  type: IWorkoutNodeEventType;
  workoutId?: Maybe<Scalars["Uuid"]>;
  coachId: Scalars["Int"];
  timestamp: Scalars["Datetime"];
  workspaceId?: Maybe<Scalars["Int"]>;
  payload: Scalars["Json"];
  updatedAt: Scalars["Datetime"];
  createdAt: Scalars["Datetime"];
  ksOrgId?: Maybe<Scalars["String"]>;
  /** Reads a single `Workout` that is related to this `WorkoutNodeEvent`. */
  workoutByWorkoutId?: Maybe<IWorkout>;
  /** Reads a single `Coach` that is related to this `WorkoutNodeEvent`. */
  coachByCoachId?: Maybe<ICoach>;
}

/**
 * A condition to be used against `WorkoutNodeEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 **/
export interface IWorkoutNodeEventCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<IWorkoutNodeEventType>;
  /** Checks for equality with the object’s `workoutId` field. */
  workoutId?: Maybe<Scalars["Uuid"]>;
  /** Checks for equality with the object’s `coachId` field. */
  coachId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `workspaceId` field. */
  workspaceId?: Maybe<Scalars["Int"]>;
  /** Checks for equality with the object’s `payload` field. */
  payload?: Maybe<Scalars["Json"]>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars["Datetime"]>;
  /** Checks for equality with the object’s `ksOrgId` field. */
  ksOrgId?: Maybe<Scalars["String"]>;
}

export interface IWorkoutNodeEventInput {
  type: IWorkoutNodeEventType;
  workoutId: Scalars["Uuid"];
  coachId: Scalars["Int"];
  timestamp: Scalars["Datetime"];
  workspaceId: Scalars["Int"];
  payload: Scalars["Json"];
  name?: Maybe<Scalars["String"]>;
  body?: Maybe<Scalars["Json"]>;
  duration?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `WorkoutNodeEvent`. Fields that are set will be updated. */
export interface IWorkoutNodeEventPatch {
  id?: Maybe<Scalars["Uuid"]>;
  type?: Maybe<IWorkoutNodeEventType>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  coachId?: Maybe<Scalars["Int"]>;
  timestamp?: Maybe<Scalars["Datetime"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  payload?: Maybe<Scalars["Json"]>;
  updatedAt?: Maybe<Scalars["Datetime"]>;
  createdAt?: Maybe<Scalars["Datetime"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `WorkoutNodeEvent` values. */
export interface IWorkoutNodeEventsConnection {
   __typename?: "WorkoutNodeEventsConnection";
  /** A list of `WorkoutNodeEvent` objects. */
  nodes: Array<Maybe<IWorkoutNodeEvent>>;
  /** A list of edges which contains the `WorkoutNodeEvent` and cursor to aid in pagination. */
  edges: IWorkoutNodeEventsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `WorkoutNodeEvent` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `WorkoutNodeEvent` edge in the connection. */
export interface IWorkoutNodeEventsEdge {
   __typename?: "WorkoutNodeEventsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `WorkoutNodeEvent` at the end of the edge. */
  node?: Maybe<IWorkoutNodeEvent>;
}

/** Methods to use when ordering `WorkoutNodeEvent`. */
export enum IWorkoutNodeEventsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  TypeAsc = "TYPE_ASC",
  TypeDesc = "TYPE_DESC",
  WorkoutIdAsc = "WORKOUT_ID_ASC",
  WorkoutIdDesc = "WORKOUT_ID_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  TimestampAsc = "TIMESTAMP_ASC",
  TimestampDesc = "TIMESTAMP_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  PayloadAsc = "PAYLOAD_ASC",
  PayloadDesc = "PAYLOAD_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export enum IWorkoutNodeEventType {
  Draft = "DRAFT",
  Publish = "PUBLISH",
}

/** An input for mutations affecting `WorkoutNode` */
export interface IWorkoutNodeInput {
  id?: Maybe<Scalars["Uuid"]>;
  parentId?: Maybe<Scalars["Uuid"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  exerciseId?: Maybe<Scalars["Uuid"]>;
  meta: Scalars["Json"];
  index: Scalars["Int"];
  coachId: Scalars["Int"];
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** Represents an update to a `WorkoutNode`. Fields that are set will be updated. */
export interface IWorkoutNodePatch {
  id?: Maybe<Scalars["Uuid"]>;
  parentId?: Maybe<Scalars["Uuid"]>;
  workoutId?: Maybe<Scalars["Uuid"]>;
  exerciseId?: Maybe<Scalars["Uuid"]>;
  meta?: Maybe<Scalars["Json"]>;
  index?: Maybe<Scalars["Int"]>;
  coachId?: Maybe<Scalars["Int"]>;
  workspaceId?: Maybe<Scalars["Int"]>;
  ksOrgId?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `WorkoutNode` values. */
export interface IWorkoutNodesConnection {
   __typename?: "WorkoutNodesConnection";
  /** A list of `WorkoutNode` objects. */
  nodes: Array<Maybe<IWorkoutNode>>;
  /** A list of edges which contains the `WorkoutNode` and cursor to aid in pagination. */
  edges: IWorkoutNodesEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `WorkoutNode` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `WorkoutNode` edge in the connection. */
export interface IWorkoutNodesEdge {
   __typename?: "WorkoutNodesEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `WorkoutNode` at the end of the edge. */
  node?: Maybe<IWorkoutNode>;
}

/** Methods to use when ordering `WorkoutNode`. */
export enum IWorkoutNodesOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  ParentIdAsc = "PARENT_ID_ASC",
  ParentIdDesc = "PARENT_ID_DESC",
  WorkoutIdAsc = "WORKOUT_ID_ASC",
  WorkoutIdDesc = "WORKOUT_ID_DESC",
  ExerciseIdAsc = "EXERCISE_ID_ASC",
  ExerciseIdDesc = "EXERCISE_ID_DESC",
  MetaAsc = "META_ASC",
  MetaDesc = "META_DESC",
  IndexAsc = "INDEX_ASC",
  IndexDesc = "INDEX_DESC",
  CoachIdAsc = "COACH_ID_ASC",
  CoachIdDesc = "COACH_ID_DESC",
  WorkspaceIdAsc = "WORKSPACE_ID_ASC",
  WorkspaceIdDesc = "WORKSPACE_ID_DESC",
  KsOrgIdAsc = "KS_ORG_ID_ASC",
  KsOrgIdDesc = "KS_ORG_ID_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IWorkoutPatch {
  name?: Maybe<Scalars["String"]>;
  body?: Maybe<Scalars["Json"]>;
  duration?: Maybe<Scalars["String"]>;
  notes?: Maybe<Scalars["String"]>;
}

/** A connection to a list of `Workout` values. */
export interface IWorkoutsConnection {
   __typename?: "WorkoutsConnection";
  /** A list of `Workout` objects. */
  nodes: Array<Maybe<IWorkout>>;
  /** A list of edges which contains the `Workout` and cursor to aid in pagination. */
  edges: IWorkoutsEdge[];
  /** Information to aid in pagination. */
  pageInfo: IPageInfo;
  /** The count of *all* `Workout` you could get from the connection. */
  totalCount?: Maybe<Scalars["Int"]>;
}

/** A `Workout` edge in the connection. */
export interface IWorkoutsEdge {
   __typename?: "WorkoutsEdge";
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars["Cursor"]>;
  /** The `Workout` at the end of the edge. */
  node?: Maybe<IWorkout>;
}

export interface IWorkoutSession {
   __typename?: "WorkoutSession";
  /** Public ID of a workout */
  id: Scalars["ID"];
  /** Workout template used as a plan for a workout */
  workoutTemplate?: Maybe<IWorkoutTemplate>;
  /** Date of workout */
  date: Scalars["NaiveDate"];
  /** Binary representation of workout */
  body?: Maybe<Scalars["String"]>;
  /** Flag of whether the workout is completed or not */
  isCompleted: Scalars["Boolean"];
  /** Meta information about the session */
  meta: IShortWorkoutMeta;
}

export interface IWorkoutSessionsConnection {
   __typename?: "WorkoutSessionsConnection";
  /** List of available workout sessions */
  nodes: IWorkoutSession[];
  /** Total number of available workout sessions */
  totalCount: Scalars["Int"];
}

/** Methods to use when ordering `Workout`. */
export enum IWorkoutsOrderBy {
  Natural = "NATURAL",
  IdAsc = "ID_ASC",
  IdDesc = "ID_DESC",
  NameAsc = "NAME_ASC",
  NameDesc = "NAME_DESC",
  BodyAsc = "BODY_ASC",
  BodyDesc = "BODY_DESC",
  UpdatedAtAsc = "UPDATED_AT_ASC",
  UpdatedAtDesc = "UPDATED_AT_DESC",
  CreatedAtAsc = "CREATED_AT_ASC",
  CreatedAtDesc = "CREATED_AT_DESC",
  DurationAsc = "DURATION_ASC",
  DurationDesc = "DURATION_DESC",
  NotesAsc = "NOTES_ASC",
  NotesDesc = "NOTES_DESC",
  IsArchivedAsc = "IS_ARCHIVED_ASC",
  IsArchivedDesc = "IS_ARCHIVED_DESC",
  V3CompilationStatusAsc = "V3_COMPILATION_STATUS_ASC",
  V3CompilationStatusDesc = "V3_COMPILATION_STATUS_DESC",
  PrimaryKeyAsc = "PRIMARY_KEY_ASC",
  PrimaryKeyDesc = "PRIMARY_KEY_DESC",
}

export interface IWorkoutTemplate {
   __typename?: "WorkoutTemplate";
  /** Public ID of a workout template */
  id: Scalars["ID"];
  /** Binary representation provided by a client builder */
  body: Scalars["String"];
  /** Timestamp of the last update */
  updatedAt: Scalars["NaiveDateTime"];
  /** Version of the binary generation */
  version: Scalars["Int"];
  /** Compiled model of a workout template */
  sequence: Scalars["String"];
  /** Name of the template */
  name: Scalars["String"];
  /** Number of weeks in the template */
  phaseNum: Scalars["Int"];
  /** Map of sets in the template (on the first week) */
  setMap: Array<Scalars["String"]>;
  /** Expected duration of one session (on the first week) */
  duration?: Maybe<Scalars["Int"]>;
  /** Random notes for a whole template */
  notes?: Maybe<Scalars["String"]>;
  /** Expected difficulty of a workout */
  difficulty?: Maybe<Scalars["String"]>;
  /** Author of workout */
  authorId: Scalars["ID"];
  /** Is template shared with anyone */
  isShared: Scalars["Boolean"];
  /** Is template created in a context of plan */
  isContextual: Scalars["Boolean"];
  author?: Maybe<IUser>;
}

export interface IWorkoutTemplateDirectoriesConnection {
   __typename?: "WorkoutTemplateDirectoriesConnection";
  /** List of available workout templates */
  nodes: IWorkoutTemplateDirectory[];
  /** Total number of available workout templates */
  totalCount: Scalars["Int"];
}

export interface IWorkoutTemplateDirectory {
   __typename?: "WorkoutTemplateDirectory";
  id: Scalars["ID"];
  name: Scalars["String"];
  parentId?: Maybe<Scalars["ID"]>;
  updatedAt: Scalars["NaiveDateTime"];
  createdAt: Scalars["NaiveDateTime"];
}

export interface IWorkoutTemplateDirectoryInput {
  name: Scalars["String"];
  parentId?: Maybe<Scalars["ID"]>;
}

export interface IWorkoutTemplateDirectoryPatch {
  name?: Maybe<Scalars["String"]>;
}

export enum IWorkoutTemplateFilter {
  Own = "OWN",
  Assigned = "ASSIGNED",
  Club = "CLUB",
  Org = "ORG",
  Keystone = "KEYSTONE",
  All = "ALL",
}

export interface IWorkoutTemplateInput {
  /** ID of template to be saved */
  id: Scalars["ID"];
  /** Name of template */
  name: Scalars["String"];
  /** Version of the template builder */
  version: Scalars["Int"];
  /** AST tree from Kata */
  ast: Scalars["String"];
  /** Text source */
  body: Scalars["String"];
  /** Difficulty (any text) */
  difficulty?: Maybe<Scalars["String"]>;
  /** Duration in minutes */
  duration?: Maybe<Scalars["Int"]>;
  /** Notes */
  notes?: Maybe<Scalars["String"]>;
  /** ID of the parent template */
  parentId?: Maybe<Scalars["ID"]>;
  /** ID of the contextual training plan */
  planId?: Maybe<Scalars["ID"]>;
  /** ID of the template directory */
  directoryId?: Maybe<Scalars["ID"]>;
}

export interface IWorkoutTemplatesConnection {
   __typename?: "WorkoutTemplatesConnection";
  /** List of available workout templates */
  nodes: IWorkoutTemplate[];
  /** Total number of available workout templates */
  totalCount: Scalars["Int"];
}

export interface IWorkspaceInvite {
   __typename?: "WorkspaceInvite";
  email?: Maybe<Scalars["String"]>;
  isAccepted?: Maybe<Scalars["Boolean"]>;
  firstName?: Maybe<Scalars["String"]>;
  workspaceId?: Maybe<Scalars["String"]>;
  workspaceName?: Maybe<Scalars["String"]>;
}
